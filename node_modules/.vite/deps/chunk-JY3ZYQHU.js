import {
  D,
  N,
  Qt,
  Ut,
  Vn,
  _,
  esm_exports,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  jt,
  require_cjs,
  require_cjs2,
  require_random,
  require_sha256,
  us,
  xr
} from "./chunk-D6DUIPOT.js";
import {
  _classPrivateMethodGet,
  _classPrivateMethodInitSpec
} from "./chunk-ZXQ5YOFG.js";
import {
  getInjectedMetamaskProvider
} from "./chunk-Z444LTOS.js";
import {
  assertWindowEthereum
} from "./chunk-BL3IWORX.js";
import {
  walletIds
} from "./chunk-PRPWH2ZE.js";
import {
  _classPrivateFieldGet,
  _classPrivateFieldInitSpec,
  _classPrivateFieldSet
} from "./chunk-64WJJLDE.js";
import {
  WagmiAdapter
} from "./chunk-JHPQ3DUV.js";
import {
  _defineProperty
} from "./chunk-6OBQOEDS.js";
import {
  require_events
} from "./chunk-UR4CD6SH.js";
import {
  NATIVE_TOKEN_ADDRESS,
  fetchCurrencyValue,
  isNativeToken,
  normalizePriceValue
} from "./chunk-7L73S5DV.js";
import {
  c1,
  defaultChains,
  updateChainRPCs
} from "./chunk-DMOEZRHT.js";
import {
  eventemitter3_default
} from "./chunk-ADEMXSHQ.js";
import {
  Contract,
  Wallet,
  init_lib7 as init_lib3,
  utils_exports
} from "./chunk-LSMB6K3F.js";
import {
  hashMessage,
  init_lib11 as init_lib,
  init_lib15 as init_lib2,
  lib_exports19 as lib_exports,
  recoverAddress
} from "./chunk-7GXO2BXT.js";
import {
  init_shim,
  require_buffer
} from "./chunk-6SWLQQ3Q.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-GN3OLCG2.js";

// node_modules/unfetch/dist/unfetch.module.js
var unfetch_module_exports = {};
__export(unfetch_module_exports, {
  default: () => unfetch_module_default
});
function unfetch_module_default(e, n) {
  return n = n || {}, new Promise(function(t, r) {
    var s = new XMLHttpRequest(), o2 = [], u2 = [], i = {}, a = function() {
      return { ok: 2 == (s.status / 100 | 0), statusText: s.statusText, status: s.status, url: s.responseURL, text: function() {
        return Promise.resolve(s.responseText);
      }, json: function() {
        return Promise.resolve(s.responseText).then(JSON.parse);
      }, blob: function() {
        return Promise.resolve(new Blob([s.response]));
      }, clone: a, headers: { keys: function() {
        return o2;
      }, entries: function() {
        return u2;
      }, get: function(e2) {
        return i[e2.toLowerCase()];
      }, has: function(e2) {
        return e2.toLowerCase() in i;
      } } };
    };
    for (var l2 in s.open(n.method || "get", e, true), s.onload = function() {
      s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(e2, n2, t2) {
        o2.push(n2 = n2.toLowerCase()), u2.push([n2, t2]), i[n2] = i[n2] ? i[n2] + "," + t2 : t2;
      }), t(a());
    }, s.onerror = r, s.withCredentials = "include" == n.credentials, n.headers)
      s.setRequestHeader(l2, n.headers[l2]);
    s.send(n.body || null);
  });
}
var init_unfetch_module = __esm({
  "node_modules/unfetch/dist/unfetch.module.js"() {
    init_shim();
  }
});

// node_modules/isomorphic-unfetch/browser.js
var require_browser = __commonJS({
  "node_modules/isomorphic-unfetch/browser.js"(exports, module) {
    init_shim();
    module.exports = self.fetch || (self.fetch = (init_unfetch_module(), __toCommonJS(unfetch_module_exports)).default || (init_unfetch_module(), __toCommonJS(unfetch_module_exports)));
  }
});

// node_modules/@thirdweb-dev/wallets/dist/smart-wallet-b682d05a.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/wallets/dist/base-2087ffde.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/wallets/evm/wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js
init_shim();
init_lib3();
var ERC20WithDecimalsAbi = [{
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "address",
    name: "owner",
    type: "address"
  }, {
    indexed: true,
    internalType: "address",
    name: "spender",
    type: "address"
  }, {
    indexed: false,
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "Approval",
  type: "event"
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "address",
    name: "from",
    type: "address"
  }, {
    indexed: true,
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    indexed: false,
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "Transfer",
  type: "event"
}, {
  inputs: [{
    internalType: "address",
    name: "owner",
    type: "address"
  }, {
    internalType: "address",
    name: "spender",
    type: "address"
  }],
  name: "allowance",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "spender",
    type: "address"
  }, {
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "approve",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "who",
    type: "address"
  }],
  name: "balanceOf",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "totalSupply",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "transfer",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "from",
    type: "address"
  }, {
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "transferFrom",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [],
  name: "decimals",
  outputs: [{
    internalType: "uint8",
    name: "",
    type: "uint8"
  }],
  stateMutability: "view",
  type: "function"
}];
function createErc20(provider, currencyAddress) {
  return new Contract(currencyAddress, ERC20WithDecimalsAbi, provider);
}
function chainIdToThirdwebRpc(chainId, clientId) {
  return `https://${chainId}.rpc.thirdweb.com${clientId ? `/${clientId}` : ""}${typeof globalThis !== "undefined" && "APP_BUNDLE_ID" in globalThis ? `?bundleId=${globalThis.APP_BUNDLE_ID}` : ""}`;
}
var EIP1271_ABI = ["function isValidSignature(bytes32 _message, bytes _signature) public view returns (bytes4)"];
var EIP1271_MAGICVALUE = "0x1626ba7e";
async function checkContractWalletSignature(message, signature, address, chainId) {
  const provider = new lib_exports.JsonRpcProvider(chainIdToThirdwebRpc(chainId));
  const walletContract = new Contract(address, EIP1271_ABI, provider);
  const _hashMessage = utils_exports.hashMessage(message);
  try {
    const res = await walletContract.isValidSignature(_hashMessage, signature);
    return res === EIP1271_MAGICVALUE;
  } catch {
    return false;
  }
}
var AbstractWallet = class extends eventemitter3_default {
  constructor() {
    super(...arguments);
    _defineProperty(this, "type", "evm");
  }
  async getAddress() {
    const signer = await this.getSigner();
    return signer.getAddress();
  }
  async getBalance() {
    let currencyAddress = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : NATIVE_TOKEN_ADDRESS;
    const signer = await this.getSigner();
    const address = await this.getAddress();
    if (!signer.provider) {
      throw new Error("Please connect a provider");
    }
    let balance;
    if (isNativeToken(currencyAddress)) {
      balance = await signer.provider.getBalance(address);
    } else {
      const erc20 = createErc20(signer, currencyAddress);
      balance = await erc20.balanceOf(address);
    }
    return await fetchCurrencyValue(signer.provider, currencyAddress, balance);
  }
  async getChainId() {
    const signer = await this.getSigner();
    return signer.getChainId();
  }
  async transfer(to, amount) {
    let currencyAddress = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NATIVE_TOKEN_ADDRESS;
    const signer = await this.getSigner();
    const from = await this.getAddress();
    if (!signer.provider) {
      throw new Error("Please connect a provider");
    }
    const value = await normalizePriceValue(signer.provider, amount, currencyAddress);
    if (isNativeToken(currencyAddress)) {
      const tx = await signer.sendTransaction({
        from,
        to,
        value
      });
      return {
        receipt: await tx.wait()
      };
    } else {
      const erc20 = createErc20(signer, currencyAddress);
      const tx = await erc20.transfer(to, value);
      return {
        receipt: await tx.wait()
      };
    }
  }
  async signMessage(message) {
    const signer = await this.getSigner();
    return await signer.signMessage(message);
  }
  async verifySignature(message, signature, address, chainId) {
    try {
      const messageHash = utils_exports.hashMessage(message);
      const messageHashBytes = utils_exports.arrayify(messageHash);
      const recoveredAddress = utils_exports.recoverAddress(messageHashBytes, signature);
      if (recoveredAddress === address) {
        return true;
      }
    } catch {
    }
    if (chainId !== void 0) {
      try {
        const isValid = await checkContractWalletSignature(message, signature, address, chainId || 1);
        return isValid;
      } catch {
      }
    }
    return false;
  }
};

// node_modules/@thirdweb-dev/wallets/dist/base-2087ffde.browser.esm.js
var PREFIX = "__TW__";
var AsyncLocalStorage = class {
  constructor(name) {
    this.name = name;
  }
  getItem(key) {
    return new Promise((res) => {
      res(localStorage.getItem(`${PREFIX}/${this.name}/${key}`));
    });
  }
  setItem(key, value) {
    return new Promise((res, rej) => {
      try {
        localStorage.setItem(`${PREFIX}/${this.name}/${key}`, value);
        res();
      } catch (e) {
        rej(e);
      }
    });
  }
  removeItem(key) {
    return new Promise((res) => {
      localStorage.removeItem(`${PREFIX}/${this.name}/${key}`);
      res();
    });
  }
};
function createAsyncLocalStorage(name) {
  return new AsyncLocalStorage(name);
}
var DEFAULT_DAPP_META = {
  name: "thirdweb powered dApp",
  url: "https://thirdweb.com",
  description: "thirdweb powered dApp",
  logoUrl: "https://thirdweb.com/favicon.ico",
  isDarkMode: true
};
var _connectParams = /* @__PURE__ */ new WeakMap();
var _connect = /* @__PURE__ */ new WeakSet();
var _subscribeToEvents = /* @__PURE__ */ new WeakSet();
var AbstractClientWallet = class extends AbstractWallet {
  getMeta() {
    return this.constructor.meta;
  }
  constructor(walletId, options) {
    super();
    _classPrivateMethodInitSpec(this, _subscribeToEvents);
    _classPrivateMethodInitSpec(this, _connect);
    _classPrivateFieldInitSpec(this, _connectParams, {
      writable: true,
      value: void 0
    });
    this.walletId = walletId;
    this.options = options;
    this.chains = ((options == null ? void 0 : options.chains) || defaultChains).map((c) => updateChainRPCs(c, options == null ? void 0 : options.clientId));
    this.dappMetadata = (options == null ? void 0 : options.dappMetadata) || DEFAULT_DAPP_META;
    this.walletStorage = (options == null ? void 0 : options.walletStorage) || createAsyncLocalStorage(this.walletId);
  }
  async autoConnect(connectOptions) {
    const options = connectOptions ? {
      ...connectOptions,
      chainId: void 0
    } : void 0;
    return _classPrivateMethodGet(this, _connect, _connect2).call(this, true, options);
  }
  async connect(connectOptions) {
    _classPrivateFieldSet(this, _connectParams, connectOptions);
    const address = await _classPrivateMethodGet(this, _connect, _connect2).call(this, false, connectOptions);
    if (!address) {
      throw new Error("Failed to connect to the wallet.");
    }
    return address;
  }
  getConnectParams() {
    return _classPrivateFieldGet(this, _connectParams);
  }
  async getSigner() {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    return await connector.getSigner();
  }
  async disconnect() {
    const connector = await this.getConnector();
    if (connector) {
      await connector.disconnect();
      this.emit("disconnect");
      connector.removeAllListeners();
    }
  }
  async switchChain(chainId) {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    if (!connector.switchChain) {
      throw new Error("Wallet does not support switching chains");
    }
    return await connector.switchChain(chainId);
  }
  async updateChains(chains) {
    this.chains = chains.map((c) => {
      var _a;
      return updateChainRPCs(c, (_a = this.options) == null ? void 0 : _a.clientId);
    });
    const connector = await this.getConnector();
    connector.updateChains(this.chains);
  }
  getPersonalWallet() {
    return void 0;
  }
};
async function _connect2(isAutoConnect, connectOptions) {
  const connector = await this.getConnector();
  _classPrivateMethodGet(this, _subscribeToEvents, _subscribeToEvents2).call(this, connector);
  const isConnected = await connector.isConnected();
  if (isConnected) {
    const address = await connector.getAddress();
    connector.setupListeners();
    if (connectOptions == null ? void 0 : connectOptions.chainId) {
      await connector.switchChain(connectOptions == null ? void 0 : connectOptions.chainId);
    }
    this.emit("connect", {
      address,
      chainId: await this.getChainId()
    });
    return address;
  }
  if (isAutoConnect) {
    throw new Error("Failed to auto connect to the wallet.");
  }
  try {
    const address = await connector.connect(connectOptions);
    return address;
  } catch (error) {
    throw new Error(error.message);
  }
}
async function _subscribeToEvents2(connector) {
  connector.on("connect", (data) => {
    var _a;
    this.emit("connect", {
      address: data.account,
      chainId: (_a = data.chain) == null ? void 0 : _a.id
    });
  });
  connector.on("change", (data) => {
    var _a;
    this.emit("change", {
      address: data.account,
      chainId: (_a = data.chain) == null ? void 0 : _a.id
    });
  });
  connector.on("message", (data) => {
    this.emit("message", data);
  });
  connector.on("disconnect", async () => {
    this.emit("disconnect");
  });
  connector.on("error", (error) => this.emit("error", error));
}

// node_modules/@walletconnect/web3wallet/dist/index.es.js
init_shim();

// node_modules/@walletconnect/auth-client/dist/index.es.js
init_shim();
var import_logger = __toESM(require_cjs2());
var import_events = __toESM(require_events());
var import_time = __toESM(require_cjs());
init_lib();
init_lib2();
var import_isomorphic_unfetch = __toESM(require_browser());
var import_random = __toESM(require_random());
var import_sha256 = __toESM(require_sha256());
var J = class {
  constructor(t) {
    this.client = t;
  }
};
var X = class {
  constructor(t) {
    this.opts = t;
  }
};
var G = "https://rpc.walletconnect.com/v1";
var R = { wc_authRequest: { req: { ttl: import_time.ONE_DAY, prompt: true, tag: 3e3 }, res: { ttl: import_time.ONE_DAY, prompt: false, tag: 3001 } } };
var U = { min: import_time.FIVE_MINUTES, max: import_time.SEVEN_DAYS };
var B = "wc";
var H = 1;
var Y = "auth";
var N2 = "authClient";
var F = `${B}@${1}:${Y}:`;
var x = `${F}:PUB_KEY`;
function P(r) {
  return r == null ? void 0 : r.split(":");
}
function He(r) {
  const t = r && P(r);
  if (t)
    return t[3];
}
function Ye(r) {
  const t = r && P(r);
  if (t)
    return t[2] + ":" + t[3];
}
function Q(r) {
  const t = r && P(r);
  if (t)
    return t.pop();
}
async function Qe(r, t, e, i, n) {
  switch (e.t) {
    case "eip191":
      return Ze(r, t, e.s);
    case "eip1271":
      return await We(r, t, e.s, i, n);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${e.t}`);
  }
}
function Ze(r, t, e) {
  return recoverAddress(hashMessage(t), e).toLowerCase() === r.toLowerCase();
}
async function We(r, t, e, i, n) {
  try {
    const s = "0x1626ba7e", u2 = "0000000000000000000000000000000000000000000000000000000000000040", o2 = "0000000000000000000000000000000000000000000000000000000000000041", a = e.substring(2), h = hashMessage(t).substring(2), D3 = s + h + u2 + o2 + a, p2 = await (0, import_isomorphic_unfetch.default)(`${G}/?chainId=${i}&projectId=${n}`, { method: "POST", body: JSON.stringify({ id: et(), jsonrpc: "2.0", method: "eth_call", params: [{ to: r, data: D3 }, "latest"] }) }), { result: g2 } = await p2.json();
    return g2 ? g2.slice(0, s.length).toLowerCase() === s.toLowerCase() : false;
  } catch (s) {
    return console.error("isValidEip1271Signature: ", s), false;
  }
}
function et() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function Z(r) {
  return r.getAll().filter((t) => "requester" in t);
}
function W(r, t) {
  return Z(r).find((e) => e.id === t);
}
function tt(r) {
  const t = jt(r.aud), e = new RegExp(`${r.domain}`).test(r.aud), i = !!r.nonce, n = r.type ? r.type === "eip4361" : true, s = r.expiry;
  if (s && !Qt(s, U)) {
    const { message: u2 } = N("MISSING_OR_INVALID", `request() expiry: ${s}. Expiry must be a number (in seconds) between ${U.min} and ${U.max}`);
    throw new Error(u2);
  }
  return !!(t && e && i && n);
}
function rt(r, t) {
  return !!W(t, r.id);
}
function it(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r) : new Uint8Array(r);
}
function nt(r, t) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var e = new Uint8Array(256), i = 0; i < e.length; i++)
    e[i] = 255;
  for (var n = 0; n < r.length; n++) {
    var s = r.charAt(n), u2 = s.charCodeAt(0);
    if (e[u2] !== 255)
      throw new TypeError(s + " is ambiguous");
    e[u2] = n;
  }
  var o2 = r.length, a = r.charAt(0), h = Math.log(o2) / Math.log(256), D3 = Math.log(256) / Math.log(o2);
  function p2(c) {
    if (c instanceof Uint8Array || (ArrayBuffer.isView(c) ? c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength) : Array.isArray(c) && (c = Uint8Array.from(c))), !(c instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (c.length === 0)
      return "";
    for (var f2 = 0, _3 = 0, b2 = 0, w2 = c.length; b2 !== w2 && c[b2] === 0; )
      b2++, f2++;
    for (var C2 = (w2 - b2) * D3 + 1 >>> 0, E2 = new Uint8Array(C2); b2 !== w2; ) {
      for (var m2 = c[b2], A = 0, y2 = C2 - 1; (m2 !== 0 || A < _3) && y2 !== -1; y2--, A++)
        m2 += 256 * E2[y2] >>> 0, E2[y2] = m2 % o2 >>> 0, m2 = m2 / o2 >>> 0;
      if (m2 !== 0)
        throw new Error("Non-zero carry");
      _3 = A, b2++;
    }
    for (var v = C2 - _3; v !== C2 && E2[v] === 0; )
      v++;
    for (var I2 = a.repeat(f2); v < C2; ++v)
      I2 += r.charAt(E2[v]);
    return I2;
  }
  function g2(c) {
    if (typeof c != "string")
      throw new TypeError("Expected String");
    if (c.length === 0)
      return new Uint8Array();
    var f2 = 0;
    if (c[f2] !== " ") {
      for (var _3 = 0, b2 = 0; c[f2] === a; )
        _3++, f2++;
      for (var w2 = (c.length - f2) * h + 1 >>> 0, C2 = new Uint8Array(w2); c[f2]; ) {
        var E2 = e[c.charCodeAt(f2)];
        if (E2 === 255)
          return;
        for (var m2 = 0, A = w2 - 1; (E2 !== 0 || m2 < b2) && A !== -1; A--, m2++)
          E2 += o2 * C2[A] >>> 0, C2[A] = E2 % 256 >>> 0, E2 = E2 / 256 >>> 0;
        if (E2 !== 0)
          throw new Error("Non-zero carry");
        b2 = m2, f2++;
      }
      if (c[f2] !== " ") {
        for (var y2 = w2 - b2; y2 !== w2 && C2[y2] === 0; )
          y2++;
        for (var v = new Uint8Array(_3 + (w2 - y2)), I2 = _3; y2 !== w2; )
          v[I2++] = C2[y2++];
        return v;
      }
    }
  }
  function l2(c) {
    var f2 = g2(c);
    if (f2)
      return f2;
    throw new Error(`Non-${t} character`);
  }
  return { encode: p2, decodeUnsafe: g2, decode: l2 };
}
var st = nt;
var ut = st;
var ee = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
    return r;
  if (r instanceof ArrayBuffer)
    return new Uint8Array(r);
  if (ArrayBuffer.isView(r))
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ot = (r) => new TextEncoder().encode(r);
var at = (r) => new TextDecoder().decode(r);
var Dt = class {
  constructor(t, e, i) {
    this.name = t, this.prefix = e, this.baseEncode = i;
  }
  encode(t) {
    if (t instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var ct = class {
  constructor(t, e, i) {
    if (this.name = t, this.prefix = e, e.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = e.codePointAt(0), this.baseDecode = i;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(t) {
    return te(this, t);
  }
};
var ht = class {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return te(this, t);
  }
  decode(t) {
    const e = t[0], i = this.decoders[e];
    if (i)
      return i.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var te = (r, t) => new ht({ ...r.decoders || { [r.prefix]: r }, ...t.decoders || { [t.prefix]: t } });
var lt = class {
  constructor(t, e, i, n) {
    this.name = t, this.prefix = e, this.baseEncode = i, this.baseDecode = n, this.encoder = new Dt(t, e, i), this.decoder = new ct(t, e, n);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
};
var S = ({ name: r, prefix: t, encode: e, decode: i }) => new lt(r, t, e, i);
var T = ({ prefix: r, name: t, alphabet: e }) => {
  const { encode: i, decode: n } = ut(e, t);
  return S({ prefix: r, name: t, encode: i, decode: (s) => ee(n(s)) });
};
var dt = (r, t, e, i) => {
  const n = {};
  for (let D3 = 0; D3 < t.length; ++D3)
    n[t[D3]] = D3;
  let s = r.length;
  for (; r[s - 1] === "="; )
    --s;
  const u2 = new Uint8Array(s * e / 8 | 0);
  let o2 = 0, a = 0, h = 0;
  for (let D3 = 0; D3 < s; ++D3) {
    const p2 = n[r[D3]];
    if (p2 === void 0)
      throw new SyntaxError(`Non-${i} character`);
    a = a << e | p2, o2 += e, o2 >= 8 && (o2 -= 8, u2[h++] = 255 & a >> o2);
  }
  if (o2 >= e || 255 & a << 8 - o2)
    throw new SyntaxError("Unexpected end of data");
  return u2;
};
var pt = (r, t, e) => {
  const i = t[t.length - 1] === "=", n = (1 << e) - 1;
  let s = "", u2 = 0, o2 = 0;
  for (let a = 0; a < r.length; ++a)
    for (o2 = o2 << 8 | r[a], u2 += 8; u2 > e; )
      u2 -= e, s += t[n & o2 >> u2];
  if (u2 && (s += t[n & o2 << e - u2]), i)
    for (; s.length * e & 7; )
      s += "=";
  return s;
};
var d = ({ name: r, prefix: t, bitsPerChar: e, alphabet: i }) => S({ prefix: t, name: r, encode(n) {
  return pt(n, i, e);
}, decode(n) {
  return dt(n, i, e, r);
} });
var ft = S({ prefix: "\0", name: "identity", encode: (r) => at(r), decode: (r) => ot(r) });
var gt = Object.freeze({ __proto__: null, identity: ft });
var Et = d({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var bt = Object.freeze({ __proto__: null, base2: Et });
var yt = d({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var wt = Object.freeze({ __proto__: null, base8: yt });
var Ct = T({ prefix: "9", name: "base10", alphabet: "0123456789" });
var mt = Object.freeze({ __proto__: null, base10: Ct });
var vt = d({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var At = d({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var _t = Object.freeze({ __proto__: null, base16: vt, base16upper: At });
var xt = d({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Rt = d({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Ft = d({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Tt = d({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var It = d({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var Ut2 = d({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var St = d({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Ot = d({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var qt = d({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var $t = Object.freeze({ __proto__: null, base32: xt, base32upper: Rt, base32pad: Ft, base32padupper: Tt, base32hex: It, base32hexupper: Ut2, base32hexpad: St, base32hexpadupper: Ot, base32z: qt });
var Bt = T({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var Nt = T({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Pt = Object.freeze({ __proto__: null, base36: Bt, base36upper: Nt });
var zt = T({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Mt = T({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var jt2 = Object.freeze({ __proto__: null, base58btc: zt, base58flickr: Mt });
var Lt = d({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Kt = d({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Vt = d({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var kt = d({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Jt = Object.freeze({ __proto__: null, base64: Lt, base64pad: Kt, base64url: Vt, base64urlpad: kt });
var re = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var Xt = re.reduce((r, t, e) => (r[e] = t, r), []);
var Gt = re.reduce((r, t, e) => (r[t.codePointAt(0)] = e, r), []);
function Ht(r) {
  return r.reduce((t, e) => (t += Xt[e], t), "");
}
function Yt(r) {
  const t = [];
  for (const e of r) {
    const i = Gt[e.codePointAt(0)];
    if (i === void 0)
      throw new Error(`Non-base256emoji character: ${e}`);
    t.push(i);
  }
  return new Uint8Array(t);
}
var Qt2 = S({ prefix: "\u{1F680}", name: "base256emoji", encode: Ht, decode: Yt });
var Zt = Object.freeze({ __proto__: null, base256emoji: Qt2 });
var Wt = ne;
var ie = 128;
var er = 127;
var tr = ~er;
var rr = Math.pow(2, 31);
function ne(r, t, e) {
  t = t || [], e = e || 0;
  for (var i = e; r >= rr; )
    t[e++] = r & 255 | ie, r /= 128;
  for (; r & tr; )
    t[e++] = r & 255 | ie, r >>>= 7;
  return t[e] = r | 0, ne.bytes = e - i + 1, t;
}
var ir = z;
var nr = 128;
var se = 127;
function z(r, i) {
  var e = 0, i = i || 0, n = 0, s = i, u2, o2 = r.length;
  do {
    if (s >= o2)
      throw z.bytes = 0, new RangeError("Could not decode varint");
    u2 = r[s++], e += n < 28 ? (u2 & se) << n : (u2 & se) * Math.pow(2, n), n += 7;
  } while (u2 >= nr);
  return z.bytes = s - i, e;
}
var sr = Math.pow(2, 7);
var ur = Math.pow(2, 14);
var or = Math.pow(2, 21);
var ar = Math.pow(2, 28);
var Dr = Math.pow(2, 35);
var cr = Math.pow(2, 42);
var hr = Math.pow(2, 49);
var lr = Math.pow(2, 56);
var dr = Math.pow(2, 63);
var pr = function(r) {
  return r < sr ? 1 : r < ur ? 2 : r < or ? 3 : r < ar ? 4 : r < Dr ? 5 : r < cr ? 6 : r < hr ? 7 : r < lr ? 8 : r < dr ? 9 : 10;
};
var fr = { encode: Wt, decode: ir, encodingLength: pr };
var ue = fr;
var oe = (r, t, e = 0) => (ue.encode(r, t, e), t);
var ae = (r) => ue.encodingLength(r);
var M = (r, t) => {
  const e = t.byteLength, i = ae(r), n = i + ae(e), s = new Uint8Array(n + e);
  return oe(r, s, 0), oe(e, s, i), s.set(t, n), new gr(r, e, t, s);
};
var gr = class {
  constructor(t, e, i, n) {
    this.code = t, this.size = e, this.digest = i, this.bytes = n;
  }
};
var De = ({ name: r, code: t, encode: e }) => new Er(r, t, e);
var Er = class {
  constructor(t, e, i) {
    this.name = t, this.code = e, this.encode = i;
  }
  digest(t) {
    if (t instanceof Uint8Array) {
      const e = this.encode(t);
      return e instanceof Uint8Array ? M(this.code, e) : e.then((i) => M(this.code, i));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var ce = (r) => async (t) => new Uint8Array(await crypto.subtle.digest(r, t));
var br = De({ name: "sha2-256", code: 18, encode: ce("SHA-256") });
var yr = De({ name: "sha2-512", code: 19, encode: ce("SHA-512") });
var wr = Object.freeze({ __proto__: null, sha256: br, sha512: yr });
var he = 0;
var Cr = "identity";
var le = ee;
var mr = (r) => M(he, le(r));
var vr = { code: he, name: Cr, encode: le, digest: mr };
var Ar = Object.freeze({ __proto__: null, identity: vr });
new TextEncoder(), new TextDecoder();
var de = { ...gt, ...bt, ...wt, ...mt, ..._t, ...$t, ...Pt, ...jt2, ...Jt, ...Zt };
({ ...wr, ...Ar });
function pe(r, t, e, i) {
  return { name: r, prefix: t, encoder: { name: r, prefix: t, encode: e }, decoder: { decode: i } };
}
var fe = pe("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1)));
var j = pe("ascii", "a", (r) => {
  let t = "a";
  for (let e = 0; e < r.length; e++)
    t += String.fromCharCode(r[e]);
  return t;
}, (r) => {
  r = r.substring(1);
  const t = it(r.length);
  for (let e = 0; e < r.length; e++)
    t[e] = r.charCodeAt(e);
  return t;
});
var ge = { utf8: fe, "utf-8": fe, hex: de.base16, latin1: j, ascii: j, binary: j, ...de };
function _r(r, t = "utf8") {
  const e = ge[t];
  if (!e)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r, "utf8") : e.decoder.decode(`${e.prefix}${r}`);
}
function xr2(r, t = "utf8") {
  const e = ge[t];
  if (!e)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString("utf8") : e.encoder.encode(r).substring(1);
}
var Ee = "base16";
var be = "utf8";
function ye(r) {
  const t = (0, import_sha256.hash)(_r(r, be));
  return xr2(t, Ee);
}
var Ir = Object.defineProperty;
var Ur = Object.defineProperties;
var Sr = Object.getOwnPropertyDescriptors;
var we = Object.getOwnPropertySymbols;
var Or = Object.prototype.hasOwnProperty;
var qr = Object.prototype.propertyIsEnumerable;
var Ce = (r, t, e) => t in r ? Ir(r, t, { enumerable: true, configurable: true, writable: true, value: e }) : r[t] = e;
var L = (r, t) => {
  for (var e in t || (t = {}))
    Or.call(t, e) && Ce(r, e, t[e]);
  if (we)
    for (var e of we(t))
      qr.call(t, e) && Ce(r, e, t[e]);
  return r;
};
var $r = (r, t) => Ur(r, Sr(t));
var Br = class extends J {
  constructor(t) {
    super(t), this.initialized = false, this.name = "authEngine", this.init = () => {
      this.initialized || (this.registerRelayerEvents(), this.client.core.pairing.register({ methods: Object.keys(R) }), this.initialized = true);
    }, this.request = async (e, i) => {
      if (this.isInitialized(), !tt(e))
        throw new Error("Invalid request");
      if (i != null && i.topic)
        return await this.requestOnKnownPairing(i.topic, e);
      const { chainId: n, statement: s, aud: u2, domain: o2, nonce: a, type: h } = e, { topic: D3, uri: p2 } = await this.client.core.pairing.create();
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: D3, uri: p2 } });
      const g2 = await this.client.core.crypto.generateKeyPair(), l2 = Vn(g2);
      await this.client.authKeys.set(x, { responseTopic: l2, publicKey: g2 }), await this.client.pairingTopics.set(l2, { topic: l2, pairingTopic: D3 }), await this.client.core.relayer.subscribe(l2), this.client.logger.info(`sending request to new pairing topic: ${D3}`);
      const c = await this.sendRequest(D3, "wc_authRequest", { payloadParams: { type: h != null ? h : "eip4361", chainId: n, statement: s, aud: u2, domain: o2, version: "1", nonce: a, iat: new Date().toISOString() }, requester: { publicKey: g2, metadata: this.client.metadata } }, {}, e.expiry);
      return this.client.logger.info(`sent request to new pairing topic: ${D3}`), { uri: p2, id: c };
    }, this.respond = async (e, i) => {
      if (this.isInitialized(), !rt(e, this.client.requests))
        throw new Error("Invalid response");
      const n = W(this.client.requests, e.id), s = n.requester.publicKey, u2 = await this.client.core.crypto.generateKeyPair(), o2 = Vn(s), a = { type: _, receiverPublicKey: s, senderPublicKey: u2 };
      if ("error" in e) {
        await this.sendError(n.id, o2, e, a);
        return;
      }
      const h = { h: { t: "eip4361" }, p: $r(L({}, n.cacaoPayload), { iss: i }), s: e.signature }, D3 = await this.sendResult(n.id, o2, h, a);
      await this.client.requests.update(D3, L({}, h));
    }, this.getPendingRequests = () => Z(this.client.requests), this.formatMessage = (e, i) => {
      this.client.logger.debug(`formatMessage, cacao is: ${JSON.stringify(e)}`);
      const n = `${e.domain} wants you to sign in with your Ethereum account:`, s = Q(i), u2 = e.statement, o2 = `URI: ${e.aud}`, a = `Version: ${e.version}`, h = `Chain ID: ${He(i)}`, D3 = `Nonce: ${e.nonce}`, p2 = `Issued At: ${e.iat}`, g2 = e.resources && e.resources.length > 0 ? `Resources:
${e.resources.map((l2) => `- ${l2}`).join(`
`)}` : void 0;
      return [n, s, "", u2, "", o2, a, h, D3, p2, g2].filter((l2) => l2 != null).join(`
`);
    }, this.setExpiry = async (e, i) => {
      this.client.core.pairing.pairings.keys.includes(e) && await this.client.core.pairing.updateExpiry({ topic: e, expiry: i }), this.client.core.expirer.set(e, i);
    }, this.sendRequest = async (e, i, n, s, u2) => {
      const o2 = formatJsonRpcRequest(i, n), a = await this.client.core.crypto.encode(e, o2, s), h = R[i].req;
      return u2 && (h.ttl = u2), this.client.core.history.set(e, o2), await this.client.core.relayer.publish(e, a, h), o2.id;
    }, this.sendResult = async (e, i, n, s) => {
      const u2 = formatJsonRpcResult(e, n), o2 = await this.client.core.crypto.encode(i, u2, s), a = await this.client.core.history.get(i, e), h = R[a.request.method].res;
      return await this.client.core.relayer.publish(i, o2, h), await this.client.core.history.resolve(u2), u2.id;
    }, this.sendError = async (e, i, n, s) => {
      const u2 = formatJsonRpcError(e, n.error), o2 = await this.client.core.crypto.encode(i, u2, s), a = await this.client.core.history.get(i, e), h = R[a.request.method].res;
      return await this.client.core.relayer.publish(i, o2, h), await this.client.core.history.resolve(u2), u2.id;
    }, this.requestOnKnownPairing = async (e, i) => {
      const n = this.client.core.pairing.pairings.getAll({ active: true }).find((l2) => l2.topic === e);
      if (!n)
        throw new Error(`Could not find pairing for provided topic ${e}`);
      const { publicKey: s } = this.client.authKeys.get(x), { chainId: u2, statement: o2, aud: a, domain: h, nonce: D3, type: p2 } = i, g2 = await this.sendRequest(n.topic, "wc_authRequest", { payloadParams: { type: p2 != null ? p2 : "eip4361", chainId: u2, statement: o2, aud: a, domain: h, version: "1", nonce: D3, iat: new Date().toISOString() }, requester: { publicKey: s, metadata: this.client.metadata } }, {}, i.expiry);
      return this.client.logger.info(`sent request to known pairing topic: ${n.topic}`), { id: g2 };
    }, this.onRelayEventRequest = (e) => {
      const { topic: i, payload: n } = e, s = n.method;
      switch (s) {
        case "wc_authRequest":
          return this.onAuthRequest(i, n);
        default:
          return this.client.logger.info(`Unsupported request method ${s}`);
      }
    }, this.onRelayEventResponse = async (e) => {
      const { topic: i, payload: n } = e, s = (await this.client.core.history.get(i, n.id)).request.method;
      switch (s) {
        case "wc_authRequest":
          return this.onAuthResponse(i, n);
        default:
          return this.client.logger.info(`Unsupported response method ${s}`);
      }
    }, this.onAuthRequest = async (e, i) => {
      const { requester: n, payloadParams: { resources: s, statement: u2, aud: o2, domain: a, version: h, nonce: D3, iat: p2, chainId: g2 } } = i.params;
      this.client.logger.info({ type: "onAuthRequest", topic: e, payload: i });
      try {
        const l2 = { aud: o2, domain: a, version: h, nonce: D3, iat: p2, statement: u2, resources: s, chainId: g2 };
        await this.client.requests.set(i.id, { requester: n, pairingTopic: e, id: i.id, cacaoPayload: l2 });
        const c = ye(JSON.stringify(i)), f2 = await this.getVerifyContext(c, this.client.metadata);
        this.client.emit("auth_request", { id: i.id, topic: e, params: { requester: n, cacaoPayload: l2 }, verifyContext: f2 });
      } catch (l2) {
        await this.sendError(i.id, e, l2), this.client.logger.error(l2);
      }
    }, this.onAuthResponse = async (e, i) => {
      const { id: n } = i;
      if (this.client.logger.info({ type: "onAuthResponse", topic: e, response: i }), isJsonRpcResult(i)) {
        const { pairingTopic: s } = this.client.pairingTopics.get(e);
        await this.client.core.pairing.activate({ topic: s });
        const { s: u2, p: o2 } = i.result;
        await this.client.requests.set(n, L({ id: n, pairingTopic: s }, i.result));
        const a = this.formatMessage(o2, o2.iss);
        this.client.logger.debug(`reconstructed message:
`, JSON.stringify(a)), this.client.logger.debug("payload.iss:", o2.iss), this.client.logger.debug("signature:", u2);
        const h = Q(o2.iss), D3 = Ye(o2.iss);
        if (!h)
          throw new Error("Could not derive address from `payload.iss`");
        if (!D3)
          throw new Error("Could not derive chainId from `payload.iss`");
        this.client.logger.debug("walletAddress extracted from `payload.iss`:", h), await Qe(h, a, u2, D3, this.client.projectId) ? this.client.emit("auth_response", { id: n, topic: e, params: i }) : this.client.emit("auth_response", { id: n, topic: e, params: { message: "Invalid signature", code: -1 } });
      } else
        isJsonRpcError(i) && this.client.emit("auth_response", { id: n, topic: e, params: i });
    }, this.getVerifyContext = async (e, i) => {
      const n = { verified: { verifyUrl: i.verifyUrl || "", validation: "UNKNOWN", origin: i.url || "" } };
      try {
        const s = await this.client.core.verify.resolve({ attestationId: e, verifyUrl: i.verifyUrl });
        s && (n.verified.origin = s, n.verified.validation = s === i.url ? "VALID" : "INVALID");
      } catch (s) {
        this.client.logger.error(s);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(n)}`), n;
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = N("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(D.message, async (t) => {
      const { topic: e, message: i } = t, { responseTopic: n, publicKey: s } = this.client.authKeys.keys.includes(x) ? this.client.authKeys.get(x) : { responseTopic: void 0, publicKey: void 0 };
      if (n && e !== n) {
        this.client.logger.debug("[Auth] Ignoring message from unknown topic", e);
        return;
      }
      const u2 = await this.client.core.crypto.decode(e, i, { receiverPublicKey: s });
      isJsonRpcRequest(u2) ? (this.client.core.history.set(e, u2), this.onRelayEventRequest({ topic: e, payload: u2 })) : isJsonRpcResponse(u2) && (await this.client.core.history.resolve(u2), this.onRelayEventResponse({ topic: e, payload: u2 }));
    });
  }
};
var O = class extends X {
  constructor(t) {
    super(t), this.protocol = B, this.version = H, this.name = N2, this.events = new import_events.EventEmitter(), this.emit = (i, n) => this.events.emit(i, n), this.on = (i, n) => this.events.on(i, n), this.once = (i, n) => this.events.once(i, n), this.off = (i, n) => this.events.off(i, n), this.removeListener = (i, n) => this.events.removeListener(i, n), this.request = async (i, n) => {
      try {
        return await this.engine.request(i, n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.respond = async (i, n) => {
      try {
        return await this.engine.respond(i, n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.getPendingRequests = () => {
      try {
        return this.engine.getPendingRequests();
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.formatMessage = (i, n) => {
      try {
        return this.engine.formatMessage(i, n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    };
    const e = typeof t.logger < "u" && typeof t.logger != "string" ? t.logger : (0, import_logger.pino)((0, import_logger.getDefaultLoggerOptions)({ level: t.logger || "error" }));
    this.name = (t == null ? void 0 : t.name) || N2, this.metadata = t.metadata, this.projectId = t.projectId, this.core = t.core || new xr(t), this.logger = (0, import_logger.generateChildLogger)(e, this.name), this.authKeys = new Ut(this.core, this.logger, "authKeys", F, () => x), this.pairingTopics = new Ut(this.core, this.logger, "pairingTopics", F), this.requests = new Ut(this.core, this.logger, "requests", F), this.engine = new Br(this);
  }
  static async init(t) {
    const e = new O(t);
    return await e.initialize(), e;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.authKeys.init(), await this.requests.init(), await this.pairingTopics.init(), await this.engine.init(), this.logger.info("AuthClient Initialization Success"), this.logger.info({ authClient: this });
    } catch (t) {
      throw this.logger.info("AuthClient Initialization Failure"), this.logger.error(t.message), t;
    }
  }
};
var Nr = O;

// node_modules/@walletconnect/web3wallet/dist/index.es.js
var l = { exports: {} };
var u = typeof Reflect == "object" ? Reflect : null;
var m = u && typeof u.apply == "function" ? u.apply : function(t, e, n) {
  return Function.prototype.apply.call(t, e, n);
};
var f;
u && typeof u.ownKeys == "function" ? f = u.ownKeys : Object.getOwnPropertySymbols ? f = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : f = function(t) {
  return Object.getOwnPropertyNames(t);
};
function T2(s) {
  console && console.warn && console.warn(s);
}
var y = Number.isNaN || function(t) {
  return t !== t;
};
function o() {
  o.init.call(this);
}
l.exports = o, l.exports.once = M2, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
var w = 10;
function g(s) {
  if (typeof s != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof s);
}
Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
  return w;
}, set: function(s) {
  if (typeof s != "number" || s < 0 || y(s))
    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + s + ".");
  w = s;
} }), o.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, o.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || y(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function L2(s) {
  return s._maxListeners === void 0 ? o.defaultMaxListeners : s._maxListeners;
}
o.prototype.getMaxListeners = function() {
  return L2(this);
}, o.prototype.emit = function(t) {
  for (var e = [], n = 1; n < arguments.length; n++)
    e.push(arguments[n]);
  var i = t === "error", a = this._events;
  if (a !== void 0)
    i = i && a.error === void 0;
  else if (!i)
    return false;
  if (i) {
    var r;
    if (e.length > 0 && (r = e[0]), r instanceof Error)
      throw r;
    var h = new Error("Unhandled error." + (r ? " (" + r.message + ")" : ""));
    throw h.context = r, h;
  }
  var c = a[t];
  if (c === void 0)
    return false;
  if (typeof c == "function")
    m(c, this, e);
  else
    for (var v = c.length, A = b(c, v), n = 0; n < v; ++n)
      m(A[n], this, e);
  return true;
};
function _2(s, t, e, n) {
  var i, a, r;
  if (g(e), a = s._events, a === void 0 ? (a = s._events = /* @__PURE__ */ Object.create(null), s._eventsCount = 0) : (a.newListener !== void 0 && (s.emit("newListener", t, e.listener ? e.listener : e), a = s._events), r = a[t]), r === void 0)
    r = a[t] = e, ++s._eventsCount;
  else if (typeof r == "function" ? r = a[t] = n ? [e, r] : [r, e] : n ? r.unshift(e) : r.push(e), i = L2(s), i > 0 && r.length > i && !r.warned) {
    r.warned = true;
    var h = new Error("Possible EventEmitter memory leak detected. " + r.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    h.name = "MaxListenersExceededWarning", h.emitter = s, h.type = t, h.count = r.length, T2(h);
  }
  return s;
}
o.prototype.addListener = function(t, e) {
  return _2(this, t, e, false);
}, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(t, e) {
  return _2(this, t, e, true);
};
function j2() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function S2(s, t, e) {
  var n = { fired: false, wrapFn: void 0, target: s, type: t, listener: e }, i = j2.bind(n);
  return i.listener = e, n.wrapFn = i, i;
}
o.prototype.once = function(t, e) {
  return g(e), this.on(t, S2(this, t, e)), this;
}, o.prototype.prependOnceListener = function(t, e) {
  return g(e), this.prependListener(t, S2(this, t, e)), this;
}, o.prototype.removeListener = function(t, e) {
  var n, i, a, r, h;
  if (g(e), i = this._events, i === void 0)
    return this;
  if (n = i[t], n === void 0)
    return this;
  if (n === e || n.listener === e)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, n.listener || e));
  else if (typeof n != "function") {
    for (a = -1, r = n.length - 1; r >= 0; r--)
      if (n[r] === e || n[r].listener === e) {
        h = n[r].listener, a = r;
        break;
      }
    if (a < 0)
      return this;
    a === 0 ? n.shift() : I(n, a), n.length === 1 && (i[t] = n[0]), i.removeListener !== void 0 && this.emit("removeListener", t, h || e);
  }
  return this;
}, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(t) {
  var e, n, i;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[t]), this;
  if (arguments.length === 0) {
    var a = Object.keys(n), r;
    for (i = 0; i < a.length; ++i)
      r = a[i], r !== "removeListener" && this.removeAllListeners(r);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (e = n[t], typeof e == "function")
    this.removeListener(t, e);
  else if (e !== void 0)
    for (i = e.length - 1; i >= 0; i--)
      this.removeListener(t, e[i]);
  return this;
};
function C(s, t, e) {
  var n = s._events;
  if (n === void 0)
    return [];
  var i = n[t];
  return i === void 0 ? [] : typeof i == "function" ? e ? [i.listener || i] : [i] : e ? W2(i) : b(i, i.length);
}
o.prototype.listeners = function(t) {
  return C(this, t, true);
}, o.prototype.rawListeners = function(t) {
  return C(this, t, false);
}, o.listenerCount = function(s, t) {
  return typeof s.listenerCount == "function" ? s.listenerCount(t) : E.call(s, t);
}, o.prototype.listenerCount = E;
function E(s) {
  var t = this._events;
  if (t !== void 0) {
    var e = t[s];
    if (typeof e == "function")
      return 1;
    if (e !== void 0)
      return e.length;
  }
  return 0;
}
o.prototype.eventNames = function() {
  return this._eventsCount > 0 ? f(this._events) : [];
};
function b(s, t) {
  for (var e = new Array(t), n = 0; n < t; ++n)
    e[n] = s[n];
  return e;
}
function I(s, t) {
  for (; t + 1 < s.length; t++)
    s[t] = s[t + 1];
  s.pop();
}
function W2(s) {
  for (var t = new Array(s.length), e = 0; e < t.length; ++e)
    t[e] = s[e].listener || s[e];
  return t;
}
function M2(s, t) {
  return new Promise(function(e, n) {
    function i(r) {
      s.removeListener(t, a), n(r);
    }
    function a() {
      typeof s.removeListener == "function" && s.removeListener("error", i), e([].slice.call(arguments));
    }
    R2(s, t, a, { once: true }), t !== "error" && z2(s, i, { once: true });
  });
}
function z2(s, t, e) {
  typeof s.on == "function" && R2(s, "error", t, e);
}
function R2(s, t, e, n) {
  if (typeof s.on == "function")
    n.once ? s.once(t, e) : s.on(t, e);
  else if (typeof s.addEventListener == "function")
    s.addEventListener(t, function i(a) {
      n.once && s.removeEventListener(t, i), e(a);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof s);
}
var O2 = "wc";
var d2 = "Web3Wallet";
var K = `${O2}@2:${d2}:`;
var X2 = class extends l.exports {
  constructor() {
    super();
  }
};
var x2 = class {
  constructor(t) {
    this.opts = t;
  }
};
var P2 = class {
  constructor(t) {
    this.client = t;
  }
};
var D2 = class extends P2 {
  constructor(t) {
    super(t), this.init = async () => {
      this.signClient = await us.init({ core: this.client.core, metadata: this.client.metadata }), this.authClient = await Nr.init({ core: this.client.core, projectId: "", metadata: this.client.metadata }), this.initializeEventListeners();
    }, this.pair = async (e) => {
      await this.client.core.pairing.pair(e);
    }, this.approveSession = async (e) => {
      const { topic: n, acknowledged: i } = await this.signClient.approve({ id: e.id, namespaces: e.namespaces });
      return await i(), this.signClient.session.get(n);
    }, this.rejectSession = async (e) => await this.signClient.reject(e), this.updateSession = async (e) => await (await this.signClient.update(e)).acknowledged(), this.extendSession = async (e) => await (await this.signClient.extend(e)).acknowledged(), this.respondSessionRequest = async (e) => await this.signClient.respond(e), this.disconnectSession = async (e) => await this.signClient.disconnect(e), this.emitSessionEvent = async (e) => await this.signClient.emit(e), this.getActiveSessions = () => this.signClient.session.getAll().reduce((e, n) => (e[n.topic] = n, e), {}), this.getPendingSessionProposals = () => this.signClient.proposal.getAll(), this.getPendingSessionRequests = () => this.signClient.getPendingSessionRequests(), this.respondAuthRequest = async (e, n) => await this.authClient.respond(e, n), this.getPendingAuthRequests = () => this.authClient.requests.getAll().filter((e) => "requester" in e), this.formatMessage = (e, n) => this.authClient.formatMessage(e, n), this.onSessionRequest = (e) => {
      this.client.events.emit("session_request", e);
    }, this.onSessionProposal = (e) => {
      this.client.events.emit("session_proposal", e);
    }, this.onSessionDelete = (e) => {
      this.client.events.emit("session_delete", e);
    }, this.onAuthRequest = (e) => {
      this.client.events.emit("auth_request", e);
    }, this.initializeEventListeners = () => {
      this.signClient.events.on("session_proposal", this.onSessionProposal), this.signClient.events.on("session_request", this.onSessionRequest), this.signClient.events.on("session_delete", this.onSessionDelete), this.authClient.on("auth_request", this.onAuthRequest);
    }, this.signClient = {}, this.authClient = {};
  }
};
var p = class extends x2 {
  constructor(t) {
    super(t), this.events = new l.exports(), this.on = (e, n) => this.events.on(e, n), this.once = (e, n) => this.events.once(e, n), this.off = (e, n) => this.events.off(e, n), this.removeListener = (e, n) => this.events.removeListener(e, n), this.pair = async (e) => {
      try {
        return await this.engine.pair(e);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.approveSession = async (e) => {
      try {
        return await this.engine.approveSession(e);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.rejectSession = async (e) => {
      try {
        return await this.engine.rejectSession(e);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.updateSession = async (e) => {
      try {
        return await this.engine.updateSession(e);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.extendSession = async (e) => {
      try {
        return await this.engine.extendSession(e);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.respondSessionRequest = async (e) => {
      try {
        return await this.engine.respondSessionRequest(e);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.disconnectSession = async (e) => {
      try {
        return await this.engine.disconnectSession(e);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.emitSessionEvent = async (e) => {
      try {
        return await this.engine.emitSessionEvent(e);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.getActiveSessions = () => {
      try {
        return this.engine.getActiveSessions();
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.getPendingSessionProposals = () => {
      try {
        return this.engine.getPendingSessionProposals();
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.respondAuthRequest = async (e, n) => {
      try {
        return await this.engine.respondAuthRequest(e, n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.getPendingAuthRequests = () => {
      try {
        return this.engine.getPendingAuthRequests();
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.formatMessage = (e, n) => {
      try {
        return this.engine.formatMessage(e, n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.metadata = t.metadata, this.name = t.name || d2, this.core = t.core, this.logger = this.core.logger, this.engine = new D2(this);
  }
  static async init(t) {
    const e = new p(t);
    return await e.initialize(), e;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.engine.init(), this.logger.info("Web3Wallet Initialization Success");
    } catch (t) {
      throw this.logger.info("Web3Wallet Initialization Failure"), this.logger.error(t.message), t;
    }
  }
};
var G2 = p;

// node_modules/@thirdweb-dev/wallets/dist/smart-wallet-b682d05a.browser.esm.js
init_lib3();

// node_modules/@thirdweb-dev/wallets/dist/wc-c6a6a61c.browser.esm.js
init_shim();
var TW_WC_PROJECT_ID = "145769e410f16970a79ff77b2d89a1e0";
var WC_RELAY_URL = "wss://relay.walletconnect.com";
var EIP155_SIGNING_METHODS = {
  PERSONAL_SIGN: "personal_sign",
  ETH_SIGN: "eth_sign",
  ETH_SIGN_TRANSACTION: "eth_signTransaction",
  ETH_SIGN_TYPED_DATA: "eth_signTypedData",
  ETH_SIGN_TYPED_DATA_V3: "eth_signTypedData_v3",
  ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
  ETH_SEND_TRANSACTION: "eth_sendTransaction",
  SWITCH_CHAIN: "wallet_switchEthereumChain"
};

// node_modules/@thirdweb-dev/wallets/dist/smart-wallet-b682d05a.browser.esm.js
var WalletConnectHandler = class extends eventemitter3_default {
};
var _core = /* @__PURE__ */ new WeakMap();
var _wcWallet$1 = /* @__PURE__ */ new WeakMap();
var _session = /* @__PURE__ */ new WeakMap();
var _wcMetadata = /* @__PURE__ */ new WeakMap();
var _activeProposal = /* @__PURE__ */ new WeakMap();
var _activeRequestEvent = /* @__PURE__ */ new WeakMap();
var _setupWalletConnectEventsListeners$1 = /* @__PURE__ */ new WeakSet();
var _getSignParamsMessage = /* @__PURE__ */ new WeakSet();
var WalletConnectV2Handler = class extends WalletConnectHandler {
  constructor(options) {
    super();
    _classPrivateMethodInitSpec(this, _getSignParamsMessage);
    _classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners$1);
    _classPrivateFieldInitSpec(this, _core, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _wcWallet$1, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _session, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _wcMetadata, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _activeProposal, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _activeRequestEvent, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _wcMetadata, (options == null ? void 0 : options.walletConnectWalletMetadata) || {
      name: "Thirdweb Smart Wallet",
      description: "Thirdweb Smart Wallet",
      url: "https://thirdweb.com",
      icons: ["https://thirdweb.com/favicon.ico"]
    });
    _classPrivateFieldSet(this, _core, new xr({
      projectId: (options == null ? void 0 : options.walletConenctV2ProjectId) || TW_WC_PROJECT_ID,
      relayUrl: (options == null ? void 0 : options.walletConnectV2RelayUrl) || WC_RELAY_URL
    }));
  }
  async init() {
    _classPrivateFieldSet(this, _wcWallet$1, await G2.init({
      core: _classPrivateFieldGet(this, _core),
      metadata: _classPrivateFieldGet(this, _wcMetadata)
    }));
    const sessions = _classPrivateFieldGet(this, _wcWallet$1).getActiveSessions();
    const keys = Object.keys(sessions);
    if (keys.length > 0) {
      _classPrivateFieldSet(this, _session, sessions[keys[0]]);
    }
    _classPrivateMethodGet(this, _setupWalletConnectEventsListeners$1, _setupWalletConnectEventsListeners2$1).call(this);
  }
  async connectApp(wcUri) {
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before connecting an app.");
    }
    await _classPrivateFieldGet(this, _wcWallet$1).core.pairing.pair({
      uri: wcUri
    });
  }
  async approveSession(wallet) {
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!_classPrivateFieldGet(this, _activeProposal)) {
      throw new Error("Please, pass a valid proposal.");
    }
    const account = await wallet.getAddress();
    const {
      id,
      params
    } = _classPrivateFieldGet(this, _activeProposal);
    const {
      requiredNamespaces,
      relays
    } = params;
    const namespaces = {};
    Object.keys(requiredNamespaces).forEach((key) => {
      var _a;
      const accounts = [];
      (_a = requiredNamespaces[key].chains) == null ? void 0 : _a.map((chain) => {
        accounts.push(`${chain}:${account}`);
      });
      namespaces[key] = {
        accounts,
        methods: requiredNamespaces[key].methods,
        events: requiredNamespaces[key].events
      };
    });
    _classPrivateFieldSet(this, _session, await _classPrivateFieldGet(this, _wcWallet$1).approveSession({
      id,
      relayProtocol: relays[0].protocol,
      namespaces
    }));
    this.emit("session_approved");
  }
  async rejectSession() {
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!_classPrivateFieldGet(this, _activeProposal)) {
      throw new Error("Please, pass a valid proposal.");
    }
    const {
      id
    } = _classPrivateFieldGet(this, _activeProposal);
    await _classPrivateFieldGet(this, _wcWallet$1).rejectSession({
      id,
      reason: {
        message: "User rejected methods.",
        code: 5002
      }
    });
  }
  async approveEIP155Request(wallet) {
    var _a, _b;
    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {
      return;
    }
    const {
      topic,
      params,
      id
    } = _classPrivateFieldGet(this, _activeRequestEvent);
    const {
      request
    } = params;
    let response;
    switch (request.method) {
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
      case EIP155_SIGNING_METHODS.ETH_SIGN:
        const message = _classPrivateMethodGet(this, _getSignParamsMessage, _getSignParamsMessage2).call(this, request.params);
        const signedMessage = await wallet.signMessage(message);
        response = formatJsonRpcResult(id, signedMessage);
        break;
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
        const signer = await wallet.getSigner();
        const sendTransaction = request.params[0];
        const tx = await signer.sendTransaction(sendTransaction);
        const {
          transactionHash
        } = await tx.wait();
        response = formatJsonRpcResult(id, transactionHash);
        break;
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        const signerSign = await wallet.getSigner();
        const signTransaction = request.params[0];
        const signature = await signerSign.signTransaction(signTransaction);
        response = formatJsonRpcResult(id, signature);
      default:
        const error = {
          id,
          jsonrpc: "2.0",
          error: {
            message: "Invalid event.",
            code: 1002
          }
        };
        return (_a = _classPrivateFieldGet(this, _wcWallet$1)) == null ? void 0 : _a.respondSessionRequest({
          topic,
          response: error
        });
    }
    return (_b = _classPrivateFieldGet(this, _wcWallet$1)) == null ? void 0 : _b.respondSessionRequest({
      topic,
      response
    });
  }
  async rejectEIP155Request() {
    var _a;
    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {
      return;
    }
    const {
      topic,
      id
    } = _classPrivateFieldGet(this, _activeRequestEvent);
    const response = {
      id,
      jsonrpc: "2.0",
      error: {
        message: "User rejected methods.",
        code: 5002
      }
    };
    return (_a = _classPrivateFieldGet(this, _wcWallet$1)) == null ? void 0 : _a.respondSessionRequest({
      topic,
      response
    });
  }
  getActiveSessions() {
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before getting sessions.");
    }
    const sessions = _classPrivateFieldGet(this, _wcWallet$1).getActiveSessions();
    const sessionKeys = Object.keys(sessions);
    if (!sessions || sessionKeys.length === 0) {
      return [];
    }
    const thisSessions = [];
    for (const sessionKey of sessionKeys) {
      const topic = sessions[sessionKey].topic;
      const peerMeta = sessions[sessionKey].peer.metadata;
      thisSessions.push({
        topic,
        peer: {
          metadata: peerMeta
        }
      });
    }
    return thisSessions;
  }
  disconnectSession() {
    var _a;
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before disconnecting sessions.");
    }
    if (!_classPrivateFieldGet(this, _session)) {
      return Promise.resolve();
    }
    const params = {
      topic: _classPrivateFieldGet(this, _session).topic,
      reason: {
        message: "User disconnected.",
        code: 6e3
      }
    };
    return (_a = _classPrivateFieldGet(this, _wcWallet$1)) == null ? void 0 : _a.disconnectSession(params);
  }
};
function _setupWalletConnectEventsListeners2$1() {
  if (!_classPrivateFieldGet(this, _wcWallet$1)) {
    throw new Error("Please, init the wallet before making session requests.");
  }
  _classPrivateFieldGet(this, _wcWallet$1).on("session_proposal", (proposal) => {
    _classPrivateFieldSet(this, _activeProposal, proposal);
    this.emit("session_proposal", {
      proposer: {
        metadata: proposal.params.proposer.metadata
      }
    });
  });
  _classPrivateFieldGet(this, _wcWallet$1).on("session_delete", (session) => {
    _classPrivateFieldSet(this, _session, void 0);
    _classPrivateFieldSet(this, _activeProposal, void 0);
    this.emit("session_delete", {
      topic: session.topic
    });
  });
  _classPrivateFieldGet(this, _wcWallet$1).on("session_request", async (requestEvent) => {
    if (!_classPrivateFieldGet(this, _session)) {
      return;
    }
    const {
      params: requestParams
    } = requestEvent;
    const {
      request
    } = requestParams;
    const {
      params
    } = request;
    switch (request.method) {
      case EIP155_SIGNING_METHODS.ETH_SIGN:
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);
        const message = params[0];
        const decodedMessage = new TextDecoder().decode(utils_exports.arrayify(message));
        const paramsCopy = [...params];
        paramsCopy[0] = decodedMessage;
        this.emit("session_request", {
          topic: _classPrivateFieldGet(this, _session).topic,
          params: paramsCopy,
          peer: {
            metadata: _classPrivateFieldGet(this, _session).peer.metadata
          },
          method: request.method
        });
        return;
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);
        this.emit("session_request", {
          topic: _classPrivateFieldGet(this, _session).topic,
          params: requestEvent.params.request.params,
          peer: {
            metadata: _classPrivateFieldGet(this, _session).peer.metadata
          },
          method: request.method
        });
        return;
      default:
        throw new Error(`WCV2.Method not supported: ${request.method}`);
    }
  });
}
function _getSignParamsMessage2(params) {
  const message = params.filter((p2) => !utils_exports.isAddress(p2))[0];
  if (utils_exports.isHexString(message)) {
    return utils_exports.toUtf8String(message);
  }
  return message;
}
var NoOpWalletConnectHandler = class extends WalletConnectHandler {
  init() {
    return Promise.resolve();
  }
  connectApp(uri) {
    return Promise.resolve();
  }
  approveSession(wallet) {
    return Promise.resolve();
  }
  rejectSession() {
    return Promise.resolve();
  }
  approveEIP155Request(wallet) {
    return Promise.resolve();
  }
  rejectEIP155Request() {
    return Promise.resolve();
  }
  getActiveSessions() {
    return [];
  }
  disconnectSession() {
    return Promise.resolve();
  }
};
var _wcWallet = /* @__PURE__ */ new WeakMap();
var _setupWalletConnectEventsListeners = /* @__PURE__ */ new WeakSet();
var SmartWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Smart Wallet";
  }
  constructor(options) {
    super(SmartWallet.id, {
      ...options
    });
    _classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners);
    _defineProperty(this, "enableConnectApp", false);
    _classPrivateFieldInitSpec(this, _wcWallet, {
      writable: true,
      value: void 0
    });
    this.enableConnectApp = (options == null ? void 0 : options.enableConnectApp) || false;
    _classPrivateFieldSet(this, _wcWallet, this.enableConnectApp ? new WalletConnectV2Handler({
      walletConnectWalletMetadata: options == null ? void 0 : options.walletConnectWalletMetadata,
      walletConenctV2ProjectId: options == null ? void 0 : options.walletConenctV2ProjectId,
      walletConnectV2RelayUrl: options == null ? void 0 : options.walletConnectV2RelayUrl
    }) : new NoOpWalletConnectHandler());
  }
  async getConnector() {
    if (!this.connector) {
      if (this.enableConnectApp) {
        await _classPrivateFieldGet(this, _wcWallet).init();
        _classPrivateMethodGet(this, _setupWalletConnectEventsListeners, _setupWalletConnectEventsListeners2).call(this);
      }
      const {
        SmartWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm-774XW6P7.js");
      this.connector = new SmartWalletConnector(this.options);
    }
    return this.connector;
  }
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
  async hasPermissionToExecute(transaction) {
    const connector = await this.getConnector();
    return connector.hasPermissionToExecute(transaction);
  }
  async execute(transaction) {
    const connector = await this.getConnector();
    return connector.execute(transaction);
  }
  async executeBatch(transactions) {
    const connector = await this.getConnector();
    return connector.executeBatch(transactions);
  }
  async deploy() {
    const connector = await this.getConnector();
    return connector.deploy();
  }
  async isDeployed() {
    const connector = await this.getConnector();
    return connector.isDeployed();
  }
  async getAccountContract() {
    const connector = await this.getConnector();
    return connector.getAccountContract();
  }
  async getFactoryContract() {
    const connector = await this.getConnector();
    return connector.getFactoryContract();
  }
  autoConnect(params) {
    return this.connect(params);
  }
  async connectApp(uri) {
    var _a;
    if (!this.enableConnectApp) {
      throw new Error("enableConnectApp is set to false in this wallet config");
    }
    (_a = _classPrivateFieldGet(this, _wcWallet)) == null ? void 0 : _a.connectApp(uri);
  }
  async approveSession() {
    await _classPrivateFieldGet(this, _wcWallet).approveSession(this);
    this.emit("message", {
      type: "session_approved"
    });
  }
  rejectSession() {
    return _classPrivateFieldGet(this, _wcWallet).rejectSession();
  }
  approveRequest() {
    return _classPrivateFieldGet(this, _wcWallet).approveEIP155Request(this);
  }
  rejectRequest() {
    return _classPrivateFieldGet(this, _wcWallet).rejectEIP155Request();
  }
  getActiveSessions() {
    if (!_classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    return _classPrivateFieldGet(this, _wcWallet).getActiveSessions();
  }
  disconnectSession() {
    var _a;
    return (_a = _classPrivateFieldGet(this, _wcWallet)) == null ? void 0 : _a.disconnectSession();
  }
  isWCReceiverEnabled() {
    return this.enableConnectApp;
  }
};
function _setupWalletConnectEventsListeners2() {
  if (!_classPrivateFieldGet(this, _wcWallet)) {
    throw new Error("Please, init the wallet before making session requests.");
  }
  _classPrivateFieldGet(this, _wcWallet).on("session_proposal", (proposal) => {
    this.emit("message", {
      type: "session_proposal",
      data: proposal
    });
  });
  _classPrivateFieldGet(this, _wcWallet).on("session_delete", () => {
    this.emit("message", {
      type: "session_delete"
    });
  });
  _classPrivateFieldGet(this, _wcWallet).on("switch_chain", (request) => {
    const chainId = request.params[0].chainId;
    this.emit("message", {
      type: "switch_chain",
      data: {
        chainId
      }
    });
    _classPrivateFieldGet(this, _wcWallet).disconnectSession();
  });
  _classPrivateFieldGet(this, _wcWallet).on("session_request", (request) => {
    this.emit("message", {
      type: "session_request",
      data: request
    });
  });
}
_defineProperty(SmartWallet, "meta", {
  name: "Smart Wallet",
  iconURL: "ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg"
});
_defineProperty(SmartWallet, "id", walletIds.smartWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/paper-wallet/dist/thirdweb-dev-wallets-evm-wallets-paper-wallet.browser.esm.js
init_shim();
init_lib3();
var PaperWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Paper Wallet";
  }
  constructor(options) {
    super(PaperWallet.id, {
      ...options
    });
    this.paperClientId = options.paperClientId;
    this.chain = options.chain;
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      const {
        PaperWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-paper.browser.esm-MNAXIOCZ.js");
      this.connector = new PaperWalletConnector({
        clientId: this.paperClientId,
        chain: this.chain,
        chains: this.chains,
        advancedOptions: {
          recoveryShareManagement: (_b = (_a = this.options) == null ? void 0 : _a.advancedOptions) == null ? void 0 : _b.recoveryShareManagement
        },
        styles: (_c = this.options) == null ? void 0 : _c.styles
      });
    }
    return this.connector;
  }
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
};
_defineProperty(PaperWallet, "id", walletIds.paper);
_defineProperty(PaperWallet, "meta", {
  name: "Paper Wallet",
  iconURL: "ipfs://QmNrLXtPoFrh4yjZbXui39zUMozS1oetpgU8dvZhFAxfRa/paper-logo-icon.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/coinbase-wallet/dist/thirdweb-dev-wallets-evm-wallets-coinbase-wallet.browser.esm.js
init_shim();
var import_buffer = __toESM(require_buffer());
init_lib3();
{
  window.Buffer = import_buffer.Buffer;
}
var CoinbaseWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Coinbase Wallet";
  }
  constructor(options) {
    super(CoinbaseWallet.id, options);
    this.headlessMode = (options == null ? void 0 : options.headlessMode) || false;
    this.theme = (options == null ? void 0 : options.theme) || this.dappMetadata.isDarkMode === false ? "light" : "dark";
  }
  async getConnector() {
    if (!this.connector) {
      const {
        CoinbaseWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-coinbase-wallet.browser.esm-M7J2NZQD.js");
      const cbConnector = new CoinbaseWalletConnector({
        chains: this.chains,
        options: {
          appName: this.dappMetadata.name,
          reloadOnDisconnect: false,
          darkMode: this.theme === "dark",
          headlessMode: this.headlessMode
        }
      });
      cbConnector.on("connect", () => {
      });
      this.coinbaseConnector = cbConnector;
      this.connector = new WagmiAdapter(cbConnector);
    }
    return this.connector;
  }
  async getQrUrl() {
    await this.getConnector();
    if (!this.coinbaseConnector) {
      throw new Error("Coinbase connector not initialized");
    }
    return this.coinbaseConnector.getQrUrl();
  }
};
_defineProperty(CoinbaseWallet, "meta", {
  iconURL: "ipfs://QmcJBHopbwfJcLqJpX2xEufSS84aLbF7bHavYhaXUcrLaH/coinbase.svg",
  name: "Coinbase Wallet",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
    android: "https://play.google.com/store/apps/details?id=org.toshi",
    ios: "https://apps.apple.com/us/app/coinbase-wallet-nfts-crypto/id1278383455"
  }
});
_defineProperty(CoinbaseWallet, "id", walletIds.coinbase);

// node_modules/@thirdweb-dev/wallets/evm/wallets/local-wallet/dist/thirdweb-dev-wallets-evm-wallets-local-wallet.browser.esm.js
init_shim();
init_lib3();
var STORAGE_KEY_WALLET_DATA = "localWalletData";
var _storage2 = /* @__PURE__ */ new WeakMap();
var _saveData = /* @__PURE__ */ new WeakSet();
var LocalWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Local Wallet";
  }
  constructor(options) {
    super(LocalWallet.id, options);
    _classPrivateMethodInitSpec(this, _saveData);
    _classPrivateFieldInitSpec(this, _storage2, {
      writable: true,
      value: void 0
    });
    this.options = options || {};
    _classPrivateFieldSet(this, _storage2, (options == null ? void 0 : options.storage) || createAsyncLocalStorage(walletIds.localWallet));
  }
  async getConnector() {
    if (!this.connector) {
      const {
        LocalWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-local-wallet.browser.esm-XCV3MY5J.js");
      if (!this.ethersWallet) {
        throw new Error("wallet is not initialized");
      }
      const defaults = this.options.chain ? [...defaultChains, this.options.chain] : defaultChains;
      this.connector = new LocalWalletConnector({
        chain: this.options.chain || c1,
        ethersWallet: this.ethersWallet,
        chains: this.options.chains || defaults,
        clientId: this.options.clientId,
        secretKey: this.options.secretKey
      });
    }
    return this.connector;
  }
  async loadOrCreate(options) {
    if (await this.getSavedData()) {
      await this.load(options);
    } else {
      await this.generate();
      await this.save(options);
    }
  }
  async generate() {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    const random = utils_exports.randomBytes(32);
    this.ethersWallet = new Wallet(random);
    return this.ethersWallet.address;
  }
  async import(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    if ("encryptedJson" in options) {
      this.ethersWallet = await Wallet.fromEncryptedJson(options.encryptedJson, options.password);
      return this.ethersWallet.address;
    }
    if ("privateKey" in options) {
      if (!options.encryption && !isValidPrivateKey(options.privateKey)) {
        throw new Error("invalid private key");
      }
      const privateKey = await getDecryptor(options.encryption)(options.privateKey);
      if (options.encryption && (privateKey === "" || !isValidPrivateKey(privateKey))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = new Wallet(privateKey);
      return this.ethersWallet.address;
    }
    if ("mnemonic" in options) {
      if (!options.encryption && !utils_exports.isValidMnemonic(options.mnemonic)) {
        throw new Error("invalid mnemonic");
      }
      const mnemonic = await getDecryptor(options.encryption)(options.mnemonic);
      if (options.encryption && (mnemonic === "" || !utils_exports.isValidMnemonic(mnemonic))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = Wallet.fromMnemonic(mnemonic);
      return this.ethersWallet.address;
    }
    throw new Error("invalid import strategy");
  }
  async load(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    const walletData = await this.getSavedData(options.storage);
    if (!walletData) {
      throw new Error("No Saved wallet found in storage");
    }
    if (walletData.strategy !== options.strategy) {
      throw new Error(`Saved wallet data is not ${options.strategy}, it is ${walletData.strategy}`);
    }
    if (options.strategy === "encryptedJson") {
      return this.import({
        encryptedJson: walletData.data,
        password: options.password
      });
    }
    if (walletData.isEncrypted && !options.encryption) {
      throw new Error("Saved wallet data is encrypted, but no password is provided");
    }
    if (!walletData.isEncrypted && options.encryption) {
      throw new Error("Saved wallet data is not encrypted, but encryption config is provided");
    }
    if (options.strategy === "privateKey") {
      return this.import({
        privateKey: walletData.data,
        encryption: options.encryption
      });
    }
    if (options.strategy === "mnemonic") {
      return this.import({
        mnemonic: walletData.data,
        encryption: options.encryption
      });
    }
    throw new Error("invalid load strategy");
  }
  async save(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      const encryptedData = await wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {
        address: wallet.address,
        data: encryptedData,
        strategy: "encryptedJson",
        isEncrypted: true
      }, options.storage);
    }
    if (options.strategy === "privateKey") {
      const privateKey = await getEncryptor(options.encryption)(wallet.privateKey);
      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {
        address: wallet.address,
        data: privateKey,
        strategy: "privateKey",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
      }
      const mnemonic = await getEncryptor(options.encryption)(wallet.mnemonic.phrase);
      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {
        address: wallet.address,
        data: mnemonic,
        strategy: "mnemonic",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
  }
  async isSaved() {
    try {
      const data = await this.getSavedData();
      const address = await this.getAddress();
      if ((data == null ? void 0 : data.address) === address) {
        return true;
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  async deleteSaved() {
    await _classPrivateFieldGet(this, _storage2).removeItem(STORAGE_KEY_WALLET_DATA);
  }
  async export(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      return wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
    }
    if (options.strategy === "privateKey") {
      return getEncryptor(options.encryption)(wallet.privateKey);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
      }
      return getEncryptor(options.encryption)(wallet.mnemonic.phrase);
    }
    throw new Error("Invalid export strategy");
  }
  async getSavedData(storage) {
    const _storage = storage || _classPrivateFieldGet(this, _storage2);
    try {
      const savedDataStr = await _storage.getItem(STORAGE_KEY_WALLET_DATA);
      if (!savedDataStr) {
        return null;
      }
      const savedData = JSON.parse(savedDataStr);
      if (!savedData) {
        return null;
      }
      return savedData;
    } catch (e) {
      return null;
    }
  }
  async disconnect() {
    await super.disconnect();
    this.ethersWallet = void 0;
  }
};
async function _saveData2(data, storage) {
  const _storage = storage || _classPrivateFieldGet(this, _storage2);
  await _storage.setItem(STORAGE_KEY_WALLET_DATA, JSON.stringify(data));
}
_defineProperty(LocalWallet, "id", walletIds.localWallet);
_defineProperty(LocalWallet, "meta", {
  name: "Local Wallet",
  iconURL: "ipfs://QmbQzSNGvmNYZzem9jZRuYeLe9K2W4pqbdnVUp7Y6edQ8Y/local-wallet.svg"
});
async function defaultEncrypt(message, password) {
  const cryptoJS = (await import("./crypto-js-JRHSR7IE.js")).default;
  return cryptoJS.AES.encrypt(message, password).toString();
}
async function defaultDecrypt(message, password) {
  const cryptoJS = (await import("./crypto-js-JRHSR7IE.js")).default;
  return cryptoJS.AES.decrypt(message, password).toString(cryptoJS.enc.Utf8);
}
function getDecryptor(encryption) {
  const noop = async (msg) => msg;
  return encryption ? (msg) => (encryption.decrypt || defaultDecrypt)(msg, encryption.password) : noop;
}
function getEncryptor(encryption) {
  const noop = async (msg) => msg;
  return encryption ? (msg) => (encryption.encrypt || defaultEncrypt)(msg, encryption.password) : noop;
}
function isValidPrivateKey(value) {
  return !!value.match(/^(0x)?[0-9a-f]{64}$/i);
}

// node_modules/@thirdweb-dev/wallets/evm/wallets/frame/dist/thirdweb-dev-wallets-evm-wallets-frame.browser.esm.js
init_shim();
init_lib3();
var FrameWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Frame Wallet";
  }
  constructor(options) {
    super(FrameWallet.id, options);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        FrameConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-frame.browser.esm-WRR27DH2.js");
      this.connector = new WagmiAdapter(new FrameConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(FrameWallet, "id", walletIds.frame);

// node_modules/@thirdweb-dev/wallets/evm/wallets/metamask/dist/thirdweb-dev-wallets-evm-wallets-metamask.browser.esm.js
init_shim();
init_lib3();
var MetaMaskWallet = class extends AbstractClientWallet {
  get walletName() {
    return "MetaMask";
  }
  constructor(options) {
    super(MetaMaskWallet.id, options);
    this.isInjected = !!getInjectedMetamaskProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          MetaMaskConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-metamask.browser.esm-TAGTAEUX.js");
        const metamaskConnector = new MetaMaskConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.metamaskConnector = metamaskConnector;
        this.connector = new WagmiAdapter(metamaskConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-PP5QKWGI.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
  async switchAccount() {
    if (!this.metamaskConnector) {
      throw new Error("Can not switch Account");
    }
    await this.metamaskConnector.switchAccount();
  }
};
_defineProperty(MetaMaskWallet, "meta", {
  name: "MetaMask",
  iconURL: "ipfs://QmZZHcw7zcXursywnLDAyY6Hfxzqop5GKgwoq8NB9jjrkN/metamask.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
    android: "https://play.google.com/store/apps/details?id=io.metamask",
    ios: "https://apps.apple.com/us/app/metamask-blockchain-wallet/id1438144202"
  }
});
_defineProperty(MetaMaskWallet, "id", walletIds.metamask);

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect.browser.esm.js
init_shim();
init_lib3();
var _walletConnectConnector = /* @__PURE__ */ new WeakMap();
var _provider = /* @__PURE__ */ new WeakMap();
var _maybeThrowError = /* @__PURE__ */ new WeakMap();
var _onConnect = /* @__PURE__ */ new WeakMap();
var _onDisconnect = /* @__PURE__ */ new WeakMap();
var _onChange = /* @__PURE__ */ new WeakMap();
var _onMessage = /* @__PURE__ */ new WeakMap();
var _onSessionRequestSent = /* @__PURE__ */ new WeakMap();
var _setupListeners = /* @__PURE__ */ new WeakSet();
var _removeListeners = /* @__PURE__ */ new WeakSet();
var WalletConnect = class extends AbstractClientWallet {
  get walletName() {
    return "WalletConnect";
  }
  constructor(options) {
    super((options == null ? void 0 : options.walletId) || WalletConnect.id, options);
    _classPrivateMethodInitSpec(this, _removeListeners);
    _classPrivateMethodInitSpec(this, _setupListeners);
    _classPrivateFieldInitSpec(this, _walletConnectConnector, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _provider, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _maybeThrowError, {
      writable: true,
      value: (error) => {
        if (error) {
          throw error;
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onConnect, {
      writable: true,
      value: (data) => {
        _classPrivateFieldSet(this, _provider, data.provider);
        if (!_classPrivateFieldGet(this, _provider)) {
          throw new Error("WalletConnect provider not found after connecting.");
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onDisconnect, {
      writable: true,
      value: () => {
        _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);
      }
    });
    _classPrivateFieldInitSpec(this, _onChange, {
      writable: true,
      value: async (payload) => {
        if (payload.chain)
          ;
        else if (payload.account)
          ;
      }
    });
    _classPrivateFieldInitSpec(this, _onMessage, {
      writable: true,
      value: (payload) => {
        switch (payload.type) {
          case "display_uri":
            this.emit("display_uri", payload.data);
            break;
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onSessionRequestSent, {
      writable: true,
      value: () => {
        this.emit("wc_session_request_sent");
      }
    });
    this.projectId = (options == null ? void 0 : options.projectId) || TW_WC_PROJECT_ID;
    this.qrcode = (options == null ? void 0 : options.qrcode) === false ? false : true;
  }
  async getConnector() {
    var _a;
    if (!this.connector) {
      const {
        WalletConnectConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-PP5QKWGI.js");
      _classPrivateFieldSet(this, _walletConnectConnector, new WalletConnectConnector({
        chains: this.chains,
        options: {
          qrcode: this.qrcode,
          projectId: this.projectId,
          dappMetadata: this.dappMetadata,
          storage: this.walletStorage,
          qrModalOptions: (_a = this.options) == null ? void 0 : _a.qrModalOptions
        }
      }));
      this.connector = new WagmiAdapter(_classPrivateFieldGet(this, _walletConnectConnector));
      _classPrivateFieldSet(this, _provider, await _classPrivateFieldGet(this, _walletConnectConnector).getProvider());
      _classPrivateMethodGet(this, _setupListeners, _setupListeners2).call(this);
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = _classPrivateFieldGet(this, _walletConnectConnector);
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
function _setupListeners2() {
  var _a;
  if (!_classPrivateFieldGet(this, _walletConnectConnector)) {
    return;
  }
  _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);
  _classPrivateFieldGet(this, _walletConnectConnector).on("connect", _classPrivateFieldGet(this, _onConnect));
  _classPrivateFieldGet(this, _walletConnectConnector).on("disconnect", _classPrivateFieldGet(this, _onDisconnect));
  _classPrivateFieldGet(this, _walletConnectConnector).on("change", _classPrivateFieldGet(this, _onChange));
  _classPrivateFieldGet(this, _walletConnectConnector).on("message", _classPrivateFieldGet(this, _onMessage));
  (_a = _classPrivateFieldGet(this, _provider)) == null ? void 0 : _a.signer.client.on("session_request_sent", _classPrivateFieldGet(this, _onSessionRequestSent));
}
function _removeListeners2() {
  var _a;
  if (!_classPrivateFieldGet(this, _walletConnectConnector)) {
    return;
  }
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("connect", _classPrivateFieldGet(this, _onConnect));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("disconnect", _classPrivateFieldGet(this, _onDisconnect));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("change", _classPrivateFieldGet(this, _onChange));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("message", _classPrivateFieldGet(this, _onMessage));
  (_a = _classPrivateFieldGet(this, _provider)) == null ? void 0 : _a.signer.client.removeListener("session_request_sent", _classPrivateFieldGet(this, _onSessionRequestSent));
}
_defineProperty(WalletConnect, "id", walletIds.walletConnect);
_defineProperty(WalletConnect, "meta", {
  name: "WalletConnect",
  iconURL: "ipfs://QmX58KPRaTC9JYZ7KriuBzeoEaV2P9eZcA3qbFnTHZazKw/wallet-connect.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/safe/dist/thirdweb-dev-wallets-evm-wallets-safe.browser.esm.js
init_shim();
init_lib3();
var SafeWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Safe Wallet";
  }
  constructor(options) {
    super(SafeWallet.id, {
      ...options
    });
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SafeConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-safe.browser.esm-KJFMOU7Z.js");
      this.connector = new SafeConnector();
    }
    return this.connector;
  }
  async updateChains(chains) {
  }
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
  autoConnect(params) {
    return this.connect(params);
  }
};
_defineProperty(SafeWallet, "meta", {
  name: "Safe",
  iconURL: "ipfs://QmbbyxDDmmLQh8DzzeUR6X6B75bESsNUFmbdvS3ZsQ2pN1/SafeToken.svg"
});
_defineProperty(SafeWallet, "id", walletIds.safe);

// node_modules/@thirdweb-dev/wallets/evm/wallets/magic/dist/thirdweb-dev-wallets-evm-wallets-magic.browser.esm.js
init_shim();
init_lib3();
var MagicLink = class extends AbstractClientWallet {
  get walletName() {
    return "Magic Link";
  }
  constructor(options) {
    super(MagicLink.id, options);
    this.options = options;
  }
  async initializeConnector() {
    const {
      MagicAuthConnector
    } = await import("./thirdweb-dev-wallets-evm-connectors-magic.browser.esm-CEMUCORJ.js");
    const magicConnector = new MagicAuthConnector({
      chains: this.chains,
      options: this.options
    });
    this.magicConnector = magicConnector;
    this.connector = new WagmiAdapter(magicConnector);
    return this.connector;
  }
  async getConnector() {
    if (!this.connector) {
      return await this.initializeConnector();
    }
    return this.connector;
  }
  getMagic() {
    if (!this.magicConnector) {
      throw new Error("Magic connector is not initialized");
    }
    return this.magicConnector.getMagicSDK();
  }
  async autoConnect(options) {
    var _a;
    await this.initializeConnector();
    await ((_a = this.magicConnector) == null ? void 0 : _a.initializeMagicSDK(options));
    const magic = this.getMagic();
    {
      const url = new URL(window.location.href);
      const isMagicRedirect = url.searchParams.get("magic_credential");
      if (isMagicRedirect) {
        try {
          this.oAuthRedirectResult = await magic.oauth.getRedirectResult();
        } catch {
        }
      }
    }
    const isLoggedIn = await magic.user.isLoggedIn();
    if (isLoggedIn) {
      return super.autoConnect(options);
    }
    throw new Error("Magic user is not logged in");
  }
  async disconnect() {
    this.oAuthRedirectResult = void 0;
    const magic = this.getMagic();
    await magic.user.logout();
    return super.disconnect();
  }
  async connect(options) {
    if ("email" in options && this.options.emailLogin === false) {
      throw new Error("Email login is disabled");
    }
    if ("phoneNumber" in options && this.options.smsLogin === false) {
      throw new Error("SMS login is disabled");
    }
    return super.connect(options);
  }
};
_defineProperty(MagicLink, "meta", {
  iconURL: "ipfs://QmUMBFZGXxBpgDmZzZAHhbcCL5nYvZnVaYLTajsNjLcxMU/1-Icon_Magic_Color.svg",
  name: "Magic Link"
});
_defineProperty(MagicLink, "id", walletIds.magicLink);

// node_modules/@thirdweb-dev/wallets/evm/wallets/zerion/dist/thirdweb-dev-wallets-evm-wallets-zerion.browser.esm.js
init_shim();
init_lib3();
var ZerionWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Zerion Wallet";
  }
  constructor(options) {
    var _a;
    super(ZerionWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isZerion);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          ZerionConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-zerion.browser.esm-7XLLECN5.js");
        const zerionConnector = new ZerionConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.zerionConnector = zerionConnector;
        this.connector = new WagmiAdapter(zerionConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-PP5QKWGI.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(ZerionWallet, "id", "zerion");
_defineProperty(ZerionWallet, "meta", {
  name: "Zerion Wallet",
  iconURL: "ipfs://Qmb1LhNtMUkzbgk1V8ZiUSRXjMJGRkS5HH3R71KyRgjdBG/zerion.png",
  urls: {
    chrome: "https://zerion.io/extension",
    android: "https://link.zerion.io/901o6IN0jqb",
    ios: "https://link.zerion.io/a11o6IN0jqb"
  }
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/trust/dist/thirdweb-dev-wallets-evm-wallets-trust.browser.esm.js
init_shim();
init_lib3();
var TrustWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Trust Wallet";
  }
  constructor(options) {
    var _a;
    super(TrustWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isTrust);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          TrustConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-trust.browser.esm-2ZURA34M.js");
        const trustConnector = new TrustConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.trustConnector = trustConnector;
        this.connector = new WagmiAdapter(trustConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-PP5QKWGI.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(TrustWallet, "meta", {
  name: "Trust Wallet",
  iconURL: "ipfs://QmNigQbXk7wKZwDcgN38Znj1ZZQ3JEG3DD6fUKLBU8SUTP/trust%20wallet.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/trust-wallet/egjidjbpglichdcondbcbdnbeeppgdph",
    android: "https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp",
    ios: "https://apps.apple.com/us/app/trust-crypto-bitcoin-wallet/id1288339409"
  }
});
_defineProperty(TrustWallet, "id", walletIds.trust);

// node_modules/@thirdweb-dev/wallets/evm/wallets/blocto/dist/thirdweb-dev-wallets-evm-wallets-blocto.browser.esm.js
init_shim();
init_lib3();
var BloctoWallet = class extends AbstractClientWallet {
  constructor(options) {
    super(BloctoWallet.id, options);
    _defineProperty(this, "name", "Blocto");
  }
  async initConnector() {
    var _a, _b, _c;
    const {
      BloctoConnector
    } = await import("./thirdweb-dev-wallets-evm-connectors-blocto.browser.esm-KLW5E7LL.js");
    const bloctoConnector = new BloctoConnector({
      chains: this.chains,
      options: {
        appId: (_a = this.options) == null ? void 0 : _a.appId,
        chainId: (_c = (_b = this.options) == null ? void 0 : _b.chain) == null ? void 0 : _c.chainId
      }
    });
    this.connector = new WagmiAdapter(bloctoConnector);
    return this.connector;
  }
  async getConnector() {
    if (!this.connector) {
      return await this.initConnector();
    }
    return Promise.resolve(this.connector);
  }
};
_defineProperty(BloctoWallet, "id", walletIds.blocto);
_defineProperty(BloctoWallet, "meta", {
  name: "Blocto",
  iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzIyMzNfMjM4NykiPgo8cmVjdCB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHJ4PSIxMiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZD0iTTMyLjkwMjggMTguMzA2M0MyOC4zOTExIDE4LjMwNjMgMjMuOTg3MyAyMC4wNDU5IDIwLjY5NTIgMjMuMTMxOUMxNy4wODQzIDI2LjUxNzYgMTQuNzk5MiAzMS41MTc3IDEzLjQ4OTMgMzYuMjIxMkMxMi42MzE0IDM5LjI5OTIgMTIuMjAxNiA0Mi40OTE1IDEyLjIwMTYgNDUuNjg1M0MxMi4yMDE2IDQ2LjY1MTEgMTIuMjQxMiA0Ny42MDg5IDEyLjMxNzQgNDguNTU1NkMxMi40MTA5IDQ5LjcwNjkgMTMuNTMyMSA1MC41MDQ2IDE0LjY0ODUgNTAuMjAzM0MxNS42MjIyIDQ5Ljk0MTYgMTYuNjQ2NiA0OS44MDA1IDE3LjcwMjggNDkuODAwNUMxOS44NzIyIDQ5LjgwMDUgMjEuOTA1MiA1MC4zOTA0IDIzLjY0OCA1MS40MjEyQzIzLjY5MDggNTEuNDQ2NiAyMy43MzIgNTEuNDcxOSAyMy43NzQ4IDUxLjQ5NTdDMjYuNjA3MSA1My4xODQ2IDI5Ljk0ODQgNTQuMTEyMyAzMy41MTE3IDUzLjk5MzRDNDIuODA2MiA1My42ODU3IDUwLjM5OSA0Ni4xMjMgNTAuNzQxNiAzNi44MzAxQzUxLjExNTggMjYuNjYzNSA0Mi45ODY5IDE4LjMwNDcgMzIuOTA0NCAxOC4zMDQ3TDMyLjkwMjggMTguMzA2M1pNMzIuOTAyOCA0NC4zMTJDMjguMzk3NSA0NC4zMTIgMjQuNzQ1NCA0MC42NTk5IDI0Ljc0NTQgMzYuMTU2MkMyNC43NDU0IDMxLjY1MjUgMjguMzk3NSAyNy45OTg3IDMyLjkwMjggMjcuOTk4N0MzNy40MDgxIDI3Ljk5ODcgNDEuMDYwMiAzMS42NTA5IDQxLjA2MDIgMzYuMTU2MkM0MS4wNjAyIDQwLjY2MTQgMzcuNDA4MSA0NC4zMTIgMzIuOTAyOCA0NC4zMTJaIiBmaWxsPSIjMTRBQUZGIi8+CjxwYXRoIGQ9Ik0yNS41NjM2IDEyLjY4MjZDMjUuNTYzNiAxNS4wMzQ0IDI0LjMzMTUgMTcuMjE2NCAyMi4zMDggMTguNDE1M0MyMS4wMzc3IDE5LjE2ODYgMTkuODQ2OCAyMC4wNTgyIDE4Ljc2ODQgMjEuMDcxNUMxNi4zNzU1IDIzLjMxMzkgMTQuNTg5OCAyNi4wNjUzIDEzLjI2NzMgMjguNzkyOUMxMy4wMDcyIDI5LjMzMDQgMTIuMiAyOS4xNDAyIDEyLjIgMjguNTQyM1YxMi42ODI2QzEyLjIgOC45OTI0MiAxNS4xOTI0IDYgMTguODgyNiA2QzIyLjU3MjggNiAyNS41NjUyIDguOTkyNDIgMjUuNTY1MiAxMi42ODI2SDI1LjU2MzZaIiBmaWxsPSIjMDA3NUZGIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDBfMjIzM18yMzg3Ij4KPHJlY3Qgd2lkdGg9IjYwIiBoZWlnaHQ9IjYwIiBmaWxsPSJ3aGl0ZSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  urls: {
    android: "https://play.google.com/store/apps/details?id=com.portto.blocto",
    ios: "https://apps.apple.com/app/blocto/id1481181682"
  }
});

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/wallets/evm/wallets/injected/dist/thirdweb-dev-wallets-evm-wallets-injected.browser.esm.js
init_shim();
init_lib3();
var InjectedWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Injected Wallet";
  }
  constructor(options) {
    super(InjectedWallet.id, options);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        InjectedConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-injected.browser.esm-XV5ZDF75.js");
      this.connector = new WagmiAdapter(new InjectedConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(InjectedWallet, "id", "injected");

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect-v1/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect-v1.browser.esm.js
init_shim();
init_lib3();

// node_modules/@thirdweb-dev/wallets/evm/wallets/ethers/dist/thirdweb-dev-wallets-evm-wallets-ethers.browser.esm.js
init_shim();
init_lib3();

// node_modules/@thirdweb-dev/wallets/evm/wallets/private-key/dist/thirdweb-dev-wallets-evm-wallets-private-key.browser.esm.js
init_shim();
init_lib3();

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
init_lib3();
var import_buffer2 = __toESM(require_buffer());

export {
  createAsyncLocalStorage,
  SmartWallet,
  PaperWallet,
  CoinbaseWallet,
  LocalWallet,
  FrameWallet,
  MetaMaskWallet,
  WalletConnect,
  SafeWallet,
  MagicLink,
  ZerionWallet,
  TrustWallet,
  BloctoWallet
};
//# sourceMappingURL=chunk-JY3ZYQHU.js.map
