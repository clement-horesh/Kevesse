import {
  require_dist
} from "./chunk-QDYHUZQW.js";
import {
  assert_default,
  checkOpts,
  concatBytes,
  createView,
  crypto,
  hmac,
  init_assert,
  init_crypto,
  init_hmac,
  init_secp256k1,
  init_sha256,
  init_sha3,
  init_sha512,
  init_utils,
  keccak_224,
  keccak_256,
  keccak_384,
  keccak_512,
  randomBytes,
  secp256k1,
  sha256,
  sha512,
  toBytes,
  u32,
  utf8ToBytes
} from "./chunk-2DNYFSKP.js";
import {
  require_events
} from "./chunk-UR4CD6SH.js";
import {
  ZodIssueCode,
  z
} from "./chunk-NS4NLLWV.js";
import {
  _global,
  import_process,
  init_shim
} from "./chunk-6SWLQQ3Q.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-GN3OLCG2.js";

// node_modules/web3/node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/web3/node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module2) {
    init_shim();
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof _global !== "undefined" && _global;
    var __globalThis__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F.prototype = __global__;
      return new F();
    }();
    (function(globalThis2) {
      var irrelevant = function(exports2) {
        var global = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
        var support = {
          searchParams: "URLSearchParams" in global,
          iterable: "Symbol" in global && "iterator" in Symbol,
          blob: "FileReader" in global && "Blob" in global && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in global,
          arrayBuffer: "ArrayBuffer" in global
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name2) {
          if (typeof name2 !== "string") {
            name2 = String(name2);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name2) || name2 === "") {
            throw new TypeError('Invalid character in header field name: "' + name2 + '"');
          }
          return name2.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name2) {
              this.append(name2, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name2) {
              this.append(name2, headers[name2]);
            }, this);
          }
        }
        Headers.prototype.append = function(name2, value) {
          name2 = normalizeName(name2);
          value = normalizeValue(value);
          var oldValue = this.map[name2];
          this.map[name2] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name2) {
          delete this.map[normalizeName(name2)];
        };
        Headers.prototype.get = function(name2) {
          name2 = normalizeName(name2);
          return this.has(name2) ? this.map[name2] : null;
        };
        Headers.prototype.has = function(name2) {
          return this.map.hasOwnProperty(normalizeName(name2));
        };
        Headers.prototype.set = function(name2, value) {
          this.map[normalizeName(name2)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name2 in this.map) {
            if (this.map.hasOwnProperty(name2)) {
              callback.call(thisArg, this.map[name2], name2, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push(name2);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push([name2, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                var isConsumed = consumed(this);
                if (isConsumed) {
                  return isConsumed;
                }
                if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                  return Promise.resolve(
                    this._bodyArrayBuffer.buffer.slice(
                      this._bodyArrayBuffer.byteOffset,
                      this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                    )
                  );
                } else {
                  return Promise.resolve(this._bodyArrayBuffer);
                }
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split2 = bytes.split("=");
              var name2 = split2.shift().replace(/\+/g, " ");
              var value = split2.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name2), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = global.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name2) {
            this.message = message;
            this.name = name2;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch7(input, init2) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init2);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && global.location.href ? global.location.href : url;
              } catch (e) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer && request.headers.get("Content-Type") && request.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init2 && typeof init2.headers === "object" && !(init2.headers instanceof Headers)) {
              Object.getOwnPropertyNames(init2.headers).forEach(function(name2) {
                xhr.setRequestHeader(name2, normalizeValue(init2.headers[name2]));
              });
            } else {
              request.headers.forEach(function(value, name2) {
                xhr.setRequestHeader(name2, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch7.polyfill = true;
        if (!global.fetch) {
          global.fetch = fetch7;
          global.Headers = Headers;
          global.Request = Request;
          global.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch7;
        return exports2;
      }({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module2.exports = exports;
  }
});

// node_modules/setimmediate/setImmediate.js
var require_setImmediate = __commonJS({
  "node_modules/setimmediate/setImmediate.js"(exports) {
    init_shim();
    (function(global, undefined2) {
      "use strict";
      if (global.setImmediate) {
        return;
      }
      var nextHandle = 1;
      var tasksByHandle = {};
      var currentlyRunningATask = false;
      var doc = global.document;
      var registerImmediate;
      function setImmediate2(callback) {
        if (typeof callback !== "function") {
          callback = new Function("" + callback);
        }
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
        }
        var task = { callback, args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
      }
      function clearImmediate(handle) {
        delete tasksByHandle[handle];
      }
      function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
          case 0:
            callback();
            break;
          case 1:
            callback(args[0]);
            break;
          case 2:
            callback(args[0], args[1]);
            break;
          case 3:
            callback(args[0], args[1], args[2]);
            break;
          default:
            callback.apply(undefined2, args);
            break;
        }
      }
      function runIfPresent(handle) {
        if (currentlyRunningATask) {
          setTimeout(runIfPresent, 0, handle);
        } else {
          var task = tasksByHandle[handle];
          if (task) {
            currentlyRunningATask = true;
            try {
              run(task);
            } finally {
              clearImmediate(handle);
              currentlyRunningATask = false;
            }
          }
        }
      }
      function installNextTickImplementation() {
        registerImmediate = function(handle) {
          import_process.default.nextTick(function() {
            runIfPresent(handle);
          });
        };
      }
      function canUsePostMessage() {
        if (global.postMessage && !global.importScripts) {
          var postMessageIsAsynchronous = true;
          var oldOnMessage = global.onmessage;
          global.onmessage = function() {
            postMessageIsAsynchronous = false;
          };
          global.postMessage("", "*");
          global.onmessage = oldOnMessage;
          return postMessageIsAsynchronous;
        }
      }
      function installPostMessageImplementation() {
        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
          if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
            runIfPresent(+event.data.slice(messagePrefix.length));
          }
        };
        if (global.addEventListener) {
          global.addEventListener("message", onGlobalMessage, false);
        } else {
          global.attachEvent("onmessage", onGlobalMessage);
        }
        registerImmediate = function(handle) {
          global.postMessage(messagePrefix + handle, "*");
        };
      }
      function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
          var handle = event.data;
          runIfPresent(handle);
        };
        registerImmediate = function(handle) {
          channel.port2.postMessage(handle);
        };
      }
      function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
          var script = doc.createElement("script");
          script.onreadystatechange = function() {
            runIfPresent(handle);
            script.onreadystatechange = null;
            html.removeChild(script);
            script = null;
          };
          html.appendChild(script);
        };
      }
      function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
          setTimeout(runIfPresent, 0, handle);
        };
      }
      var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
      attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
      if ({}.toString.call(global.process) === "[object process]") {
        installNextTickImplementation();
      } else if (canUsePostMessage()) {
        installPostMessageImplementation();
      } else if (global.MessageChannel) {
        installMessageChannelImplementation();
      } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        installReadyStateChangeImplementation();
      } else {
        installSetTimeoutImplementation();
      }
      attachTo.setImmediate = setImmediate2;
      attachTo.clearImmediate = clearImmediate;
    })(typeof self === "undefined" ? typeof _global === "undefined" ? exports : _global : self);
  }
});

// node_modules/web3-eth/node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill2 = __commonJS({
  "node_modules/web3-eth/node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module2) {
    init_shim();
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof _global !== "undefined" && _global;
    var __globalThis__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F.prototype = __global__;
      return new F();
    }();
    (function(globalThis2) {
      var irrelevant = function(exports2) {
        var global = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
        var support = {
          searchParams: "URLSearchParams" in global,
          iterable: "Symbol" in global && "iterator" in Symbol,
          blob: "FileReader" in global && "Blob" in global && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in global,
          arrayBuffer: "ArrayBuffer" in global
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name2) {
          if (typeof name2 !== "string") {
            name2 = String(name2);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name2) || name2 === "") {
            throw new TypeError('Invalid character in header field name: "' + name2 + '"');
          }
          return name2.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name2) {
              this.append(name2, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name2) {
              this.append(name2, headers[name2]);
            }, this);
          }
        }
        Headers.prototype.append = function(name2, value) {
          name2 = normalizeName(name2);
          value = normalizeValue(value);
          var oldValue = this.map[name2];
          this.map[name2] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name2) {
          delete this.map[normalizeName(name2)];
        };
        Headers.prototype.get = function(name2) {
          name2 = normalizeName(name2);
          return this.has(name2) ? this.map[name2] : null;
        };
        Headers.prototype.has = function(name2) {
          return this.map.hasOwnProperty(normalizeName(name2));
        };
        Headers.prototype.set = function(name2, value) {
          this.map[normalizeName(name2)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name2 in this.map) {
            if (this.map.hasOwnProperty(name2)) {
              callback.call(thisArg, this.map[name2], name2, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push(name2);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push([name2, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                var isConsumed = consumed(this);
                if (isConsumed) {
                  return isConsumed;
                }
                if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                  return Promise.resolve(
                    this._bodyArrayBuffer.buffer.slice(
                      this._bodyArrayBuffer.byteOffset,
                      this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                    )
                  );
                } else {
                  return Promise.resolve(this._bodyArrayBuffer);
                }
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split2 = bytes.split("=");
              var name2 = split2.shift().replace(/\+/g, " ");
              var value = split2.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name2), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = global.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name2) {
            this.message = message;
            this.name = name2;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch7(input, init2) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init2);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && global.location.href ? global.location.href : url;
              } catch (e) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer && request.headers.get("Content-Type") && request.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init2 && typeof init2.headers === "object" && !(init2.headers instanceof Headers)) {
              Object.getOwnPropertyNames(init2.headers).forEach(function(name2) {
                xhr.setRequestHeader(name2, normalizeValue(init2.headers[name2]));
              });
            } else {
              request.headers.forEach(function(value, name2) {
                xhr.setRequestHeader(name2, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch7.polyfill = true;
        if (!global.fetch) {
          global.fetch = fetch7;
          global.Headers = Headers;
          global.Request = Request;
          global.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch7;
        return exports2;
      }({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module2.exports = exports;
  }
});

// node_modules/crc-32/crc32.js
var require_crc32 = __commonJS({
  "node_modules/crc-32/crc32.js"(exports) {
    init_shim();
    var CRC32;
    (function(factory) {
      if (typeof DO_NOT_EXPORT_CRC === "undefined") {
        if ("object" === typeof exports) {
          factory(exports);
        } else if ("function" === typeof define && define.amd) {
          define(function() {
            var module3 = {};
            factory(module3);
            return module3;
          });
        } else {
          factory(CRC32 = {});
        }
      } else {
        factory(CRC32 = {});
      }
    })(function(CRC322) {
      CRC322.version = "1.2.2";
      function signed_crc_table() {
        var c = 0, table = new Array(256);
        for (var n = 0; n != 256; ++n) {
          c = n;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          table[n] = c;
        }
        return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
      }
      var T02 = signed_crc_table();
      function slice_by_16_tables(T) {
        var c = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
        for (n = 0; n != 256; ++n)
          table[n] = T[n];
        for (n = 0; n != 256; ++n) {
          v = T[n];
          for (c = 256 + n; c < 4096; c += 256)
            v = table[c] = v >>> 8 ^ T[v & 255];
        }
        var out = [];
        for (n = 1; n != 16; ++n)
          out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
        return out;
      }
      var TT = slice_by_16_tables(T02);
      var T12 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
      var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
      var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
      function crc32_bstr(bstr, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = bstr.length; i < L; )
          C = C >>> 8 ^ T02[(C ^ bstr.charCodeAt(i++)) & 255];
        return ~C;
      }
      function crc32_buf(B, seed) {
        var C = seed ^ -1, L = B.length - 15, i = 0;
        for (; i < L; )
          C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T12[B[i++]] ^ T02[B[i++]];
        L += 15;
        while (i < L)
          C = C >>> 8 ^ T02[(C ^ B[i++]) & 255];
        return ~C;
      }
      function crc32_str(str, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = str.length, c = 0, d = 0; i < L; ) {
          c = str.charCodeAt(i++);
          if (c < 128) {
            C = C >>> 8 ^ T02[(C ^ c) & 255];
          } else if (c < 2048) {
            C = C >>> 8 ^ T02[(C ^ (192 | c >> 6 & 31)) & 255];
            C = C >>> 8 ^ T02[(C ^ (128 | c & 63)) & 255];
          } else if (c >= 55296 && c < 57344) {
            c = (c & 1023) + 64;
            d = str.charCodeAt(i++) & 1023;
            C = C >>> 8 ^ T02[(C ^ (240 | c >> 8 & 7)) & 255];
            C = C >>> 8 ^ T02[(C ^ (128 | c >> 2 & 63)) & 255];
            C = C >>> 8 ^ T02[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
            C = C >>> 8 ^ T02[(C ^ (128 | d & 63)) & 255];
          } else {
            C = C >>> 8 ^ T02[(C ^ (224 | c >> 12 & 15)) & 255];
            C = C >>> 8 ^ T02[(C ^ (128 | c >> 6 & 63)) & 255];
            C = C >>> 8 ^ T02[(C ^ (128 | c & 63)) & 255];
          }
        }
        return ~C;
      }
      CRC322.table = T02;
      CRC322.bstr = crc32_bstr;
      CRC322.buf = crc32_buf;
      CRC322.str = crc32_str;
    });
  }
});

// node_modules/web3-net/node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill3 = __commonJS({
  "node_modules/web3-net/node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module2) {
    init_shim();
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof _global !== "undefined" && _global;
    var __globalThis__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F.prototype = __global__;
      return new F();
    }();
    (function(globalThis2) {
      var irrelevant = function(exports2) {
        var global = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
        var support = {
          searchParams: "URLSearchParams" in global,
          iterable: "Symbol" in global && "iterator" in Symbol,
          blob: "FileReader" in global && "Blob" in global && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in global,
          arrayBuffer: "ArrayBuffer" in global
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name2) {
          if (typeof name2 !== "string") {
            name2 = String(name2);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name2) || name2 === "") {
            throw new TypeError('Invalid character in header field name: "' + name2 + '"');
          }
          return name2.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name2) {
              this.append(name2, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name2) {
              this.append(name2, headers[name2]);
            }, this);
          }
        }
        Headers.prototype.append = function(name2, value) {
          name2 = normalizeName(name2);
          value = normalizeValue(value);
          var oldValue = this.map[name2];
          this.map[name2] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name2) {
          delete this.map[normalizeName(name2)];
        };
        Headers.prototype.get = function(name2) {
          name2 = normalizeName(name2);
          return this.has(name2) ? this.map[name2] : null;
        };
        Headers.prototype.has = function(name2) {
          return this.map.hasOwnProperty(normalizeName(name2));
        };
        Headers.prototype.set = function(name2, value) {
          this.map[normalizeName(name2)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name2 in this.map) {
            if (this.map.hasOwnProperty(name2)) {
              callback.call(thisArg, this.map[name2], name2, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push(name2);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push([name2, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                var isConsumed = consumed(this);
                if (isConsumed) {
                  return isConsumed;
                }
                if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                  return Promise.resolve(
                    this._bodyArrayBuffer.buffer.slice(
                      this._bodyArrayBuffer.byteOffset,
                      this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                    )
                  );
                } else {
                  return Promise.resolve(this._bodyArrayBuffer);
                }
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split2 = bytes.split("=");
              var name2 = split2.shift().replace(/\+/g, " ");
              var value = split2.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name2), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = global.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name2) {
            this.message = message;
            this.name = name2;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch7(input, init2) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init2);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && global.location.href ? global.location.href : url;
              } catch (e) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer && request.headers.get("Content-Type") && request.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init2 && typeof init2.headers === "object" && !(init2.headers instanceof Headers)) {
              Object.getOwnPropertyNames(init2.headers).forEach(function(name2) {
                xhr.setRequestHeader(name2, normalizeValue(init2.headers[name2]));
              });
            } else {
              request.headers.forEach(function(value, name2) {
                xhr.setRequestHeader(name2, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch7.polyfill = true;
        if (!global.fetch) {
          global.fetch = fetch7;
          global.Headers = Headers;
          global.Request = Request;
          global.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch7;
        return exports2;
      }({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module2.exports = exports;
  }
});

// node_modules/web3-eth-contract/node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill4 = __commonJS({
  "node_modules/web3-eth-contract/node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module2) {
    init_shim();
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof _global !== "undefined" && _global;
    var __globalThis__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F.prototype = __global__;
      return new F();
    }();
    (function(globalThis2) {
      var irrelevant = function(exports2) {
        var global = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
        var support = {
          searchParams: "URLSearchParams" in global,
          iterable: "Symbol" in global && "iterator" in Symbol,
          blob: "FileReader" in global && "Blob" in global && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in global,
          arrayBuffer: "ArrayBuffer" in global
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name2) {
          if (typeof name2 !== "string") {
            name2 = String(name2);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name2) || name2 === "") {
            throw new TypeError('Invalid character in header field name: "' + name2 + '"');
          }
          return name2.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name2) {
              this.append(name2, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name2) {
              this.append(name2, headers[name2]);
            }, this);
          }
        }
        Headers.prototype.append = function(name2, value) {
          name2 = normalizeName(name2);
          value = normalizeValue(value);
          var oldValue = this.map[name2];
          this.map[name2] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name2) {
          delete this.map[normalizeName(name2)];
        };
        Headers.prototype.get = function(name2) {
          name2 = normalizeName(name2);
          return this.has(name2) ? this.map[name2] : null;
        };
        Headers.prototype.has = function(name2) {
          return this.map.hasOwnProperty(normalizeName(name2));
        };
        Headers.prototype.set = function(name2, value) {
          this.map[normalizeName(name2)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name2 in this.map) {
            if (this.map.hasOwnProperty(name2)) {
              callback.call(thisArg, this.map[name2], name2, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push(name2);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push([name2, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                var isConsumed = consumed(this);
                if (isConsumed) {
                  return isConsumed;
                }
                if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                  return Promise.resolve(
                    this._bodyArrayBuffer.buffer.slice(
                      this._bodyArrayBuffer.byteOffset,
                      this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                    )
                  );
                } else {
                  return Promise.resolve(this._bodyArrayBuffer);
                }
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split2 = bytes.split("=");
              var name2 = split2.shift().replace(/\+/g, " ");
              var value = split2.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name2), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = global.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name2) {
            this.message = message;
            this.name = name2;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch7(input, init2) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init2);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && global.location.href ? global.location.href : url;
              } catch (e) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer && request.headers.get("Content-Type") && request.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init2 && typeof init2.headers === "object" && !(init2.headers instanceof Headers)) {
              Object.getOwnPropertyNames(init2.headers).forEach(function(name2) {
                xhr.setRequestHeader(name2, normalizeValue(init2.headers[name2]));
              });
            } else {
              request.headers.forEach(function(value, name2) {
                xhr.setRequestHeader(name2, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch7.polyfill = true;
        if (!global.fetch) {
          global.fetch = fetch7;
          global.Headers = Headers;
          global.Request = Request;
          global.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch7;
        return exports2;
      }({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module2.exports = exports;
  }
});

// node_modules/web3-eth-ens/node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill5 = __commonJS({
  "node_modules/web3-eth-ens/node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module2) {
    init_shim();
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof _global !== "undefined" && _global;
    var __globalThis__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F.prototype = __global__;
      return new F();
    }();
    (function(globalThis2) {
      var irrelevant = function(exports2) {
        var global = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
        var support = {
          searchParams: "URLSearchParams" in global,
          iterable: "Symbol" in global && "iterator" in Symbol,
          blob: "FileReader" in global && "Blob" in global && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in global,
          arrayBuffer: "ArrayBuffer" in global
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name2) {
          if (typeof name2 !== "string") {
            name2 = String(name2);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name2) || name2 === "") {
            throw new TypeError('Invalid character in header field name: "' + name2 + '"');
          }
          return name2.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name2) {
              this.append(name2, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name2) {
              this.append(name2, headers[name2]);
            }, this);
          }
        }
        Headers.prototype.append = function(name2, value) {
          name2 = normalizeName(name2);
          value = normalizeValue(value);
          var oldValue = this.map[name2];
          this.map[name2] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name2) {
          delete this.map[normalizeName(name2)];
        };
        Headers.prototype.get = function(name2) {
          name2 = normalizeName(name2);
          return this.has(name2) ? this.map[name2] : null;
        };
        Headers.prototype.has = function(name2) {
          return this.map.hasOwnProperty(normalizeName(name2));
        };
        Headers.prototype.set = function(name2, value) {
          this.map[normalizeName(name2)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name2 in this.map) {
            if (this.map.hasOwnProperty(name2)) {
              callback.call(thisArg, this.map[name2], name2, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push(name2);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push([name2, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                var isConsumed = consumed(this);
                if (isConsumed) {
                  return isConsumed;
                }
                if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                  return Promise.resolve(
                    this._bodyArrayBuffer.buffer.slice(
                      this._bodyArrayBuffer.byteOffset,
                      this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                    )
                  );
                } else {
                  return Promise.resolve(this._bodyArrayBuffer);
                }
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split2 = bytes.split("=");
              var name2 = split2.shift().replace(/\+/g, " ");
              var value = split2.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name2), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = global.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name2) {
            this.message = message;
            this.name = name2;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch7(input, init2) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init2);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && global.location.href ? global.location.href : url;
              } catch (e) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer && request.headers.get("Content-Type") && request.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init2 && typeof init2.headers === "object" && !(init2.headers instanceof Headers)) {
              Object.getOwnPropertyNames(init2.headers).forEach(function(name2) {
                xhr.setRequestHeader(name2, normalizeValue(init2.headers[name2]));
              });
            } else {
              request.headers.forEach(function(value, name2) {
                xhr.setRequestHeader(name2, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch7.polyfill = true;
        if (!global.fetch) {
          global.fetch = fetch7;
          global.Headers = Headers;
          global.Request = Request;
          global.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch7;
        return exports2;
      }({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module2.exports = exports;
  }
});

// node_modules/web3-eth-personal/node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill6 = __commonJS({
  "node_modules/web3-eth-personal/node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module2) {
    init_shim();
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof _global !== "undefined" && _global;
    var __globalThis__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F.prototype = __global__;
      return new F();
    }();
    (function(globalThis2) {
      var irrelevant = function(exports2) {
        var global = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
        var support = {
          searchParams: "URLSearchParams" in global,
          iterable: "Symbol" in global && "iterator" in Symbol,
          blob: "FileReader" in global && "Blob" in global && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in global,
          arrayBuffer: "ArrayBuffer" in global
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name2) {
          if (typeof name2 !== "string") {
            name2 = String(name2);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name2) || name2 === "") {
            throw new TypeError('Invalid character in header field name: "' + name2 + '"');
          }
          return name2.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name2) {
              this.append(name2, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name2) {
              this.append(name2, headers[name2]);
            }, this);
          }
        }
        Headers.prototype.append = function(name2, value) {
          name2 = normalizeName(name2);
          value = normalizeValue(value);
          var oldValue = this.map[name2];
          this.map[name2] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name2) {
          delete this.map[normalizeName(name2)];
        };
        Headers.prototype.get = function(name2) {
          name2 = normalizeName(name2);
          return this.has(name2) ? this.map[name2] : null;
        };
        Headers.prototype.has = function(name2) {
          return this.map.hasOwnProperty(normalizeName(name2));
        };
        Headers.prototype.set = function(name2, value) {
          this.map[normalizeName(name2)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name2 in this.map) {
            if (this.map.hasOwnProperty(name2)) {
              callback.call(thisArg, this.map[name2], name2, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push(name2);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push([name2, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                var isConsumed = consumed(this);
                if (isConsumed) {
                  return isConsumed;
                }
                if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                  return Promise.resolve(
                    this._bodyArrayBuffer.buffer.slice(
                      this._bodyArrayBuffer.byteOffset,
                      this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                    )
                  );
                } else {
                  return Promise.resolve(this._bodyArrayBuffer);
                }
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split2 = bytes.split("=");
              var name2 = split2.shift().replace(/\+/g, " ");
              var value = split2.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name2), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = global.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name2) {
            this.message = message;
            this.name = name2;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch7(input, init2) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init2);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && global.location.href ? global.location.href : url;
              } catch (e) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer && request.headers.get("Content-Type") && request.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init2 && typeof init2.headers === "object" && !(init2.headers instanceof Headers)) {
              Object.getOwnPropertyNames(init2.headers).forEach(function(name2) {
                xhr.setRequestHeader(name2, normalizeValue(init2.headers[name2]));
              });
            } else {
              request.headers.forEach(function(value, name2) {
                xhr.setRequestHeader(name2, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch7.polyfill = true;
        if (!global.fetch) {
          global.fetch = fetch7;
          global.Headers = Headers;
          global.Request = Request;
          global.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch7;
        return exports2;
      }({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module2.exports = exports;
  }
});

// node_modules/web3/lib/esm/index.js
init_shim();

// node_modules/web3/lib/esm/web3.js
init_shim();

// node_modules/web3/node_modules/web3-core/lib/esm/index.js
var esm_exports8 = {};
__export(esm_exports8, {
  DEFAULT_BATCH_REQUEST_TIMEOUT: () => DEFAULT_BATCH_REQUEST_TIMEOUT,
  Web3BatchRequest: () => Web3BatchRequest,
  Web3Config: () => Web3Config,
  Web3ConfigEvent: () => Web3ConfigEvent,
  Web3Context: () => Web3Context,
  Web3EthPluginBase: () => Web3EthPluginBase,
  Web3EventEmitter: () => Web3EventEmitter,
  Web3PluginBase: () => Web3PluginBase,
  Web3PromiEvent: () => Web3PromiEvent,
  Web3RequestManager: () => Web3RequestManager,
  Web3RequestManagerEvent: () => Web3RequestManagerEvent,
  Web3Subscription: () => Web3Subscription,
  Web3SubscriptionManager: () => Web3SubscriptionManager,
  formatters: () => formatters_exports,
  inputAddressFormatter: () => inputAddressFormatter,
  inputBlockNumberFormatter: () => inputBlockNumberFormatter,
  inputCallFormatter: () => inputCallFormatter,
  inputDefaultBlockNumberFormatter: () => inputDefaultBlockNumberFormatter,
  inputLogFormatter: () => inputLogFormatter,
  inputPostFormatter: () => inputPostFormatter,
  inputSignFormatter: () => inputSignFormatter,
  inputStorageKeysFormatter: () => inputStorageKeysFormatter,
  inputTopicFormatter: () => inputTopicFormatter,
  inputTransactionFormatter: () => inputTransactionFormatter,
  isEIP1193Provider: () => isEIP1193Provider,
  isLegacyRequestProvider: () => isLegacyRequestProvider,
  isLegacySendAsyncProvider: () => isLegacySendAsyncProvider,
  isLegacySendProvider: () => isLegacySendProvider,
  isMetaMaskProvider: () => isMetaMaskProvider,
  isSupportSubscriptions: () => isSupportSubscriptions,
  isSupportedProvider: () => isSupportedProvider,
  isWeb3Provider: () => isWeb3Provider,
  outputBigIntegerFormatter: () => outputBigIntegerFormatter,
  outputBlockFormatter: () => outputBlockFormatter,
  outputLogFormatter: () => outputLogFormatter,
  outputPostFormatter: () => outputPostFormatter,
  outputProofFormatter: () => outputProofFormatter,
  outputSyncingFormatter: () => outputSyncingFormatter,
  outputTransactionFormatter: () => outputTransactionFormatter,
  outputTransactionReceiptFormatter: () => outputTransactionReceiptFormatter,
  txInputOptionsFormatter: () => txInputOptionsFormatter
});
init_shim();

// node_modules/web3/node_modules/web3-core/lib/esm/web3_config.js
init_shim();

// node_modules/web3-errors/lib/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  AbiError: () => AbiError,
  BaseWeb3Error: () => BaseWeb3Error,
  ChainIdMismatchError: () => ChainIdMismatchError,
  ChainMismatchError: () => ChainMismatchError,
  CommonOrChainAndHardforkError: () => CommonOrChainAndHardforkError,
  ConfigChainMismatchError: () => ConfigChainMismatchError,
  ConfigHardforkMismatchError: () => ConfigHardforkMismatchError,
  ConnectionCloseError: () => ConnectionCloseError,
  ConnectionError: () => ConnectionError,
  ConnectionNotOpenError: () => ConnectionNotOpenError,
  ConnectionTimeoutError: () => ConnectionTimeoutError,
  ContractCodeNotStoredError: () => ContractCodeNotStoredError,
  ContractEventDoesNotExistError: () => ContractEventDoesNotExistError,
  ContractExecutionError: () => ContractExecutionError,
  ContractInstantiationError: () => ContractInstantiationError,
  ContractMissingABIError: () => ContractMissingABIError,
  ContractMissingDeployDataError: () => ContractMissingDeployDataError,
  ContractNoAddressDefinedError: () => ContractNoAddressDefinedError,
  ContractNoFromAddressDefinedError: () => ContractNoFromAddressDefinedError,
  ContractOnceRequiresCallbackError: () => ContractOnceRequiresCallbackError,
  ContractReservedEventError: () => ContractReservedEventError,
  ContractTransactionDataAndInputError: () => ContractTransactionDataAndInputError,
  EIP1193ProviderRpcError: () => EIP1193ProviderRpcError,
  ENSCheckInterfaceSupportError: () => ENSCheckInterfaceSupportError,
  ENSNetworkNotSyncedError: () => ENSNetworkNotSyncedError,
  ENSUnsupportedNetworkError: () => ENSUnsupportedNetworkError,
  ERR_ABI_ENCODING: () => ERR_ABI_ENCODING,
  ERR_CONN: () => ERR_CONN,
  ERR_CONN_CLOSE: () => ERR_CONN_CLOSE,
  ERR_CONN_INVALID: () => ERR_CONN_INVALID,
  ERR_CONN_MAX_ATTEMPTS: () => ERR_CONN_MAX_ATTEMPTS,
  ERR_CONN_NOT_OPEN: () => ERR_CONN_NOT_OPEN,
  ERR_CONN_PENDING_REQUESTS: () => ERR_CONN_PENDING_REQUESTS,
  ERR_CONN_TIMEOUT: () => ERR_CONN_TIMEOUT,
  ERR_CONTRACT: () => ERR_CONTRACT,
  ERR_CONTRACT_ABI_MISSING: () => ERR_CONTRACT_ABI_MISSING,
  ERR_CONTRACT_EVENT_NOT_EXISTS: () => ERR_CONTRACT_EVENT_NOT_EXISTS,
  ERR_CONTRACT_EXECUTION_REVERTED: () => ERR_CONTRACT_EXECUTION_REVERTED,
  ERR_CONTRACT_INSTANTIATION: () => ERR_CONTRACT_INSTANTIATION,
  ERR_CONTRACT_MISSING_ADDRESS: () => ERR_CONTRACT_MISSING_ADDRESS,
  ERR_CONTRACT_MISSING_DEPLOY_DATA: () => ERR_CONTRACT_MISSING_DEPLOY_DATA,
  ERR_CONTRACT_MISSING_FROM_ADDRESS: () => ERR_CONTRACT_MISSING_FROM_ADDRESS,
  ERR_CONTRACT_REQUIRED_CALLBACK: () => ERR_CONTRACT_REQUIRED_CALLBACK,
  ERR_CONTRACT_RESERVED_EVENT: () => ERR_CONTRACT_RESERVED_EVENT,
  ERR_CONTRACT_RESOLVER_MISSING: () => ERR_CONTRACT_RESOLVER_MISSING,
  ERR_CONTRACT_TX_DATA_AND_INPUT: () => ERR_CONTRACT_TX_DATA_AND_INPUT,
  ERR_CORE_CHAIN_MISMATCH: () => ERR_CORE_CHAIN_MISMATCH,
  ERR_CORE_HARDFORK_MISMATCH: () => ERR_CORE_HARDFORK_MISMATCH,
  ERR_ENS_CHECK_INTERFACE_SUPPORT: () => ERR_ENS_CHECK_INTERFACE_SUPPORT,
  ERR_ENS_NETWORK_NOT_SYNCED: () => ERR_ENS_NETWORK_NOT_SYNCED,
  ERR_ENS_UNSUPPORTED_NETWORK: () => ERR_ENS_UNSUPPORTED_NETWORK,
  ERR_EXISTING_PLUGIN_NAMESPACE: () => ERR_EXISTING_PLUGIN_NAMESPACE,
  ERR_FORMATTERS: () => ERR_FORMATTERS,
  ERR_INVALID_ADDRESS: () => ERR_INVALID_ADDRESS,
  ERR_INVALID_BLOCK: () => ERR_INVALID_BLOCK,
  ERR_INVALID_BOOLEAN: () => ERR_INVALID_BOOLEAN,
  ERR_INVALID_BYTES: () => ERR_INVALID_BYTES,
  ERR_INVALID_CLIENT: () => ERR_INVALID_CLIENT,
  ERR_INVALID_HEX: () => ERR_INVALID_HEX,
  ERR_INVALID_KEYSTORE: () => ERR_INVALID_KEYSTORE,
  ERR_INVALID_LARGE_VALUE: () => ERR_INVALID_LARGE_VALUE,
  ERR_INVALID_METHOD_PARAMS: () => ERR_INVALID_METHOD_PARAMS,
  ERR_INVALID_NIBBLE_WIDTH: () => ERR_INVALID_NIBBLE_WIDTH,
  ERR_INVALID_NUMBER: () => ERR_INVALID_NUMBER,
  ERR_INVALID_PASSWORD: () => ERR_INVALID_PASSWORD,
  ERR_INVALID_PRIVATE_KEY: () => ERR_INVALID_PRIVATE_KEY,
  ERR_INVALID_PROVIDER: () => ERR_INVALID_PROVIDER,
  ERR_INVALID_RESPONSE: () => ERR_INVALID_RESPONSE,
  ERR_INVALID_SIGNATURE: () => ERR_INVALID_SIGNATURE,
  ERR_INVALID_SIZE: () => ERR_INVALID_SIZE,
  ERR_INVALID_STRING: () => ERR_INVALID_STRING,
  ERR_INVALID_TYPE: () => ERR_INVALID_TYPE,
  ERR_INVALID_TYPE_ABI: () => ERR_INVALID_TYPE_ABI,
  ERR_INVALID_UNIT: () => ERR_INVALID_UNIT,
  ERR_INVALID_UNSIGNED_INTEGER: () => ERR_INVALID_UNSIGNED_INTEGER,
  ERR_IV_LENGTH: () => ERR_IV_LENGTH,
  ERR_KEY_DERIVATION_FAIL: () => ERR_KEY_DERIVATION_FAIL,
  ERR_KEY_VERSION_UNSUPPORTED: () => ERR_KEY_VERSION_UNSUPPORTED,
  ERR_METHOD_NOT_IMPLEMENTED: () => ERR_METHOD_NOT_IMPLEMENTED,
  ERR_OPERATION_ABORT: () => ERR_OPERATION_ABORT,
  ERR_OPERATION_TIMEOUT: () => ERR_OPERATION_TIMEOUT,
  ERR_PARAM: () => ERR_PARAM,
  ERR_PBKDF2_ITERATIONS: () => ERR_PBKDF2_ITERATIONS,
  ERR_PRIVATE_KEY_LENGTH: () => ERR_PRIVATE_KEY_LENGTH,
  ERR_PROVIDER: () => ERR_PROVIDER,
  ERR_RAW_TX_UNDEFINED: () => ERR_RAW_TX_UNDEFINED,
  ERR_REQ_ALREADY_SENT: () => ERR_REQ_ALREADY_SENT,
  ERR_RESPONSE: () => ERR_RESPONSE,
  ERR_RPC_INTERNAL_ERROR: () => ERR_RPC_INTERNAL_ERROR,
  ERR_RPC_INVALID_INPUT: () => ERR_RPC_INVALID_INPUT,
  ERR_RPC_INVALID_JSON: () => ERR_RPC_INVALID_JSON,
  ERR_RPC_INVALID_METHOD: () => ERR_RPC_INVALID_METHOD,
  ERR_RPC_INVALID_PARAMS: () => ERR_RPC_INVALID_PARAMS,
  ERR_RPC_INVALID_REQUEST: () => ERR_RPC_INVALID_REQUEST,
  ERR_RPC_LIMIT_EXCEEDED: () => ERR_RPC_LIMIT_EXCEEDED,
  ERR_RPC_MISSING_RESOURCE: () => ERR_RPC_MISSING_RESOURCE,
  ERR_RPC_NOT_SUPPORTED: () => ERR_RPC_NOT_SUPPORTED,
  ERR_RPC_TRANSACTION_REJECTED: () => ERR_RPC_TRANSACTION_REJECTED,
  ERR_RPC_UNAVAILABLE_RESOURCE: () => ERR_RPC_UNAVAILABLE_RESOURCE,
  ERR_RPC_UNSUPPORTED_METHOD: () => ERR_RPC_UNSUPPORTED_METHOD,
  ERR_SCHEMA_FORMAT: () => ERR_SCHEMA_FORMAT,
  ERR_SIGNATURE_FAILED: () => ERR_SIGNATURE_FAILED,
  ERR_SUBSCRIPTION: () => ERR_SUBSCRIPTION,
  ERR_TX: () => ERR_TX,
  ERR_TX_BLOCK_TIMEOUT: () => ERR_TX_BLOCK_TIMEOUT,
  ERR_TX_CHAIN_ID_MISMATCH: () => ERR_TX_CHAIN_ID_MISMATCH,
  ERR_TX_CHAIN_MISMATCH: () => ERR_TX_CHAIN_MISMATCH,
  ERR_TX_CONTRACT_NOT_STORED: () => ERR_TX_CONTRACT_NOT_STORED,
  ERR_TX_DATA_AND_INPUT: () => ERR_TX_DATA_AND_INPUT,
  ERR_TX_GAS_MISMATCH: () => ERR_TX_GAS_MISMATCH,
  ERR_TX_GAS_MISMATCH_INNER_ERROR: () => ERR_TX_GAS_MISMATCH_INNER_ERROR,
  ERR_TX_HARDFORK_MISMATCH: () => ERR_TX_HARDFORK_MISMATCH,
  ERR_TX_INVALID_CALL: () => ERR_TX_INVALID_CALL,
  ERR_TX_INVALID_CHAIN_INFO: () => ERR_TX_INVALID_CHAIN_INFO,
  ERR_TX_INVALID_FEE_MARKET_GAS: () => ERR_TX_INVALID_FEE_MARKET_GAS,
  ERR_TX_INVALID_FEE_MARKET_GAS_PRICE: () => ERR_TX_INVALID_FEE_MARKET_GAS_PRICE,
  ERR_TX_INVALID_LEGACY_FEE_MARKET: () => ERR_TX_INVALID_LEGACY_FEE_MARKET,
  ERR_TX_INVALID_LEGACY_GAS: () => ERR_TX_INVALID_LEGACY_GAS,
  ERR_TX_INVALID_NONCE_OR_CHAIN_ID: () => ERR_TX_INVALID_NONCE_OR_CHAIN_ID,
  ERR_TX_INVALID_OBJECT: () => ERR_TX_INVALID_OBJECT,
  ERR_TX_INVALID_PROPERTIES_FOR_TYPE: () => ERR_TX_INVALID_PROPERTIES_FOR_TYPE,
  ERR_TX_INVALID_RECEIVER: () => ERR_TX_INVALID_RECEIVER,
  ERR_TX_INVALID_SENDER: () => ERR_TX_INVALID_SENDER,
  ERR_TX_LOCAL_WALLET_NOT_AVAILABLE: () => ERR_TX_LOCAL_WALLET_NOT_AVAILABLE,
  ERR_TX_MISSING_CHAIN_INFO: () => ERR_TX_MISSING_CHAIN_INFO,
  ERR_TX_MISSING_CUSTOM_CHAIN: () => ERR_TX_MISSING_CUSTOM_CHAIN,
  ERR_TX_MISSING_CUSTOM_CHAIN_ID: () => ERR_TX_MISSING_CUSTOM_CHAIN_ID,
  ERR_TX_MISSING_GAS: () => ERR_TX_MISSING_GAS,
  ERR_TX_MISSING_GAS_INNER_ERROR: () => ERR_TX_MISSING_GAS_INNER_ERROR,
  ERR_TX_NOT_FOUND: () => ERR_TX_NOT_FOUND,
  ERR_TX_NO_CONTRACT_ADDRESS: () => ERR_TX_NO_CONTRACT_ADDRESS,
  ERR_TX_OUT_OF_GAS: () => ERR_TX_OUT_OF_GAS,
  ERR_TX_POLLING_TIMEOUT: () => ERR_TX_POLLING_TIMEOUT,
  ERR_TX_RECEIPT_MISSING_BLOCK_NUMBER: () => ERR_TX_RECEIPT_MISSING_BLOCK_NUMBER,
  ERR_TX_RECEIPT_MISSING_OR_BLOCKHASH_NULL: () => ERR_TX_RECEIPT_MISSING_OR_BLOCKHASH_NULL,
  ERR_TX_REVERT_INSTRUCTION: () => ERR_TX_REVERT_INSTRUCTION,
  ERR_TX_REVERT_TRANSACTION: () => ERR_TX_REVERT_TRANSACTION,
  ERR_TX_REVERT_TRANSACTION_CUSTOM_ERROR: () => ERR_TX_REVERT_TRANSACTION_CUSTOM_ERROR,
  ERR_TX_REVERT_WITHOUT_REASON: () => ERR_TX_REVERT_WITHOUT_REASON,
  ERR_TX_SEND_TIMEOUT: () => ERR_TX_SEND_TIMEOUT,
  ERR_TX_SIGNING: () => ERR_TX_SIGNING,
  ERR_TX_UNABLE_TO_POPULATE_NONCE: () => ERR_TX_UNABLE_TO_POPULATE_NONCE,
  ERR_TX_UNSUPPORTED_EIP_1559: () => ERR_TX_UNSUPPORTED_EIP_1559,
  ERR_TX_UNSUPPORTED_TYPE: () => ERR_TX_UNSUPPORTED_TYPE,
  ERR_UNSUPPORTED_KDF: () => ERR_UNSUPPORTED_KDF,
  ERR_VALIDATION: () => ERR_VALIDATION,
  ERR_WS_PROVIDER: () => ERR_WS_PROVIDER,
  Eip1559GasPriceError: () => Eip1559GasPriceError,
  Eip1559NotSupportedError: () => Eip1559NotSupportedError,
  Eip838ExecutionError: () => Eip838ExecutionError,
  ExistingPluginNamespaceError: () => ExistingPluginNamespaceError,
  FormatterError: () => FormatterError,
  GENESIS_BLOCK_NUMBER: () => GENESIS_BLOCK_NUMBER,
  HardforkMismatchError: () => HardforkMismatchError,
  HexProcessingError: () => HexProcessingError,
  IVLengthError: () => IVLengthError,
  InternalError: () => InternalError,
  InvalidAddressError: () => InvalidAddressError,
  InvalidBlockError: () => InvalidBlockError,
  InvalidBooleanError: () => InvalidBooleanError,
  InvalidBytesError: () => InvalidBytesError,
  InvalidClientError: () => InvalidClientError,
  InvalidConnectionError: () => InvalidConnectionError,
  InvalidGasOrGasPrice: () => InvalidGasOrGasPrice,
  InvalidInputError: () => InvalidInputError,
  InvalidKdfError: () => InvalidKdfError,
  InvalidLargeValueError: () => InvalidLargeValueError,
  InvalidMaxPriorityFeePerGasOrMaxFeePerGas: () => InvalidMaxPriorityFeePerGasOrMaxFeePerGas,
  InvalidMethodParamsError: () => InvalidMethodParamsError,
  InvalidNonceOrChainIdError: () => InvalidNonceOrChainIdError,
  InvalidNumberError: () => InvalidNumberError,
  InvalidNumberOfParamsError: () => InvalidNumberOfParamsError,
  InvalidParamsError: () => InvalidParamsError,
  InvalidPasswordError: () => InvalidPasswordError,
  InvalidPrivateKeyError: () => InvalidPrivateKeyError,
  InvalidPropertiesForTransactionTypeError: () => InvalidPropertiesForTransactionTypeError,
  InvalidProviderError: () => InvalidProviderError,
  InvalidRequestError: () => InvalidRequestError,
  InvalidResponseError: () => InvalidResponseError,
  InvalidSignatureError: () => InvalidSignatureError,
  InvalidSizeError: () => InvalidSizeError,
  InvalidStringError: () => InvalidStringError,
  InvalidTransactionCall: () => InvalidTransactionCall,
  InvalidTransactionObjectError: () => InvalidTransactionObjectError,
  InvalidTransactionWithReceiver: () => InvalidTransactionWithReceiver,
  InvalidTransactionWithSender: () => InvalidTransactionWithSender,
  InvalidTypeAbiInputError: () => InvalidTypeAbiInputError,
  InvalidTypeError: () => InvalidTypeError,
  InvalidUnitError: () => InvalidUnitError,
  InvalidUnsignedIntegerError: () => InvalidUnsignedIntegerError,
  InvalidValueError: () => InvalidValueError,
  JSONRPC_ERR_CHAIN_DISCONNECTED: () => JSONRPC_ERR_CHAIN_DISCONNECTED,
  JSONRPC_ERR_DISCONNECTED: () => JSONRPC_ERR_DISCONNECTED,
  JSONRPC_ERR_REJECTED_REQUEST: () => JSONRPC_ERR_REJECTED_REQUEST,
  JSONRPC_ERR_UNAUTHORIZED: () => JSONRPC_ERR_UNAUTHORIZED,
  JSONRPC_ERR_UNSUPPORTED_METHOD: () => JSONRPC_ERR_UNSUPPORTED_METHOD,
  KeyDerivationError: () => KeyDerivationError,
  KeyStoreVersionError: () => KeyStoreVersionError,
  LimitExceededError: () => LimitExceededError,
  LocalWalletNotAvailableError: () => LocalWalletNotAvailableError,
  MaxAttemptsReachedOnReconnectingError: () => MaxAttemptsReachedOnReconnectingError,
  MethodNotFoundError: () => MethodNotFoundError,
  MethodNotImplementedError: () => MethodNotImplementedError,
  MethodNotSupported: () => MethodNotSupported,
  MissingChainOrHardforkError: () => MissingChainOrHardforkError,
  MissingCustomChainError: () => MissingCustomChainError,
  MissingCustomChainIdError: () => MissingCustomChainIdError,
  MissingGasError: () => MissingGasError,
  MissingGasInnerError: () => MissingGasInnerError,
  NibbleWidthError: () => NibbleWidthError,
  NoContractAddressFoundError: () => NoContractAddressFoundError,
  OperationAbortError: () => OperationAbortError,
  OperationTimeoutError: () => OperationTimeoutError,
  PBKDF2IterationsError: () => PBKDF2IterationsError,
  ParseError: () => ParseError,
  PendingRequestsOnReconnectingError: () => PendingRequestsOnReconnectingError,
  PrivateKeyLengthError: () => PrivateKeyLengthError,
  ProviderError: () => ProviderError,
  RequestAlreadySentError: () => RequestAlreadySentError,
  ResolverMethodMissingError: () => ResolverMethodMissingError,
  ResourceUnavailableError: () => ResourceUnavailableError,
  ResourcesNotFoundError: () => ResourcesNotFoundError,
  ResponseError: () => ResponseError,
  RevertInstructionError: () => RevertInstructionError,
  RpcError: () => RpcError,
  RpcErrorMessages: () => RpcErrorMessages,
  SchemaFormatError: () => SchemaFormatError,
  SignatureError: () => SignatureError,
  SubscriptionError: () => SubscriptionError,
  TransactionBlockTimeoutError: () => TransactionBlockTimeoutError,
  TransactionDataAndInputError: () => TransactionDataAndInputError,
  TransactionError: () => TransactionError,
  TransactionGasMismatchError: () => TransactionGasMismatchError,
  TransactionGasMismatchInnerError: () => TransactionGasMismatchInnerError,
  TransactionMissingReceiptOrBlockHashError: () => TransactionMissingReceiptOrBlockHashError,
  TransactionNotFound: () => TransactionNotFound,
  TransactionOutOfGasError: () => TransactionOutOfGasError,
  TransactionPollingTimeoutError: () => TransactionPollingTimeoutError,
  TransactionReceiptMissingBlockNumberError: () => TransactionReceiptMissingBlockNumberError,
  TransactionRejectedError: () => TransactionRejectedError,
  TransactionRevertInstructionError: () => TransactionRevertInstructionError,
  TransactionRevertWithCustomError: () => TransactionRevertWithCustomError,
  TransactionRevertedWithoutReasonError: () => TransactionRevertedWithoutReasonError,
  TransactionSendTimeoutError: () => TransactionSendTimeoutError,
  TransactionSigningError: () => TransactionSigningError,
  UnableToPopulateNonceError: () => UnableToPopulateNonceError,
  UndefinedRawTransactionError: () => UndefinedRawTransactionError,
  UnsupportedFeeMarketError: () => UnsupportedFeeMarketError,
  UnsupportedTransactionTypeError: () => UnsupportedTransactionTypeError,
  VersionNotSupportedError: () => VersionNotSupportedError,
  Web3ContractError: () => Web3ContractError,
  Web3WSProviderError: () => Web3WSProviderError,
  genericRpcErrorMessageTemplate: () => genericRpcErrorMessageTemplate,
  rpcErrorsMap: () => rpcErrorsMap
});
init_shim();

// node_modules/web3-errors/lib/esm/error_codes.js
init_shim();
var ERR_RESPONSE = 100;
var ERR_INVALID_RESPONSE = 101;
var ERR_PARAM = 200;
var ERR_FORMATTERS = 201;
var ERR_METHOD_NOT_IMPLEMENTED = 202;
var ERR_OPERATION_TIMEOUT = 203;
var ERR_OPERATION_ABORT = 204;
var ERR_ABI_ENCODING = 205;
var ERR_EXISTING_PLUGIN_NAMESPACE = 206;
var ERR_INVALID_METHOD_PARAMS = 207;
var ERR_CONTRACT = 300;
var ERR_CONTRACT_RESOLVER_MISSING = 301;
var ERR_CONTRACT_ABI_MISSING = 302;
var ERR_CONTRACT_REQUIRED_CALLBACK = 303;
var ERR_CONTRACT_EVENT_NOT_EXISTS = 304;
var ERR_CONTRACT_RESERVED_EVENT = 305;
var ERR_CONTRACT_MISSING_DEPLOY_DATA = 306;
var ERR_CONTRACT_MISSING_ADDRESS = 307;
var ERR_CONTRACT_MISSING_FROM_ADDRESS = 308;
var ERR_CONTRACT_INSTANTIATION = 309;
var ERR_CONTRACT_EXECUTION_REVERTED = 310;
var ERR_CONTRACT_TX_DATA_AND_INPUT = 311;
var ERR_TX = 400;
var ERR_TX_REVERT_INSTRUCTION = 401;
var ERR_TX_REVERT_TRANSACTION = 402;
var ERR_TX_NO_CONTRACT_ADDRESS = 403;
var ERR_TX_CONTRACT_NOT_STORED = 404;
var ERR_TX_REVERT_WITHOUT_REASON = 405;
var ERR_TX_OUT_OF_GAS = 406;
var ERR_RAW_TX_UNDEFINED = 407;
var ERR_TX_INVALID_SENDER = 408;
var ERR_TX_INVALID_CALL = 409;
var ERR_TX_MISSING_CUSTOM_CHAIN = 410;
var ERR_TX_MISSING_CUSTOM_CHAIN_ID = 411;
var ERR_TX_CHAIN_ID_MISMATCH = 412;
var ERR_TX_INVALID_CHAIN_INFO = 413;
var ERR_TX_MISSING_CHAIN_INFO = 414;
var ERR_TX_MISSING_GAS = 415;
var ERR_TX_INVALID_LEGACY_GAS = 416;
var ERR_TX_INVALID_FEE_MARKET_GAS = 417;
var ERR_TX_INVALID_FEE_MARKET_GAS_PRICE = 418;
var ERR_TX_INVALID_LEGACY_FEE_MARKET = 419;
var ERR_TX_INVALID_OBJECT = 420;
var ERR_TX_INVALID_NONCE_OR_CHAIN_ID = 421;
var ERR_TX_UNABLE_TO_POPULATE_NONCE = 422;
var ERR_TX_UNSUPPORTED_EIP_1559 = 423;
var ERR_TX_UNSUPPORTED_TYPE = 424;
var ERR_TX_DATA_AND_INPUT = 425;
var ERR_TX_POLLING_TIMEOUT = 426;
var ERR_TX_RECEIPT_MISSING_OR_BLOCKHASH_NULL = 427;
var ERR_TX_RECEIPT_MISSING_BLOCK_NUMBER = 428;
var ERR_TX_LOCAL_WALLET_NOT_AVAILABLE = 429;
var ERR_TX_NOT_FOUND = 430;
var ERR_TX_SEND_TIMEOUT = 431;
var ERR_TX_BLOCK_TIMEOUT = 432;
var ERR_TX_SIGNING = 433;
var ERR_TX_GAS_MISMATCH = 434;
var ERR_TX_CHAIN_MISMATCH = 435;
var ERR_TX_HARDFORK_MISMATCH = 436;
var ERR_TX_INVALID_RECEIVER = 437;
var ERR_TX_REVERT_TRANSACTION_CUSTOM_ERROR = 438;
var ERR_TX_INVALID_PROPERTIES_FOR_TYPE = 439;
var ERR_TX_MISSING_GAS_INNER_ERROR = 440;
var ERR_TX_GAS_MISMATCH_INNER_ERROR = 441;
var ERR_CONN = 500;
var ERR_CONN_INVALID = 501;
var ERR_CONN_TIMEOUT = 502;
var ERR_CONN_NOT_OPEN = 503;
var ERR_CONN_CLOSE = 504;
var ERR_CONN_MAX_ATTEMPTS = 505;
var ERR_CONN_PENDING_REQUESTS = 506;
var ERR_REQ_ALREADY_SENT = 507;
var ERR_PROVIDER = 600;
var ERR_INVALID_PROVIDER = 601;
var ERR_INVALID_CLIENT = 602;
var ERR_SUBSCRIPTION = 603;
var ERR_WS_PROVIDER = 604;
var ERR_PRIVATE_KEY_LENGTH = 701;
var ERR_INVALID_PRIVATE_KEY = 702;
var ERR_UNSUPPORTED_KDF = 703;
var ERR_KEY_DERIVATION_FAIL = 704;
var ERR_KEY_VERSION_UNSUPPORTED = 705;
var ERR_INVALID_PASSWORD = 706;
var ERR_IV_LENGTH = 707;
var ERR_INVALID_KEYSTORE = 708;
var ERR_PBKDF2_ITERATIONS = 709;
var ERR_SIGNATURE_FAILED = 801;
var ERR_INVALID_SIGNATURE = 802;
var GENESIS_BLOCK_NUMBER = "0x0";
var JSONRPC_ERR_REJECTED_REQUEST = 4001;
var JSONRPC_ERR_UNAUTHORIZED = 4100;
var JSONRPC_ERR_UNSUPPORTED_METHOD = 4200;
var JSONRPC_ERR_DISCONNECTED = 4900;
var JSONRPC_ERR_CHAIN_DISCONNECTED = 4901;
var ERR_ENS_CHECK_INTERFACE_SUPPORT = 901;
var ERR_ENS_UNSUPPORTED_NETWORK = 902;
var ERR_ENS_NETWORK_NOT_SYNCED = 903;
var ERR_INVALID_STRING = 1001;
var ERR_INVALID_BYTES = 1002;
var ERR_INVALID_NUMBER = 1003;
var ERR_INVALID_UNIT = 1004;
var ERR_INVALID_ADDRESS = 1005;
var ERR_INVALID_HEX = 1006;
var ERR_INVALID_TYPE = 1007;
var ERR_INVALID_BOOLEAN = 1008;
var ERR_INVALID_UNSIGNED_INTEGER = 1009;
var ERR_INVALID_SIZE = 1010;
var ERR_INVALID_LARGE_VALUE = 1011;
var ERR_INVALID_BLOCK = 1012;
var ERR_INVALID_TYPE_ABI = 1013;
var ERR_INVALID_NIBBLE_WIDTH = 1014;
var ERR_VALIDATION = 1100;
var ERR_CORE_HARDFORK_MISMATCH = 1101;
var ERR_CORE_CHAIN_MISMATCH = 1102;
var ERR_SCHEMA_FORMAT = 1200;
var ERR_RPC_INVALID_JSON = -32700;
var ERR_RPC_INVALID_REQUEST = -32600;
var ERR_RPC_INVALID_METHOD = -32601;
var ERR_RPC_INVALID_PARAMS = -32602;
var ERR_RPC_INTERNAL_ERROR = -32603;
var ERR_RPC_INVALID_INPUT = -32e3;
var ERR_RPC_MISSING_RESOURCE = -32001;
var ERR_RPC_UNAVAILABLE_RESOURCE = -32002;
var ERR_RPC_TRANSACTION_REJECTED = -32003;
var ERR_RPC_UNSUPPORTED_METHOD = -32004;
var ERR_RPC_LIMIT_EXCEEDED = -32005;
var ERR_RPC_NOT_SUPPORTED = -32006;

// node_modules/web3-errors/lib/esm/web3_error_base.js
init_shim();
var BaseWeb3Error = class extends Error {
  constructor(msg, innerError) {
    super(msg);
    this.innerError = innerError;
    this.name = this.constructor.name;
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(new.target.constructor);
    } else {
      this.stack = new Error().stack;
    }
  }
  static convertToString(value, unquotValue = false) {
    if (value === null || value === void 0)
      return "undefined";
    const result = JSON.stringify(value, (_, v) => typeof v === "bigint" ? v.toString() : v);
    return unquotValue && ["bigint", "string"].includes(typeof value) ? result.replace(/['\\"]+/g, "") : result;
  }
  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message,
      innerError: this.innerError
    };
  }
};
var InvalidValueError = class extends BaseWeb3Error {
  constructor(value, msg) {
    super(`Invalid value given "${BaseWeb3Error.convertToString(value, true)}". Error: ${msg}.`);
    this.name = this.constructor.name;
  }
};

// node_modules/web3-errors/lib/esm/errors/account_errors.js
init_shim();
var PrivateKeyLengthError = class extends BaseWeb3Error {
  constructor() {
    super(`Private key must be 32 bytes.`);
    this.code = ERR_PRIVATE_KEY_LENGTH;
  }
};
var InvalidPrivateKeyError = class extends BaseWeb3Error {
  constructor() {
    super(`Invalid Private Key, Not a valid string or uint8Array`);
    this.code = ERR_INVALID_PRIVATE_KEY;
  }
};
var InvalidSignatureError = class extends BaseWeb3Error {
  constructor(errorDetails) {
    super(`"${errorDetails}"`);
    this.code = ERR_INVALID_SIGNATURE;
  }
};
var InvalidKdfError = class extends BaseWeb3Error {
  constructor() {
    super(`Invalid key derivation function`);
    this.code = ERR_UNSUPPORTED_KDF;
  }
};
var KeyDerivationError = class extends BaseWeb3Error {
  constructor() {
    super(`Key derivation failed - possibly wrong password`);
    this.code = ERR_KEY_DERIVATION_FAIL;
  }
};
var KeyStoreVersionError = class extends BaseWeb3Error {
  constructor() {
    super("Unsupported key store version");
    this.code = ERR_KEY_VERSION_UNSUPPORTED;
  }
};
var InvalidPasswordError = class extends BaseWeb3Error {
  constructor() {
    super("Password cannot be empty");
    this.code = ERR_INVALID_PASSWORD;
  }
};
var IVLengthError = class extends BaseWeb3Error {
  constructor() {
    super("Initialization vector must be 16 bytes");
    this.code = ERR_IV_LENGTH;
  }
};
var PBKDF2IterationsError = class extends BaseWeb3Error {
  constructor() {
    super("c > 1000, pbkdf2 is less secure with less iterations");
    this.code = ERR_PBKDF2_ITERATIONS;
  }
};

// node_modules/web3-errors/lib/esm/errors/connection_errors.js
init_shim();
var ConnectionError = class extends BaseWeb3Error {
  constructor(message, event) {
    super(message);
    this.code = ERR_CONN;
    if (event) {
      this.errorCode = event.code;
      this.errorReason = event.reason;
    }
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { errorCode: this.errorCode, errorReason: this.errorReason });
  }
};
var InvalidConnectionError = class extends ConnectionError {
  constructor(host, event) {
    super(`CONNECTION ERROR: Couldn't connect to node ${host}.`, event);
    this.host = host;
    this.code = ERR_CONN_INVALID;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { host: this.host });
  }
};
var ConnectionTimeoutError = class extends ConnectionError {
  constructor(duration) {
    super(`CONNECTION TIMEOUT: timeout of ${duration}ms achieved`);
    this.duration = duration;
    this.code = ERR_CONN_TIMEOUT;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { duration: this.duration });
  }
};
var ConnectionNotOpenError = class extends ConnectionError {
  constructor(event) {
    super("Connection not open", event);
    this.code = ERR_CONN_NOT_OPEN;
  }
};
var ConnectionCloseError = class extends ConnectionError {
  constructor(event) {
    var _a16, _b;
    super(`CONNECTION ERROR: The connection got closed with the close code ${(_a16 = event === null || event === void 0 ? void 0 : event.code) !== null && _a16 !== void 0 ? _a16 : ""} and the following reason string ${(_b = event === null || event === void 0 ? void 0 : event.reason) !== null && _b !== void 0 ? _b : ""}`, event);
    this.code = ERR_CONN_CLOSE;
  }
};
var MaxAttemptsReachedOnReconnectingError = class extends ConnectionError {
  constructor(numberOfAttempts) {
    super(`Maximum number of reconnect attempts reached! (${numberOfAttempts})`);
    this.code = ERR_CONN_MAX_ATTEMPTS;
  }
};
var PendingRequestsOnReconnectingError = class extends ConnectionError {
  constructor() {
    super("CONNECTION ERROR: Provider started to reconnect before the response got received!");
    this.code = ERR_CONN_PENDING_REQUESTS;
  }
};
var RequestAlreadySentError = class extends ConnectionError {
  constructor(id) {
    super(`Request already sent with following id: ${id}`);
    this.code = ERR_REQ_ALREADY_SENT;
  }
};

// node_modules/web3-errors/lib/esm/errors/contract_errors.js
init_shim();
var Web3ContractError = class extends BaseWeb3Error {
  constructor(message, receipt) {
    super(message);
    this.code = ERR_CONTRACT;
    this.receipt = receipt;
  }
};
var ResolverMethodMissingError = class extends BaseWeb3Error {
  constructor(address, name2) {
    super(`The resolver at ${address} does not implement requested method: "${name2}".`);
    this.address = address;
    this.name = name2;
    this.code = ERR_CONTRACT_RESOLVER_MISSING;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { address: this.address, name: this.name });
  }
};
var ContractMissingABIError = class extends BaseWeb3Error {
  constructor() {
    super("You must provide the json interface of the contract when instantiating a contract object.");
    this.code = ERR_CONTRACT_ABI_MISSING;
  }
};
var ContractOnceRequiresCallbackError = class extends BaseWeb3Error {
  constructor() {
    super("Once requires a callback as the second parameter.");
    this.code = ERR_CONTRACT_REQUIRED_CALLBACK;
  }
};
var ContractEventDoesNotExistError = class extends BaseWeb3Error {
  constructor(eventName) {
    super(`Event "${eventName}" doesn't exist in this contract.`);
    this.eventName = eventName;
    this.code = ERR_CONTRACT_EVENT_NOT_EXISTS;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { eventName: this.eventName });
  }
};
var ContractReservedEventError = class extends BaseWeb3Error {
  constructor(type) {
    super(`Event "${type}" doesn't exist in this contract.`);
    this.type = type;
    this.code = ERR_CONTRACT_RESERVED_EVENT;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { type: this.type });
  }
};
var ContractMissingDeployDataError = class extends BaseWeb3Error {
  constructor() {
    super(`No "data" specified in neither the given options, nor the default options.`);
    this.code = ERR_CONTRACT_MISSING_DEPLOY_DATA;
  }
};
var ContractNoAddressDefinedError = class extends BaseWeb3Error {
  constructor() {
    super("This contract object doesn't have address set yet, please set an address first.");
    this.code = ERR_CONTRACT_MISSING_ADDRESS;
  }
};
var ContractNoFromAddressDefinedError = class extends BaseWeb3Error {
  constructor() {
    super('No "from" address specified in neither the given options, nor the default options.');
    this.code = ERR_CONTRACT_MISSING_FROM_ADDRESS;
  }
};
var ContractInstantiationError = class extends BaseWeb3Error {
  constructor() {
    super(...arguments);
    this.code = ERR_CONTRACT_INSTANTIATION;
  }
};
var Eip838ExecutionError = class extends Web3ContractError {
  constructor(error) {
    super(error.message || "Error");
    this.name = "name" in error && error.name || this.constructor.name;
    this.stack = "stack" in error && error.stack || void 0;
    this.code = error.code;
    if (typeof error.data === "object") {
      let originalError;
      if ("originalError" in error.data) {
        originalError = error.data.originalError;
      } else {
        originalError = error.data;
      }
      this.data = originalError.data;
      this.innerError = new Eip838ExecutionError(originalError);
    } else {
      this.data = error.data;
    }
  }
  setDecodedProperties(errorName, errorSignature, errorArgs) {
    this.errorName = errorName;
    this.errorSignature = errorSignature;
    this.errorArgs = errorArgs;
  }
  toJSON() {
    let json = Object.assign(Object.assign({}, super.toJSON()), { data: this.data });
    if (this.errorName) {
      json = Object.assign(Object.assign({}, json), { errorName: this.errorName, errorSignature: this.errorSignature, errorArgs: this.errorArgs });
    }
    return json;
  }
};
var ContractExecutionError = class extends Web3ContractError {
  constructor(rpcError) {
    super("Error happened while trying to execute a function inside a smart contract");
    this.code = ERR_CONTRACT_EXECUTION_REVERTED;
    this.innerError = new Eip838ExecutionError(rpcError);
  }
};
var ContractTransactionDataAndInputError = class extends InvalidValueError {
  constructor(value) {
    var _a16, _b;
    super(`data: ${(_a16 = value.data) !== null && _a16 !== void 0 ? _a16 : "undefined"}, input: ${(_b = value.input) !== null && _b !== void 0 ? _b : "undefined"}`, `You can't have "data" and "input" as properties of a contract at the same time, please use either "data" or "input" instead.`);
    this.code = ERR_CONTRACT_TX_DATA_AND_INPUT;
  }
};

// node_modules/web3-errors/lib/esm/errors/ens_errors.js
init_shim();
var ENSCheckInterfaceSupportError = class extends BaseWeb3Error {
  constructor(errorDetails) {
    super(`ENS resolver check interface support error. "${errorDetails}"`);
    this.code = ERR_ENS_CHECK_INTERFACE_SUPPORT;
  }
};
var ENSUnsupportedNetworkError = class extends BaseWeb3Error {
  constructor(networkType) {
    super(`ENS is not supported on network ${networkType}`);
    this.code = ERR_ENS_UNSUPPORTED_NETWORK;
  }
};
var ENSNetworkNotSyncedError = class extends BaseWeb3Error {
  constructor() {
    super(`Network not synced`);
    this.code = ERR_ENS_NETWORK_NOT_SYNCED;
  }
};

// node_modules/web3-errors/lib/esm/errors/generic_errors.js
init_shim();
var InvalidNumberOfParamsError = class extends BaseWeb3Error {
  constructor(got, expected, method) {
    super(`Invalid number of parameters for "${method}". Got "${got}" expected "${expected}"!`);
    this.got = got;
    this.expected = expected;
    this.method = method;
    this.code = ERR_PARAM;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { got: this.got, expected: this.expected, method: this.method });
  }
};
var InvalidMethodParamsError = class extends BaseWeb3Error {
  constructor(hint) {
    super(`Invalid parameters passed. "${typeof hint !== "undefined" ? hint : ""}"`);
    this.hint = hint;
    this.code = ERR_INVALID_METHOD_PARAMS;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { hint: this.hint });
  }
};
var FormatterError = class extends BaseWeb3Error {
  constructor() {
    super(...arguments);
    this.code = ERR_FORMATTERS;
  }
};
var MethodNotImplementedError = class extends BaseWeb3Error {
  constructor() {
    super("The method you're trying to call is not implemented.");
    this.code = ERR_METHOD_NOT_IMPLEMENTED;
  }
};
var OperationTimeoutError = class extends BaseWeb3Error {
  constructor() {
    super(...arguments);
    this.code = ERR_OPERATION_TIMEOUT;
  }
};
var OperationAbortError = class extends BaseWeb3Error {
  constructor() {
    super(...arguments);
    this.code = ERR_OPERATION_ABORT;
  }
};
var AbiError = class extends BaseWeb3Error {
  constructor(message, props) {
    super(message);
    this.code = ERR_ABI_ENCODING;
    this.props = props !== null && props !== void 0 ? props : {};
  }
};
var ExistingPluginNamespaceError = class extends BaseWeb3Error {
  constructor(pluginNamespace) {
    super(`A plugin with the namespace: ${pluginNamespace} has already been registered.`);
    this.code = ERR_EXISTING_PLUGIN_NAMESPACE;
  }
};

// node_modules/web3-errors/lib/esm/errors/provider_errors.js
init_shim();
var ProviderError = class extends BaseWeb3Error {
  constructor() {
    super(...arguments);
    this.code = ERR_PROVIDER;
  }
};
var InvalidProviderError = class extends BaseWeb3Error {
  constructor(clientUrl) {
    super(`Provider with url "${clientUrl}" is not set or invalid`);
    this.clientUrl = clientUrl;
    this.code = ERR_INVALID_PROVIDER;
  }
};
var InvalidClientError = class extends BaseWeb3Error {
  constructor(clientUrl) {
    super(`Client URL "${clientUrl}" is invalid.`);
    this.code = ERR_INVALID_CLIENT;
  }
};
var SubscriptionError = class extends BaseWeb3Error {
  constructor() {
    super(...arguments);
    this.code = ERR_SUBSCRIPTION;
  }
};
var Web3WSProviderError = class extends BaseWeb3Error {
  constructor() {
    super(...arguments);
    this.code = ERR_WS_PROVIDER;
  }
};

// node_modules/web3-errors/lib/esm/errors/signature_errors.js
init_shim();
var SignatureError = class extends InvalidValueError {
  constructor() {
    super(...arguments);
    this.code = ERR_SIGNATURE_FAILED;
  }
};

// node_modules/web3-errors/lib/esm/errors/transaction_errors.js
init_shim();
var TransactionError = class extends BaseWeb3Error {
  constructor(message, receipt) {
    super(message);
    this.receipt = receipt;
    this.code = ERR_TX;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { receipt: this.receipt });
  }
};
var RevertInstructionError = class extends BaseWeb3Error {
  constructor(reason, signature) {
    super(`Your request got reverted with the following reason string: ${reason}`);
    this.reason = reason;
    this.signature = signature;
    this.code = ERR_TX_REVERT_INSTRUCTION;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { reason: this.reason, signature: this.signature });
  }
};
var TransactionRevertInstructionError = class extends BaseWeb3Error {
  constructor(reason, signature, receipt, data) {
    super(`Transaction has been reverted by the EVM${receipt === void 0 ? "" : `:
 ${BaseWeb3Error.convertToString(receipt)}`}`);
    this.reason = reason;
    this.signature = signature;
    this.receipt = receipt;
    this.data = data;
    this.code = ERR_TX_REVERT_TRANSACTION;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { reason: this.reason, signature: this.signature, receipt: this.receipt, data: this.data });
  }
};
var TransactionRevertWithCustomError = class extends TransactionRevertInstructionError {
  constructor(reason, customErrorName, customErrorDecodedSignature, customErrorArguments, signature, receipt, data) {
    super(reason);
    this.reason = reason;
    this.customErrorName = customErrorName;
    this.customErrorDecodedSignature = customErrorDecodedSignature;
    this.customErrorArguments = customErrorArguments;
    this.signature = signature;
    this.receipt = receipt;
    this.data = data;
    this.code = ERR_TX_REVERT_TRANSACTION_CUSTOM_ERROR;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { reason: this.reason, customErrorName: this.customErrorName, customErrorDecodedSignature: this.customErrorDecodedSignature, customErrorArguments: this.customErrorArguments, signature: this.signature, receipt: this.receipt, data: this.data });
  }
};
var NoContractAddressFoundError = class extends TransactionError {
  constructor(receipt) {
    super("The transaction receipt didn't contain a contract address.", receipt);
    this.code = ERR_TX_NO_CONTRACT_ADDRESS;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { receipt: this.receipt });
  }
};
var ContractCodeNotStoredError = class extends TransactionError {
  constructor(receipt) {
    super("The contract code couldn't be stored, please check your gas limit.", receipt);
    this.code = ERR_TX_CONTRACT_NOT_STORED;
  }
};
var TransactionRevertedWithoutReasonError = class extends TransactionError {
  constructor(receipt) {
    super(`Transaction has been reverted by the EVM${receipt === void 0 ? "" : `:
 ${BaseWeb3Error.convertToString(receipt)}`}`, receipt);
    this.code = ERR_TX_REVERT_WITHOUT_REASON;
  }
};
var TransactionOutOfGasError = class extends TransactionError {
  constructor(receipt) {
    super(`Transaction ran out of gas. Please provide more gas:
 ${JSON.stringify(receipt, void 0, 2)}`, receipt);
    this.code = ERR_TX_OUT_OF_GAS;
  }
};
var UndefinedRawTransactionError = class extends TransactionError {
  constructor() {
    super(`Raw transaction undefined`);
    this.code = ERR_RAW_TX_UNDEFINED;
  }
};
var TransactionNotFound = class extends TransactionError {
  constructor() {
    super("Transaction not found");
    this.code = ERR_TX_NOT_FOUND;
  }
};
var InvalidTransactionWithSender = class extends InvalidValueError {
  constructor(value) {
    super(value, "invalid transaction with invalid sender");
    this.code = ERR_TX_INVALID_SENDER;
  }
};
var InvalidTransactionWithReceiver = class extends InvalidValueError {
  constructor(value) {
    super(value, "invalid transaction with invalid receiver");
    this.code = ERR_TX_INVALID_RECEIVER;
  }
};
var InvalidTransactionCall = class extends InvalidValueError {
  constructor(value) {
    super(value, "invalid transaction call");
    this.code = ERR_TX_INVALID_CALL;
  }
};
var MissingCustomChainError = class extends InvalidValueError {
  constructor() {
    super("MissingCustomChainError", "If tx.common is provided it must have tx.common.customChain");
    this.code = ERR_TX_MISSING_CUSTOM_CHAIN;
  }
};
var MissingCustomChainIdError = class extends InvalidValueError {
  constructor() {
    super("MissingCustomChainIdError", "If tx.common is provided it must have tx.common.customChain and tx.common.customChain.chainId");
    this.code = ERR_TX_MISSING_CUSTOM_CHAIN_ID;
  }
};
var ChainIdMismatchError = class extends InvalidValueError {
  constructor(value) {
    super(
      JSON.stringify(value),
      "Chain Id doesnt match in tx.chainId tx.common.customChain.chainId"
    );
    this.code = ERR_TX_CHAIN_ID_MISMATCH;
  }
};
var ChainMismatchError = class extends InvalidValueError {
  constructor(value) {
    super(JSON.stringify(value), "Chain doesnt match in tx.chain tx.common.basechain");
    this.code = ERR_TX_CHAIN_MISMATCH;
  }
};
var HardforkMismatchError = class extends InvalidValueError {
  constructor(value) {
    super(JSON.stringify(value), "hardfork doesnt match in tx.hardfork tx.common.hardfork");
    this.code = ERR_TX_HARDFORK_MISMATCH;
  }
};
var CommonOrChainAndHardforkError = class extends InvalidValueError {
  constructor() {
    super("CommonOrChainAndHardforkError", "Please provide the common object or the chain and hardfork property but not all together.");
    this.code = ERR_TX_INVALID_CHAIN_INFO;
  }
};
var MissingChainOrHardforkError = class extends InvalidValueError {
  constructor(value) {
    var _a16, _b;
    super("MissingChainOrHardforkError", `When specifying chain and hardfork, both values must be defined. Received "chain": ${(_a16 = value.chain) !== null && _a16 !== void 0 ? _a16 : "undefined"}, "hardfork": ${(_b = value.hardfork) !== null && _b !== void 0 ? _b : "undefined"}`);
    this.code = ERR_TX_MISSING_CHAIN_INFO;
  }
};
var MissingGasInnerError = class extends BaseWeb3Error {
  constructor() {
    super('Missing properties in transaction, either define "gas" and "gasPrice" for type 0 transactions or "gas", "maxPriorityFeePerGas" and "maxFeePerGas" for type 2 transactions');
    this.code = ERR_TX_MISSING_GAS_INNER_ERROR;
  }
};
var MissingGasError = class extends InvalidValueError {
  constructor(value) {
    var _a16, _b, _c, _d;
    super(`gas: ${(_a16 = value.gas) !== null && _a16 !== void 0 ? _a16 : "undefined"}, gasPrice: ${(_b = value.gasPrice) !== null && _b !== void 0 ? _b : "undefined"}, maxPriorityFeePerGas: ${(_c = value.maxPriorityFeePerGas) !== null && _c !== void 0 ? _c : "undefined"}, maxFeePerGas: ${(_d = value.maxFeePerGas) !== null && _d !== void 0 ? _d : "undefined"}`, '"gas" is missing');
    this.code = ERR_TX_MISSING_GAS;
    this.innerError = new MissingGasInnerError();
  }
};
var TransactionGasMismatchInnerError = class extends BaseWeb3Error {
  constructor() {
    super('Missing properties in transaction, either define "gas" and "gasPrice" for type 0 transactions or "gas", "maxPriorityFeePerGas" and "maxFeePerGas" for type 2 transactions, not both');
    this.code = ERR_TX_GAS_MISMATCH_INNER_ERROR;
  }
};
var TransactionGasMismatchError = class extends InvalidValueError {
  constructor(value) {
    var _a16, _b, _c, _d;
    super(`gas: ${(_a16 = value.gas) !== null && _a16 !== void 0 ? _a16 : "undefined"}, gasPrice: ${(_b = value.gasPrice) !== null && _b !== void 0 ? _b : "undefined"}, maxPriorityFeePerGas: ${(_c = value.maxPriorityFeePerGas) !== null && _c !== void 0 ? _c : "undefined"}, maxFeePerGas: ${(_d = value.maxFeePerGas) !== null && _d !== void 0 ? _d : "undefined"}`, "transaction must specify legacy or fee market gas properties, not both");
    this.code = ERR_TX_GAS_MISMATCH;
    this.innerError = new TransactionGasMismatchInnerError();
  }
};
var InvalidGasOrGasPrice = class extends InvalidValueError {
  constructor(value) {
    var _a16, _b;
    super(`gas: ${(_a16 = value.gas) !== null && _a16 !== void 0 ? _a16 : "undefined"}, gasPrice: ${(_b = value.gasPrice) !== null && _b !== void 0 ? _b : "undefined"}`, "Gas or gasPrice is lower than 0");
    this.code = ERR_TX_INVALID_LEGACY_GAS;
  }
};
var InvalidMaxPriorityFeePerGasOrMaxFeePerGas = class extends InvalidValueError {
  constructor(value) {
    var _a16, _b;
    super(`maxPriorityFeePerGas: ${(_a16 = value.maxPriorityFeePerGas) !== null && _a16 !== void 0 ? _a16 : "undefined"}, maxFeePerGas: ${(_b = value.maxFeePerGas) !== null && _b !== void 0 ? _b : "undefined"}`, "maxPriorityFeePerGas or maxFeePerGas is lower than 0");
    this.code = ERR_TX_INVALID_FEE_MARKET_GAS;
  }
};
var Eip1559GasPriceError = class extends InvalidValueError {
  constructor(value) {
    super(value, "eip-1559 transactions don't support gasPrice");
    this.code = ERR_TX_INVALID_FEE_MARKET_GAS_PRICE;
  }
};
var UnsupportedFeeMarketError = class extends InvalidValueError {
  constructor(value) {
    var _a16, _b;
    super(`maxPriorityFeePerGas: ${(_a16 = value.maxPriorityFeePerGas) !== null && _a16 !== void 0 ? _a16 : "undefined"}, maxFeePerGas: ${(_b = value.maxFeePerGas) !== null && _b !== void 0 ? _b : "undefined"}`, "pre-eip-1559 transaction don't support maxFeePerGas/maxPriorityFeePerGas");
    this.code = ERR_TX_INVALID_LEGACY_FEE_MARKET;
  }
};
var InvalidTransactionObjectError = class extends InvalidValueError {
  constructor(value) {
    super(value, "invalid transaction object");
    this.code = ERR_TX_INVALID_OBJECT;
  }
};
var InvalidNonceOrChainIdError = class extends InvalidValueError {
  constructor(value) {
    var _a16, _b;
    super(`nonce: ${(_a16 = value.nonce) !== null && _a16 !== void 0 ? _a16 : "undefined"}, chainId: ${(_b = value.chainId) !== null && _b !== void 0 ? _b : "undefined"}`, "Nonce or chainId is lower than 0");
    this.code = ERR_TX_INVALID_NONCE_OR_CHAIN_ID;
  }
};
var UnableToPopulateNonceError = class extends InvalidValueError {
  constructor() {
    super("UnableToPopulateNonceError", "unable to populate nonce, no from address available");
    this.code = ERR_TX_UNABLE_TO_POPULATE_NONCE;
  }
};
var Eip1559NotSupportedError = class extends InvalidValueError {
  constructor() {
    super("Eip1559NotSupportedError", "Network doesn't support eip-1559");
    this.code = ERR_TX_UNSUPPORTED_EIP_1559;
  }
};
var UnsupportedTransactionTypeError = class extends InvalidValueError {
  constructor(value) {
    super(value, "unsupported transaction type");
    this.code = ERR_TX_UNSUPPORTED_TYPE;
  }
};
var TransactionDataAndInputError = class extends InvalidValueError {
  constructor(value) {
    var _a16, _b;
    super(`data: ${(_a16 = value.data) !== null && _a16 !== void 0 ? _a16 : "undefined"}, input: ${(_b = value.input) !== null && _b !== void 0 ? _b : "undefined"}`, `You can't have "data" and "input" as properties of transactions at the same time, please use either "data" or "input" instead.`);
    this.code = ERR_TX_DATA_AND_INPUT;
  }
};
var TransactionSendTimeoutError = class extends BaseWeb3Error {
  constructor(value) {
    super(`The connected Ethereum Node did not respond within ${value.numberOfSeconds} seconds, please make sure your transaction was properly sent and you are connected to a healthy Node. Be aware that transaction might still be pending or mined!
	Transaction Hash: ${value.transactionHash ? value.transactionHash.toString() : "not available"}`);
    this.code = ERR_TX_SEND_TIMEOUT;
  }
};
function transactionTimeoutHint(transactionHash) {
  return `Please make sure your transaction was properly sent and there are no previous pending transaction for the same account. However, be aware that it might still be mined!
	Transaction Hash: ${transactionHash ? transactionHash.toString() : "not available"}`;
}
var TransactionPollingTimeoutError = class extends BaseWeb3Error {
  constructor(value) {
    super(`Transaction was not mined within ${value.numberOfSeconds} seconds. ${transactionTimeoutHint(value.transactionHash)}`);
    this.code = ERR_TX_POLLING_TIMEOUT;
  }
};
var TransactionBlockTimeoutError = class extends BaseWeb3Error {
  constructor(value) {
    super(`Transaction started at ${value.starterBlockNumber} but was not mined within ${value.numberOfBlocks} blocks. ${transactionTimeoutHint(value.transactionHash)}`);
    this.code = ERR_TX_BLOCK_TIMEOUT;
  }
};
var TransactionMissingReceiptOrBlockHashError = class extends InvalidValueError {
  constructor(value) {
    var _a16, _b;
    super(`receipt: ${JSON.stringify(value.receipt)}, blockHash: ${(_a16 = value.blockHash) === null || _a16 === void 0 ? void 0 : _a16.toString()}, transactionHash: ${(_b = value.transactionHash) === null || _b === void 0 ? void 0 : _b.toString()}`, `Receipt missing or blockHash null`);
    this.code = ERR_TX_RECEIPT_MISSING_OR_BLOCKHASH_NULL;
  }
};
var TransactionReceiptMissingBlockNumberError = class extends InvalidValueError {
  constructor(value) {
    super(`receipt: ${JSON.stringify(value.receipt)}`, `Receipt missing block number`);
    this.code = ERR_TX_RECEIPT_MISSING_BLOCK_NUMBER;
  }
};
var TransactionSigningError = class extends BaseWeb3Error {
  constructor(errorDetails) {
    super(`Invalid signature. "${errorDetails}"`);
    this.code = ERR_TX_SIGNING;
  }
};
var LocalWalletNotAvailableError = class extends InvalidValueError {
  constructor() {
    super("LocalWalletNotAvailableError", `Attempted to index account in local wallet, but no wallet is available`);
    this.code = ERR_TX_LOCAL_WALLET_NOT_AVAILABLE;
  }
};
var InvalidPropertiesForTransactionTypeError = class extends BaseWeb3Error {
  constructor(validationError, txType) {
    const invalidPropertyNames = [];
    validationError.forEach((error) => invalidPropertyNames.push(error.keyword));
    super(`The following properties are invalid for the transaction type ${txType}: ${invalidPropertyNames.join(", ")}`);
    this.code = ERR_TX_INVALID_PROPERTIES_FOR_TYPE;
  }
};

// node_modules/web3-errors/lib/esm/errors/utils_errors.js
init_shim();
var InvalidBytesError = class extends InvalidValueError {
  constructor(value) {
    super(value, "can not parse as byte data");
    this.code = ERR_INVALID_BYTES;
  }
};
var InvalidNumberError = class extends InvalidValueError {
  constructor(value) {
    super(value, "can not parse as number data");
    this.code = ERR_INVALID_NUMBER;
  }
};
var InvalidAddressError = class extends InvalidValueError {
  constructor(value) {
    super(value, "invalid ethereum address");
    this.code = ERR_INVALID_ADDRESS;
  }
};
var InvalidStringError = class extends InvalidValueError {
  constructor(value) {
    super(value, "not a valid string");
    this.code = ERR_INVALID_STRING;
  }
};
var InvalidUnitError = class extends InvalidValueError {
  constructor(value) {
    super(value, "invalid unit");
    this.code = ERR_INVALID_UNIT;
  }
};
var HexProcessingError = class extends InvalidValueError {
  constructor(value) {
    super(value, "can not be converted to hex");
    this.code = ERR_INVALID_HEX;
  }
};
var NibbleWidthError = class extends InvalidValueError {
  constructor(value) {
    super(value, "value greater than the nibble width");
    this.code = ERR_INVALID_NIBBLE_WIDTH;
  }
};
var InvalidTypeError = class extends InvalidValueError {
  constructor(value) {
    super(value, "invalid type, type not supported");
    this.code = ERR_INVALID_TYPE;
  }
};
var InvalidBooleanError = class extends InvalidValueError {
  constructor(value) {
    super(value, "not a valid boolean.");
    this.code = ERR_INVALID_BOOLEAN;
  }
};
var InvalidUnsignedIntegerError = class extends InvalidValueError {
  constructor(value) {
    super(value, "not a valid unsigned integer.");
    this.code = ERR_INVALID_UNSIGNED_INTEGER;
  }
};
var InvalidSizeError = class extends InvalidValueError {
  constructor(value) {
    super(value, "invalid size given.");
    this.code = ERR_INVALID_SIZE;
  }
};
var InvalidLargeValueError = class extends InvalidValueError {
  constructor(value) {
    super(value, "value is larger than size.");
    this.code = ERR_INVALID_LARGE_VALUE;
  }
};
var InvalidBlockError = class extends InvalidValueError {
  constructor(value) {
    super(value, "invalid string given");
    this.code = ERR_INVALID_BLOCK;
  }
};
var InvalidTypeAbiInputError = class extends InvalidValueError {
  constructor(value) {
    super(value, "components found but type is not tuple");
    this.code = ERR_INVALID_TYPE_ABI;
  }
};

// node_modules/web3-errors/lib/esm/errors/response_errors.js
init_shim();
var isResponseWithError = (response) => !Array.isArray(response) && response.jsonrpc === "2.0" && !!response && (response.result === void 0 || response.result === null) && "error" in response && (typeof response.id === "number" || typeof response.id === "string");
var buildErrorMessage = (response) => isResponseWithError(response) ? response.error.message : "";
var ResponseError = class extends BaseWeb3Error {
  constructor(response, message, request) {
    var _a16;
    super(message !== null && message !== void 0 ? message : `Returned error: ${Array.isArray(response) ? response.map((r) => buildErrorMessage(r)).join(",") : buildErrorMessage(response)}`);
    this.code = ERR_RESPONSE;
    if (!message) {
      this.data = Array.isArray(response) ? response.map((r) => {
        var _a17;
        return (_a17 = r.error) === null || _a17 === void 0 ? void 0 : _a17.data;
      }) : (_a16 = response === null || response === void 0 ? void 0 : response.error) === null || _a16 === void 0 ? void 0 : _a16.data;
    }
    this.request = request;
    let errorOrErrors;
    if (`error` in response) {
      errorOrErrors = response.error;
    } else if (response instanceof Array) {
      errorOrErrors = response.map((r) => r.error);
    }
    this.innerError = errorOrErrors;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { data: this.data, request: this.request });
  }
};
var InvalidResponseError = class extends ResponseError {
  constructor(result, request) {
    super(result, void 0, request);
    this.code = ERR_INVALID_RESPONSE;
    let errorOrErrors;
    if (`error` in result) {
      errorOrErrors = result.error;
    } else if (result instanceof Array) {
      errorOrErrors = result.map((r) => r.error);
    }
    this.innerError = errorOrErrors;
  }
};

// node_modules/web3-errors/lib/esm/errors/core_errors.js
init_shim();
var ConfigHardforkMismatchError = class extends BaseWeb3Error {
  constructor(defaultHardfork, commonHardFork) {
    super(`Web3Config hardfork doesnt match in defaultHardfork ${defaultHardfork} and common.hardfork ${commonHardFork}`);
    this.code = ERR_CORE_HARDFORK_MISMATCH;
  }
};
var ConfigChainMismatchError = class extends BaseWeb3Error {
  constructor(defaultHardfork, commonHardFork) {
    super(`Web3Config chain doesnt match in defaultHardfork ${defaultHardfork} and common.hardfork ${commonHardFork}`);
    this.code = ERR_CORE_HARDFORK_MISMATCH;
  }
};

// node_modules/web3-errors/lib/esm/errors/rpc_errors.js
init_shim();

// node_modules/web3-errors/lib/esm/errors/rpc_error_messages.js
init_shim();
var genericRpcErrorMessageTemplate = "An Rpc error has occured with a code of *code*";
var RpcErrorMessages = {
  [ERR_RPC_INVALID_JSON]: {
    message: "Parse error",
    description: "Invalid JSON"
  },
  [ERR_RPC_INVALID_REQUEST]: {
    message: "Invalid request",
    description: "JSON is not a valid request object	"
  },
  [ERR_RPC_INVALID_METHOD]: {
    message: "Method not found",
    description: "Method does not exist	"
  },
  [ERR_RPC_INVALID_PARAMS]: {
    message: "Invalid params",
    description: "Invalid method parameters"
  },
  [ERR_RPC_INTERNAL_ERROR]: {
    message: "Internal error",
    description: "Internal JSON-RPC error"
  },
  [ERR_RPC_INVALID_INPUT]: {
    message: "Invalid input",
    description: "Missing or invalid parameters"
  },
  [ERR_RPC_MISSING_RESOURCE]: {
    message: "Resource not found",
    description: "Requested resource not found"
  },
  [ERR_RPC_UNAVAILABLE_RESOURCE]: {
    message: "Resource unavailable",
    description: "Requested resource not available"
  },
  [ERR_RPC_TRANSACTION_REJECTED]: {
    message: "Transaction rejected",
    description: "Transaction creation failed"
  },
  [ERR_RPC_UNSUPPORTED_METHOD]: {
    message: "Method not supported",
    description: "Method is not implemented"
  },
  [ERR_RPC_LIMIT_EXCEEDED]: {
    message: "Limit exceeded",
    description: "Request exceeds defined limit"
  },
  [ERR_RPC_NOT_SUPPORTED]: {
    message: "JSON-RPC version not supported",
    description: "Version of JSON-RPC protocol is not supported"
  },
  [JSONRPC_ERR_REJECTED_REQUEST]: {
    name: "User Rejected Request",
    message: "The user rejected the request."
  },
  [JSONRPC_ERR_UNAUTHORIZED]: {
    name: "Unauthorized",
    message: "The requested method and/or account has not been authorized by the user."
  },
  [JSONRPC_ERR_UNSUPPORTED_METHOD]: {
    name: "Unsupported Method",
    message: "The Provider does not support the requested method."
  },
  [JSONRPC_ERR_DISCONNECTED]: {
    name: "Disconnected",
    message: "The Provider is disconnected from all chains."
  },
  [JSONRPC_ERR_CHAIN_DISCONNECTED]: {
    name: "Chain Disconnected",
    message: "The Provider is not connected to the requested chain."
  },
  "0-999": {
    name: "",
    message: "Not used."
  },
  1e3: {
    name: "Normal Closure",
    message: "The connection successfully completed the purpose for which it was created."
  },
  1001: {
    name: "Going Away",
    message: "The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection."
  },
  1002: {
    name: "Protocol error",
    message: "The endpoint is terminating the connection due to a protocol error."
  },
  1003: {
    name: "Unsupported Data",
    message: "The connection is being terminated because the endpoint received data of a type it cannot accept. (For example, a text-only endpoint received binary data.)"
  },
  1004: {
    name: "Reserved",
    message: "Reserved. A meaning might be defined in the future."
  },
  1005: {
    name: "No Status Rcvd",
    message: "Reserved. Indicates that no status code was provided even though one was expected."
  },
  1006: {
    name: "Abnormal Closure",
    message: "Reserved. Indicates that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected."
  },
  1007: {
    name: "Invalid frame payload data",
    message: "The endpoint is terminating the connection because a message was received that contained inconsistent data (e.g., non-UTF-8 data within a text message)."
  },
  1008: {
    name: "Policy Violation",
    message: "The endpoint is terminating the connection because it received a message that violates its policy. This is a generic status code, used when codes 1003 and 1009 are not suitable."
  },
  1009: {
    name: "Message Too Big",
    message: "The endpoint is terminating the connection because a data frame was received that is too large."
  },
  1010: {
    name: "Mandatory Ext.",
    message: "The client is terminating the connection because it expected the server to negotiate one or more extension, but the server didn't."
  },
  1011: {
    name: "Internal Error",
    message: "The server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request."
  },
  1012: {
    name: "Service Restart",
    message: "The server is terminating the connection because it is restarting."
  },
  1013: {
    name: "Try Again Later",
    message: "The server is terminating the connection due to a temporary condition, e.g. it is overloaded and is casting off some of its clients."
  },
  1014: {
    name: "Bad Gateway",
    message: "The server was acting as a gateway or proxy and received an invalid response from the upstream server. This is similar to 502 HTTP Status Code."
  },
  1015: {
    name: "TLS handshake",
    message: "Reserved. Indicates that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified)."
  },
  "1016-2999": {
    name: "",
    message: "For definition by future revisions of the WebSocket Protocol specification, and for definition by extension specifications."
  },
  "3000-3999": {
    name: "",
    message: "For use by libraries, frameworks, and applications. These status codes are registered directly with IANA. The interpretation of these codes is undefined by the WebSocket protocol."
  },
  "4000-4999": {
    name: "",
    message: "For private use, and thus can't be registered. Such codes can be used by prior agreements between WebSocket applications. The interpretation of these codes is undefined by the WebSocket protocol."
  }
};

// node_modules/web3-errors/lib/esm/errors/rpc_errors.js
var RpcError = class extends BaseWeb3Error {
  constructor(rpcError, message) {
    super(message !== null && message !== void 0 ? message : genericRpcErrorMessageTemplate.replace("*code*", rpcError.error.code.toString()));
    this.code = rpcError.error.code;
    this.id = rpcError.id;
    this.jsonrpc = rpcError.jsonrpc;
    this.jsonRpcError = rpcError.error;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { error: this.jsonRpcError, id: this.id, jsonRpc: this.jsonrpc });
  }
};
var EIP1193ProviderRpcError = class extends BaseWeb3Error {
  constructor(code, data) {
    var _a16, _b, _c, _d;
    if (!code) {
      super();
    } else if ((_a16 = RpcErrorMessages[code]) === null || _a16 === void 0 ? void 0 : _a16.message) {
      super(RpcErrorMessages[code].message);
    } else {
      const statusCodeRange = Object.keys(RpcErrorMessages).find((statusCode) => typeof statusCode === "string" && code >= parseInt(statusCode.split("-")[0], 10) && code <= parseInt(statusCode.split("-")[1], 10));
      super((_c = (_b = RpcErrorMessages[statusCodeRange !== null && statusCodeRange !== void 0 ? statusCodeRange : ""]) === null || _b === void 0 ? void 0 : _b.message) !== null && _c !== void 0 ? _c : genericRpcErrorMessageTemplate.replace("*code*", (_d = code === null || code === void 0 ? void 0 : code.toString()) !== null && _d !== void 0 ? _d : '""'));
    }
    this.code = code;
    this.data = data;
  }
};
var ParseError = class extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INVALID_JSON].message);
    this.code = ERR_RPC_INVALID_JSON;
  }
};
var InvalidRequestError = class extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INVALID_REQUEST].message);
    this.code = ERR_RPC_INVALID_REQUEST;
  }
};
var MethodNotFoundError = class extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INVALID_METHOD].message);
    this.code = ERR_RPC_INVALID_METHOD;
  }
};
var InvalidParamsError = class extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INVALID_PARAMS].message);
    this.code = ERR_RPC_INVALID_PARAMS;
  }
};
var InternalError = class extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INTERNAL_ERROR].message);
    this.code = ERR_RPC_INTERNAL_ERROR;
  }
};
var InvalidInputError = class extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INVALID_INPUT].message);
    this.code = ERR_RPC_INVALID_INPUT;
  }
};
var MethodNotSupported = class extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_UNSUPPORTED_METHOD].message);
    this.code = ERR_RPC_UNSUPPORTED_METHOD;
  }
};
var ResourceUnavailableError = class extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_UNAVAILABLE_RESOURCE].message);
    this.code = ERR_RPC_UNAVAILABLE_RESOURCE;
  }
};
var ResourcesNotFoundError = class extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_MISSING_RESOURCE].message);
    this.code = ERR_RPC_MISSING_RESOURCE;
  }
};
var VersionNotSupportedError = class extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_NOT_SUPPORTED].message);
    this.code = ERR_RPC_NOT_SUPPORTED;
  }
};
var TransactionRejectedError = class extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_TRANSACTION_REJECTED].message);
    this.code = ERR_RPC_TRANSACTION_REJECTED;
  }
};
var LimitExceededError = class extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_LIMIT_EXCEEDED].message);
    this.code = ERR_RPC_LIMIT_EXCEEDED;
  }
};
var rpcErrorsMap = /* @__PURE__ */ new Map();
rpcErrorsMap.set(ERR_RPC_INVALID_JSON, { error: ParseError });
rpcErrorsMap.set(ERR_RPC_INVALID_REQUEST, {
  error: InvalidRequestError
});
rpcErrorsMap.set(ERR_RPC_INVALID_METHOD, {
  error: MethodNotFoundError
});
rpcErrorsMap.set(ERR_RPC_INVALID_PARAMS, { error: InvalidParamsError });
rpcErrorsMap.set(ERR_RPC_INTERNAL_ERROR, { error: InternalError });
rpcErrorsMap.set(ERR_RPC_INVALID_INPUT, { error: InvalidInputError });
rpcErrorsMap.set(ERR_RPC_UNSUPPORTED_METHOD, {
  error: MethodNotSupported
});
rpcErrorsMap.set(ERR_RPC_UNAVAILABLE_RESOURCE, {
  error: ResourceUnavailableError
});
rpcErrorsMap.set(ERR_RPC_TRANSACTION_REJECTED, {
  error: TransactionRejectedError
});
rpcErrorsMap.set(ERR_RPC_MISSING_RESOURCE, {
  error: ResourcesNotFoundError
});
rpcErrorsMap.set(ERR_RPC_NOT_SUPPORTED, {
  error: VersionNotSupportedError
});
rpcErrorsMap.set(ERR_RPC_LIMIT_EXCEEDED, { error: LimitExceededError });

// node_modules/web3-errors/lib/esm/errors/schema_errors.js
init_shim();
var SchemaFormatError = class extends BaseWeb3Error {
  constructor(type) {
    super(`Format for the type ${type} is unsupported`);
    this.type = type;
    this.code = ERR_SCHEMA_FORMAT;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { type: this.type });
  }
};

// node_modules/web3/node_modules/web3-utils/lib/esm/index.js
var esm_exports4 = {};
__export(esm_exports4, {
  ChunkResponseParser: () => ChunkResponseParser,
  Eip1193Provider: () => Eip1193Provider,
  EventEmitter: () => EventEmitter,
  SocketProvider: () => SocketProvider,
  Web3DeferredPromise: () => Web3DeferredPromise,
  asciiToHex: () => asciiToHex,
  bytesToHex: () => bytesToHex2,
  bytesToUint8Array: () => bytesToUint8Array,
  checkAddressCheckSum: () => checkAddressCheckSum2,
  compareBlockNumbers: () => compareBlockNumbers,
  convert: () => convert,
  convertScalarValue: () => convertScalarValue,
  encodePacked: () => encodePacked,
  ethUnitMap: () => ethUnitMap,
  format: () => format,
  fromAscii: () => fromAscii,
  fromDecimal: () => fromDecimal,
  fromTwosComplement: () => fromTwosComplement,
  fromUtf8: () => fromUtf8,
  fromWei: () => fromWei,
  getStorageSlotNumForLongString: () => getStorageSlotNumForLongString,
  hexToAscii: () => hexToAscii,
  hexToBytes: () => hexToBytes2,
  hexToNumber: () => hexToNumber2,
  hexToNumberString: () => hexToNumberString,
  hexToString: () => hexToString,
  hexToUtf8: () => hexToUtf8,
  isAddress: () => isAddress2,
  isBatchRequest: () => isBatchRequest,
  isBatchResponse: () => isBatchResponse,
  isBloom: () => isBloom2,
  isContractAddressInBloom: () => isContractAddressInBloom2,
  isDataFormat: () => isDataFormat,
  isHex: () => isHex2,
  isHexStrict: () => isHexStrict2,
  isInBloom: () => isInBloom2,
  isNullish: () => isNullish2,
  isPromise: () => isPromise,
  isResponseRpcError: () => isResponseRpcError,
  isResponseWithError: () => isResponseWithError2,
  isResponseWithNotification: () => isResponseWithNotification,
  isResponseWithResult: () => isResponseWithResult,
  isSubscriptionResult: () => isSubscriptionResult,
  isTopic: () => isTopic2,
  isTopicInBloom: () => isTopicInBloom2,
  isUserEthereumAddressInBloom: () => isUserEthereumAddressInBloom2,
  isValidResponse: () => isValidResponse,
  jsonRpc: () => json_rpc_exports,
  keccak256: () => keccak256Wrapper,
  keccak256Wrapper: () => keccak256Wrapper,
  leftPad: () => leftPad,
  mergeDeep: () => mergeDeep,
  numberToHex: () => numberToHex2,
  padLeft: () => padLeft2,
  padRight: () => padRight,
  pollTillDefined: () => pollTillDefined,
  pollTillDefinedAndReturnIntervalId: () => pollTillDefinedAndReturnIntervalId,
  processSolidityEncodePackedArgs: () => processSolidityEncodePackedArgs,
  randomBytes: () => randomBytes2,
  randomHex: () => randomHex,
  rejectIfConditionAtInterval: () => rejectIfConditionAtInterval,
  rejectIfTimeout: () => rejectIfTimeout,
  rightPad: () => rightPad,
  setRequestIdStart: () => setRequestIdStart,
  sha3: () => sha3,
  sha3Raw: () => sha3Raw,
  soliditySha3: () => soliditySha3,
  soliditySha3Raw: () => soliditySha3Raw,
  stringToHex: () => stringToHex,
  toAscii: () => toAscii,
  toBatchPayload: () => toBatchPayload,
  toBigInt: () => toBigInt,
  toBool: () => toBool,
  toChecksumAddress: () => toChecksumAddress,
  toDecimal: () => toDecimal,
  toHex: () => toHex,
  toNumber: () => toNumber,
  toPayload: () => toPayload,
  toTwosComplement: () => toTwosComplement,
  toUtf8: () => toUtf8,
  toWei: () => toWei,
  uint8ArrayConcat: () => uint8ArrayConcat,
  uint8ArrayEquals: () => uint8ArrayEquals,
  utf8ToBytes: () => utf8ToBytes2,
  utf8ToHex: () => utf8ToHex,
  uuidV4: () => uuidV4,
  validateResponse: () => validateResponse,
  waitWithTimeout: () => waitWithTimeout
});
init_shim();

// node_modules/web3/node_modules/web3-utils/lib/esm/converters.js
init_shim();

// node_modules/web3/node_modules/ethereum-cryptography/esm/keccak.js
init_shim();
init_sha3();

// node_modules/web3/node_modules/ethereum-cryptography/esm/utils.js
init_shim();
init_assert();
init_utils();
init_utils();
var assertBool = assert_default.bool;
var assertBytes = assert_default.bytes;
function bytesToUtf8(data) {
  if (!(data instanceof Uint8Array)) {
    throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
  }
  return new TextDecoder().decode(data);
}
function wrapHash(hash) {
  return (msg) => {
    assert_default.bytes(msg);
    return hash(msg);
  };
}
var crypto2 = (() => {
  const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
  return {
    node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
    web: webCrypto
  };
})();

// node_modules/web3/node_modules/ethereum-cryptography/esm/keccak.js
var keccak224 = wrapHash(keccak_224);
var keccak256 = (() => {
  const k = wrapHash(keccak_256);
  k.create = keccak_256.create;
  return k;
})();
var keccak384 = wrapHash(keccak_384);
var keccak512 = wrapHash(keccak_512);

// node_modules/web3-validator/lib/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  VALID_ETH_BASE_TYPES: () => VALID_ETH_BASE_TYPES,
  Web3Validator: () => Web3Validator,
  Web3ValidatorError: () => Web3ValidatorError,
  bigintPower: () => bigintPower,
  checkAddressCheckSum: () => checkAddressCheckSum,
  isAddress: () => isAddress,
  isBigInt: () => isBigInt,
  isBlockNumber: () => isBlockNumber,
  isBlockNumberOrTag: () => isBlockNumberOrTag,
  isBlockTag: () => isBlockTag,
  isBloom: () => isBloom,
  isBoolean: () => isBoolean,
  isBytes: () => isBytes,
  isContractAddressInBloom: () => isContractAddressInBloom,
  isFilterObject: () => isFilterObject,
  isHex: () => isHex,
  isHexPrefixed: () => isHexPrefixed,
  isHexStrict: () => isHexStrict,
  isHexString: () => isHexString,
  isHexString32Bytes: () => isHexString32Bytes,
  isHexString8Bytes: () => isHexString8Bytes,
  isInBloom: () => isInBloom,
  isInt: () => isInt,
  isNullish: () => isNullish,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isString: () => isString,
  isTopic: () => isTopic,
  isTopicInBloom: () => isTopicInBloom,
  isUInt: () => isUInt,
  isUint8Array: () => isUint8Array,
  isUserEthereumAddressInBloom: () => isUserEthereumAddressInBloom,
  isValidEthBaseType: () => isValidEthBaseType,
  utils: () => utils_exports,
  validateNoLeadingZeroes: () => validateNoLeadingZeroes,
  validator: () => validator
});
init_shim();

// node_modules/web3-validator/lib/esm/web3_validator.js
init_shim();

// node_modules/web3-validator/lib/esm/validator.js
init_shim();

// node_modules/web3-validator/lib/esm/errors.js
init_shim();
var errorFormatter = (error) => {
  if (error.message) {
    return error.message;
  }
  return "unspecified error";
};
var Web3ValidatorError = class extends BaseWeb3Error {
  constructor(errors) {
    super();
    this.code = ERR_VALIDATION;
    this.errors = errors;
    super.message = `Web3 validator found ${errors.length} error[s]:
${this._compileErrors().join("\n")}`;
  }
  _compileErrors() {
    return this.errors.map(errorFormatter);
  }
};

// node_modules/web3-validator/lib/esm/formats.js
init_shim();

// node_modules/web3-validator/lib/esm/validation/address.js
init_shim();

// node_modules/web3-validator/node_modules/ethereum-cryptography/esm/keccak.js
init_shim();
init_sha3();

// node_modules/web3-validator/node_modules/ethereum-cryptography/esm/utils.js
init_shim();
init_assert();
init_utils();
init_utils();
var assertBool2 = assert_default.bool;
var assertBytes2 = assert_default.bytes;
function wrapHash2(hash) {
  return (msg) => {
    assert_default.bytes(msg);
    return hash(msg);
  };
}
var crypto3 = (() => {
  const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
  return {
    node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
    web: webCrypto
  };
})();

// node_modules/web3-validator/node_modules/ethereum-cryptography/esm/keccak.js
var keccak2242 = wrapHash2(keccak_224);
var keccak2562 = (() => {
  const k = wrapHash2(keccak_256);
  k.create = keccak_256.create;
  return k;
})();
var keccak3842 = wrapHash2(keccak_384);
var keccak5122 = wrapHash2(keccak_512);

// node_modules/web3-validator/lib/esm/utils.js
var utils_exports = {};
__export(utils_exports, {
  abiSchemaToJsonSchema: () => abiSchemaToJsonSchema,
  codePointToInt: () => codePointToInt,
  ethAbiToJsonSchema: () => ethAbiToJsonSchema,
  fetchArrayElement: () => fetchArrayElement,
  hexToNumber: () => hexToNumber,
  hexToUint8Array: () => hexToUint8Array,
  numberToHex: () => numberToHex,
  padLeft: () => padLeft,
  parseBaseType: () => parseBaseType,
  transformJsonDataToAbiFormat: () => transformJsonDataToAbiFormat,
  uint8ArrayToHexString: () => uint8ArrayToHexString
});
init_shim();

// node_modules/web3-validator/lib/esm/constants.js
init_shim();
var VALID_ETH_BASE_TYPES = ["bool", "int", "uint", "bytes", "string", "address", "tuple"];

// node_modules/web3-validator/lib/esm/validation/abi.js
init_shim();
var isAbiParameterSchema = (schema) => typeof schema === "object" && "type" in schema && "name" in schema;

// node_modules/web3-validator/lib/esm/validation/string.js
init_shim();
var isString = (value) => typeof value === "string";
var isHexStrict = (hex) => typeof hex === "string" && /^((-)?0x[0-9a-f]+|(0x))$/i.test(hex);
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/))
    return false;
  if (typeof length !== "undefined" && length > 0 && value.length !== 2 + 2 * length)
    return false;
  return true;
}
var isHex = (hex) => typeof hex === "number" || typeof hex === "bigint" || typeof hex === "string" && /^((-0x|0x|-)?[0-9a-f]+|(0x))$/i.test(hex);
var isHexString8Bytes = (value, prefixed = true) => prefixed ? isHexStrict(value) && value.length === 18 : isHex(value) && value.length === 16;
var isHexString32Bytes = (value, prefixed = true) => prefixed ? isHexStrict(value) && value.length === 66 : isHex(value) && value.length === 64;
function isHexPrefixed(str) {
  if (typeof str !== "string") {
    throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);
  }
  return str.startsWith("0x");
}
var validateNoLeadingZeroes = function(values) {
  for (const [k, v] of Object.entries(values)) {
    if (v !== void 0 && v.length > 0 && v[0] === 0) {
      throw new Error(`${k} cannot have leading zeroes, received: ${v.toString()}`);
    }
  }
};

// node_modules/web3-validator/lib/esm/utils.js
var extraTypes = ["hex", "number", "blockNumber", "blockNumberOrTag", "filter", "bloom"];
var parseBaseType = (type) => {
  let strippedType = type.replace(/ /, "");
  let baseTypeSize;
  let isArray = false;
  let arraySizes = [];
  if (type.includes("[")) {
    strippedType = strippedType.slice(0, strippedType.indexOf("["));
    arraySizes = [...type.matchAll(/(?:\[(\d*)\])/g)].map((match) => parseInt(match[1], 10)).map((size) => Number.isNaN(size) ? -1 : size);
    isArray = arraySizes.length > 0;
  }
  if (VALID_ETH_BASE_TYPES.includes(strippedType)) {
    return { baseType: strippedType, isArray, baseTypeSize, arraySizes };
  }
  if (strippedType.startsWith("int")) {
    baseTypeSize = parseInt(strippedType.substring(3), 10);
    strippedType = "int";
  } else if (strippedType.startsWith("uint")) {
    baseTypeSize = parseInt(type.substring(4), 10);
    strippedType = "uint";
  } else if (strippedType.startsWith("bytes")) {
    baseTypeSize = parseInt(strippedType.substring(5), 10);
    strippedType = "bytes";
  } else {
    return { baseType: void 0, isArray: false, baseTypeSize: void 0, arraySizes };
  }
  return { baseType: strippedType, isArray, baseTypeSize, arraySizes };
};
var convertEthType = (type, parentSchema = {}) => {
  const typePropertyPresent = Object.keys(parentSchema).includes("type");
  if (typePropertyPresent) {
    throw new Web3ValidatorError([
      {
        keyword: "eth",
        message: 'Either "eth" or "type" can be presented in schema',
        params: { eth: type },
        instancePath: "",
        schemaPath: ""
      }
    ]);
  }
  const { baseType, baseTypeSize } = parseBaseType(type);
  if (!baseType && !extraTypes.includes(type)) {
    throw new Web3ValidatorError([
      {
        keyword: "eth",
        message: `Eth data type "${type}" is not valid`,
        params: { eth: type },
        instancePath: "",
        schemaPath: ""
      }
    ]);
  }
  if (baseType) {
    if (baseType === "tuple") {
      throw new Error('"tuple" type is not implemented directly.');
    }
    return { format: `${baseType}${baseTypeSize !== null && baseTypeSize !== void 0 ? baseTypeSize : ""}`, required: true };
  }
  if (type) {
    return { format: type, required: true };
  }
  return {};
};
var abiSchemaToJsonSchema = (abis, level = "/0") => {
  const schema = {
    type: "array",
    items: [],
    maxItems: abis.length,
    minItems: abis.length
  };
  for (const [index, abi] of abis.entries()) {
    let abiType;
    let abiName;
    let abiComponents = [];
    if (isAbiParameterSchema(abi)) {
      abiType = abi.type;
      abiName = abi.name;
      abiComponents = abi.components;
    } else if (typeof abi === "string") {
      abiType = abi;
      abiName = `${level}/${index}`;
    } else if (Array.isArray(abi)) {
      if (abi[0] && typeof abi[0] === "string" && abi[0].startsWith("tuple") && !Array.isArray(abi[0]) && abi[1] && Array.isArray(abi[1])) {
        abiType = abi[0];
        abiName = `${level}/${index}`;
        abiComponents = abi[1];
      } else {
        abiType = "tuple";
        abiName = `${level}/${index}`;
        abiComponents = abi;
      }
    }
    const { baseType, isArray, arraySizes } = parseBaseType(abiType);
    let childSchema;
    let lastSchema = schema;
    for (let i = arraySizes.length - 1; i > 0; i -= 1) {
      childSchema = {
        type: "array",
        items: [],
        maxItems: arraySizes[i],
        minItems: arraySizes[i]
      };
      if (arraySizes[i] < 0) {
        delete childSchema.maxItems;
        delete childSchema.minItems;
      }
      if (!Array.isArray(lastSchema.items)) {
        lastSchema.items = [lastSchema.items, childSchema];
      } else if (lastSchema.items.length === 0) {
        lastSchema.items = childSchema;
      } else {
        lastSchema.items.push(childSchema);
      }
      lastSchema = childSchema;
    }
    if (baseType === "tuple" && !isArray) {
      const nestedTuple = abiSchemaToJsonSchema(abiComponents, abiName);
      nestedTuple.$id = abiName;
      lastSchema.items.push(nestedTuple);
    } else if (baseType === "tuple" && isArray) {
      const arraySize = arraySizes[0];
      const item = {
        $id: abiName,
        type: "array",
        items: abiSchemaToJsonSchema(abiComponents, abiName),
        maxItems: arraySize,
        minItems: arraySize
      };
      if (arraySize < 0) {
        delete item.maxItems;
        delete item.minItems;
      }
      lastSchema.items.push(item);
    } else if (isArray) {
      const arraySize = arraySizes[0];
      const item = {
        type: "array",
        $id: abiName,
        items: convertEthType(String(baseType)),
        minItems: arraySize,
        maxItems: arraySize
      };
      if (arraySize < 0) {
        delete item.maxItems;
        delete item.minItems;
      }
      lastSchema.items.push(item);
    } else if (Array.isArray(lastSchema.items)) {
      lastSchema.items.push(Object.assign({ $id: abiName }, convertEthType(abiType)));
    } else {
      lastSchema.items.items.push(Object.assign({ $id: abiName }, convertEthType(abiType)));
    }
    lastSchema = schema;
  }
  return schema;
};
var ethAbiToJsonSchema = (abis) => abiSchemaToJsonSchema(abis);
var fetchArrayElement = (data, level) => {
  if (level === 1) {
    return data;
  }
  return fetchArrayElement(data[0], level - 1);
};
var transformJsonDataToAbiFormat = (abis, data, transformedData) => {
  const newData = [];
  for (const [index, abi] of abis.entries()) {
    let abiType;
    let abiName;
    let abiComponents = [];
    if (isAbiParameterSchema(abi)) {
      abiType = abi.type;
      abiName = abi.name;
      abiComponents = abi.components;
    } else if (typeof abi === "string") {
      abiType = abi;
    } else if (Array.isArray(abi)) {
      if (abi[1] && Array.isArray(abi[1])) {
        abiType = abi[0];
        abiComponents = abi[1];
      } else {
        abiType = "tuple";
        abiComponents = abi;
      }
    }
    const { baseType, isArray, arraySizes } = parseBaseType(abiType);
    const dataItem = Array.isArray(data) ? data[index] : data[abiName];
    if (baseType === "tuple" && !isArray) {
      newData.push(transformJsonDataToAbiFormat(abiComponents, dataItem, transformedData));
    } else if (baseType === "tuple" && isArray) {
      const tupleData = [];
      for (const tupleItem of dataItem) {
        if (arraySizes.length > 1) {
          const nestedItems = fetchArrayElement(tupleItem, arraySizes.length - 1);
          const nestedData = [];
          for (const nestedItem of nestedItems) {
            nestedData.push(transformJsonDataToAbiFormat(abiComponents, nestedItem, transformedData));
          }
          tupleData.push(nestedData);
        } else {
          tupleData.push(transformJsonDataToAbiFormat(abiComponents, tupleItem, transformedData));
        }
      }
      newData.push(tupleData);
    } else {
      newData.push(dataItem);
    }
  }
  transformedData = transformedData !== null && transformedData !== void 0 ? transformedData : [];
  transformedData.push(...newData);
  return transformedData;
};
var codePointToInt = (codePoint) => {
  if (codePoint >= 48 && codePoint <= 57) {
    return codePoint - 48;
  }
  if (codePoint >= 65 && codePoint <= 70) {
    return codePoint - 55;
  }
  if (codePoint >= 97 && codePoint <= 102) {
    return codePoint - 87;
  }
  throw new Error(`Invalid code point: ${codePoint}`);
};
var hexToNumber = (value) => {
  if (!isHexStrict(value)) {
    throw new Error("Invalid hex string");
  }
  const [negative, hexValue] = value.startsWith("-") ? [true, value.slice(1)] : [false, value];
  const num = BigInt(hexValue);
  if (num > Number.MAX_SAFE_INTEGER) {
    return negative ? -num : num;
  }
  if (num < Number.MIN_SAFE_INTEGER) {
    return num;
  }
  return negative ? -1 * Number(num) : Number(num);
};
var numberToHex = (value) => {
  if ((typeof value === "number" || typeof value === "bigint") && value < 0) {
    return `-0x${value.toString(16).slice(1)}`;
  }
  if ((typeof value === "number" || typeof value === "bigint") && value >= 0) {
    return `0x${value.toString(16)}`;
  }
  if (typeof value === "string" && isHexStrict(value)) {
    const [negative, hex] = value.startsWith("-") ? [true, value.slice(1)] : [false, value];
    const hexValue = hex.split(/^(-)?0(x|X)/).slice(-1)[0];
    return `${negative ? "-" : ""}0x${hexValue.replace(/^0+/, "").toLowerCase()}`;
  }
  if (typeof value === "string" && !isHexStrict(value)) {
    return numberToHex(BigInt(value));
  }
  throw new InvalidNumberError(value);
};
var padLeft = (value, characterAmount, sign6 = "0") => {
  if (typeof value === "string" && !isHexStrict(value)) {
    return value.padStart(characterAmount, sign6);
  }
  const hex = typeof value === "string" && isHexStrict(value) ? value : numberToHex(value);
  const [prefix, hexValue] = hex.startsWith("-") ? ["-0x", hex.slice(3)] : ["0x", hex.slice(2)];
  return `${prefix}${hexValue.padStart(characterAmount, sign6)}`;
};
function uint8ArrayToHexString(uint8Array) {
  let hexString = "0x";
  for (const e of uint8Array) {
    const hex = e.toString(16);
    hexString += hex.length === 1 ? `0${hex}` : hex;
  }
  return hexString;
}
function hexToUint8Array(hex) {
  let value;
  if (hex.toLowerCase().startsWith("0x")) {
    value = hex.slice(2);
  } else {
    value = hex;
  }
  if (value.length % 2 !== 0) {
    throw new InvalidBytesError(`hex string has odd length: ${hex}`);
  }
  const bytes = new Uint8Array(Math.ceil(value.length / 2));
  for (let i = 0; i < bytes.length; i += 1) {
    const byte = parseInt(value.substring(i * 2, i * 2 + 2), 16);
    bytes[i] = byte;
  }
  return bytes;
}

// node_modules/web3-validator/lib/esm/validation/address.js
var checkAddressCheckSum = (data) => {
  if (!/^(0x)?[0-9a-f]{40}$/i.test(data))
    return false;
  const address = data.slice(2);
  const updatedData = utf8ToBytes(address.toLowerCase());
  const addressHash = uint8ArrayToHexString(keccak2562(updatedData)).slice(2);
  for (let i = 0; i < 40; i += 1) {
    if (parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i] || parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i]) {
      return false;
    }
  }
  return true;
};
var isAddress = (value, checkChecksum = true) => {
  if (typeof value !== "string" && !(value instanceof Uint8Array)) {
    return false;
  }
  let valueToCheck;
  if (value instanceof Uint8Array) {
    valueToCheck = uint8ArrayToHexString(value);
  } else if (typeof value === "string" && !isHexStrict(value)) {
    valueToCheck = value.toLowerCase().startsWith("0x") ? value : `0x${value}`;
  } else {
    valueToCheck = value;
  }
  if (!/^(0x)?[0-9a-f]{40}$/i.test(valueToCheck)) {
    return false;
  }
  if (/^(0x|0X)?[0-9a-f]{40}$/.test(valueToCheck) || /^(0x|0X)?[0-9A-F]{40}$/.test(valueToCheck)) {
    return true;
  }
  return checkChecksum ? checkAddressCheckSum(valueToCheck) : true;
};

// node_modules/web3-validator/lib/esm/validation/block.js
init_shim();

// node_modules/web3-types/lib/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  BlockTags: () => BlockTags,
  DEFAULT_RETURN_FORMAT: () => DEFAULT_RETURN_FORMAT,
  ETH_DATA_FORMAT: () => ETH_DATA_FORMAT,
  FMT_BYTES: () => FMT_BYTES,
  FMT_NUMBER: () => FMT_NUMBER,
  HardforksOrdered: () => HardforksOrdered,
  TypedArray: () => TypedArray,
  Web3BaseProvider: () => Web3BaseProvider,
  Web3BaseWallet: () => Web3BaseWallet
});
init_shim();

// node_modules/web3-types/lib/esm/error_types.js
init_shim();

// node_modules/web3-types/lib/esm/apis/eth_execution_api.js
init_shim();

// node_modules/web3-types/lib/esm/apis/web3_eth_execution_api.js
init_shim();

// node_modules/web3-types/lib/esm/apis/web3_net_api.js
init_shim();

// node_modules/web3-types/lib/esm/apis/eth_personal_api.js
init_shim();

// node_modules/web3-types/lib/esm/data_format_types.js
init_shim();
var FMT_NUMBER;
(function(FMT_NUMBER2) {
  FMT_NUMBER2["NUMBER"] = "NUMBER_NUMBER";
  FMT_NUMBER2["HEX"] = "NUMBER_HEX";
  FMT_NUMBER2["STR"] = "NUMBER_STR";
  FMT_NUMBER2["BIGINT"] = "NUMBER_BIGINT";
})(FMT_NUMBER || (FMT_NUMBER = {}));
var FMT_BYTES;
(function(FMT_BYTES2) {
  FMT_BYTES2["HEX"] = "BYTES_HEX";
  FMT_BYTES2["UINT8ARRAY"] = "BYTES_UINT8ARRAY";
})(FMT_BYTES || (FMT_BYTES = {}));
var DEFAULT_RETURN_FORMAT = { number: FMT_NUMBER.BIGINT, bytes: FMT_BYTES.HEX };
var ETH_DATA_FORMAT = { number: FMT_NUMBER.HEX, bytes: FMT_BYTES.HEX };

// node_modules/web3-types/lib/esm/eth_types.js
init_shim();
var BlockTags;
(function(BlockTags2) {
  BlockTags2["EARLIEST"] = "earliest";
  BlockTags2["LATEST"] = "latest";
  BlockTags2["PENDING"] = "pending";
  BlockTags2["SAFE"] = "safe";
  BlockTags2["FINALIZED"] = "finalized";
})(BlockTags || (BlockTags = {}));
var HardforksOrdered;
(function(HardforksOrdered2) {
  HardforksOrdered2["chainstart"] = "chainstart";
  HardforksOrdered2["frontier"] = "frontier";
  HardforksOrdered2["homestead"] = "homestead";
  HardforksOrdered2["dao"] = "dao";
  HardforksOrdered2["tangerineWhistle"] = "tangerineWhistle";
  HardforksOrdered2["spuriousDragon"] = "spuriousDragon";
  HardforksOrdered2["byzantium"] = "byzantium";
  HardforksOrdered2["constantinople"] = "constantinople";
  HardforksOrdered2["petersburg"] = "petersburg";
  HardforksOrdered2["istanbul"] = "istanbul";
  HardforksOrdered2["muirGlacier"] = "muirGlacier";
  HardforksOrdered2["berlin"] = "berlin";
  HardforksOrdered2["london"] = "london";
  HardforksOrdered2["altair"] = "altair";
  HardforksOrdered2["arrowGlacier"] = "arrowGlacier";
  HardforksOrdered2["grayGlacier"] = "grayGlacier";
  HardforksOrdered2["bellatrix"] = "bellatrix";
  HardforksOrdered2["merge"] = "merge";
  HardforksOrdered2["capella"] = "capella";
  HardforksOrdered2["shanghai"] = "shanghai";
})(HardforksOrdered || (HardforksOrdered = {}));

// node_modules/web3-types/lib/esm/eth_abi_types.js
init_shim();

// node_modules/web3-types/lib/esm/eth_contract_types.js
init_shim();

// node_modules/web3-types/lib/esm/json_rpc_types.js
init_shim();

// node_modules/web3-types/lib/esm/primitives_types.js
init_shim();
var TypedArray = Object.getPrototypeOf(Uint8Array);

// node_modules/web3-types/lib/esm/utility_types.js
init_shim();

// node_modules/web3-types/lib/esm/web3_api_types.js
init_shim();

// node_modules/web3-types/lib/esm/web3_base_provider.js
init_shim();
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var symbol = Symbol.for("web3/base-provider");
var Web3BaseProvider = class {
  static isWeb3Provider(provider) {
    return provider instanceof Web3BaseProvider || Boolean(provider && provider[symbol]);
  }
  get [symbol]() {
    return true;
  }
  send(payload, callback) {
    this.request(payload).then((response) => {
      callback(null, response);
    }).catch((err) => {
      callback(err);
    });
  }
  sendAsync(payload) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.request(payload);
    });
  }
  asEIP1193Provider() {
    const newObj = Object.create(this);
    const originalRequest = newObj.request;
    newObj.request = function request(args) {
      return __awaiter(this, void 0, void 0, function* () {
        const response = yield originalRequest(args);
        return response.result;
      });
    };
    newObj.asEIP1193Provider = void 0;
    return newObj;
  }
};

// node_modules/web3-types/lib/esm/web3_base_wallet.js
init_shim();
var Web3BaseWallet = class extends Array {
  constructor(accountProvider) {
    super();
    this._accountProvider = accountProvider;
  }
};

// node_modules/web3-types/lib/esm/web3_deferred_promise_type.js
init_shim();

// node_modules/web3-validator/lib/esm/validation/numbers.js
init_shim();
var isBigInt = (value) => typeof value === "bigint";
var bigintPower = (base2, expo) => {
  let res = base2;
  for (let index = 1; index < expo; index += 1) {
    res *= base2;
  }
  return res;
};
var isUInt = (value, options = {
  abiType: "uint"
}) => {
  if (!["number", "string", "bigint"].includes(typeof value) || typeof value === "string" && value.length === 0) {
    return false;
  }
  let size;
  if (options === null || options === void 0 ? void 0 : options.abiType) {
    const { baseTypeSize } = parseBaseType(options.abiType);
    if (baseTypeSize) {
      size = baseTypeSize;
    }
  } else if (options.bitSize) {
    size = options.bitSize;
  }
  const maxSize = bigintPower(BigInt(2), BigInt(size !== null && size !== void 0 ? size : 256)) - BigInt(1);
  try {
    const valueToCheck = typeof value === "string" && isHexStrict(value) ? BigInt(hexToNumber(value)) : BigInt(value);
    return valueToCheck >= 0 && valueToCheck <= maxSize;
  } catch (error) {
    return false;
  }
};
var isInt = (value, options = {
  abiType: "int"
}) => {
  if (!["number", "string", "bigint"].includes(typeof value)) {
    return false;
  }
  if (typeof value === "number" && value > Number.MAX_SAFE_INTEGER) {
    return false;
  }
  let size;
  if (options === null || options === void 0 ? void 0 : options.abiType) {
    const { baseTypeSize, baseType } = parseBaseType(options.abiType);
    if (baseType !== "int") {
      return false;
    }
    if (baseTypeSize) {
      size = baseTypeSize;
    }
  } else if (options.bitSize) {
    size = options.bitSize;
  }
  const maxSize = bigintPower(BigInt(2), BigInt((size !== null && size !== void 0 ? size : 256) - 1));
  const minSize = BigInt(-1) * bigintPower(BigInt(2), BigInt((size !== null && size !== void 0 ? size : 256) - 1));
  try {
    const valueToCheck = typeof value === "string" && isHexStrict(value) ? BigInt(hexToNumber(value)) : BigInt(value);
    return valueToCheck >= minSize && valueToCheck <= maxSize;
  } catch (error) {
    return false;
  }
};
var isNumber = (value) => {
  if (isInt(value)) {
    return true;
  }
  if (typeof value === "string" && /[0-9.]/.test(value) && value.indexOf(".") === value.lastIndexOf(".")) {
    return true;
  }
  if (typeof value === "number") {
    return true;
  }
  return false;
};

// node_modules/web3-validator/lib/esm/validation/block.js
var isBlockNumber = (value) => isUInt(value);
var isBlockTag = (value) => Object.values(BlockTags).includes(value);
var isBlockNumberOrTag = (value) => isBlockTag(value) || isBlockNumber(value);

// node_modules/web3-validator/lib/esm/validation/bloom.js
init_shim();
var isBloom = (bloom) => {
  if (typeof bloom !== "string") {
    return false;
  }
  if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {
    return false;
  }
  if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {
    return true;
  }
  return false;
};
var isInBloom = (bloom, value) => {
  if (typeof value === "string" && !isHexStrict(value)) {
    return false;
  }
  if (!isBloom(bloom)) {
    return false;
  }
  const uint8Array = typeof value === "string" ? hexToUint8Array(value) : value;
  const hash = uint8ArrayToHexString(keccak2562(uint8Array)).slice(2);
  for (let i = 0; i < 12; i += 4) {
    const bitpos = (parseInt(hash.slice(i, i + 2), 16) << 8) + parseInt(hash.slice(i + 2, i + 4), 16) & 2047;
    const code = codePointToInt(bloom.charCodeAt(bloom.length - 1 - Math.floor(bitpos / 4)));
    const offset = 1 << bitpos % 4;
    if ((code & offset) !== offset) {
      return false;
    }
  }
  return true;
};
var isUserEthereumAddressInBloom = (bloom, ethereumAddress) => {
  if (!isBloom(bloom)) {
    return false;
  }
  if (!isAddress(ethereumAddress)) {
    return false;
  }
  const address = padLeft(ethereumAddress, 64);
  return isInBloom(bloom, address);
};
var isContractAddressInBloom = (bloom, contractAddress) => {
  if (!isBloom(bloom)) {
    return false;
  }
  if (!isAddress(contractAddress)) {
    return false;
  }
  return isInBloom(bloom, contractAddress);
};

// node_modules/web3-validator/lib/esm/validation/boolean.js
init_shim();
var isBoolean = (value) => {
  if (!["number", "string", "boolean"].includes(typeof value)) {
    return false;
  }
  if (typeof value === "boolean") {
    return true;
  }
  if (typeof value === "string" && !isHexStrict(value)) {
    return value === "1" || value === "0";
  }
  if (typeof value === "string" && isHexStrict(value)) {
    return value === "0x1" || value === "0x0";
  }
  return value === 1 || value === 0;
};

// node_modules/web3-validator/lib/esm/validation/bytes.js
init_shim();
var isUint8Array = (data) => data instanceof Uint8Array;
var isBytes = (value, options = {
  abiType: "bytes"
}) => {
  if (typeof value !== "string" && !Array.isArray(value) && !(value instanceof Uint8Array)) {
    return false;
  }
  if (typeof value === "string" && isHexStrict(value) && value.startsWith("-")) {
    return false;
  }
  if (typeof value === "string" && !isHexStrict(value)) {
    return false;
  }
  let valueToCheck;
  if (typeof value === "string") {
    if (value.length % 2 !== 0) {
      return false;
    }
    valueToCheck = hexToUint8Array(value);
  } else if (Array.isArray(value)) {
    if (value.some((d) => d < 0 || d > 255 || !Number.isInteger(d))) {
      return false;
    }
    valueToCheck = new Uint8Array(value);
  } else {
    valueToCheck = value;
  }
  if (options === null || options === void 0 ? void 0 : options.abiType) {
    const { baseTypeSize } = parseBaseType(options.abiType);
    return baseTypeSize ? valueToCheck.length === baseTypeSize : true;
  }
  if (options === null || options === void 0 ? void 0 : options.size) {
    return valueToCheck.length === (options === null || options === void 0 ? void 0 : options.size);
  }
  return true;
};

// node_modules/web3-validator/lib/esm/validation/filter.js
init_shim();

// node_modules/web3-validator/lib/esm/validation/object.js
init_shim();
var isNullish = (item) => item === void 0 || item === null;
var isObject = (item) => typeof item === "object" && !isNullish(item) && !Array.isArray(item) && !(item instanceof TypedArray);

// node_modules/web3-validator/lib/esm/validation/topic.js
init_shim();
var isTopic = (topic) => {
  if (typeof topic !== "string") {
    return false;
  }
  if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {
    return false;
  }
  if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {
    return true;
  }
  return false;
};
var isTopicInBloom = (bloom, topic) => {
  if (!isBloom(bloom)) {
    return false;
  }
  if (!isTopic(topic)) {
    return false;
  }
  return isInBloom(bloom, topic);
};

// node_modules/web3-validator/lib/esm/validation/filter.js
var isFilterObject = (value) => {
  const expectedFilterProperties = [
    "fromBlock",
    "toBlock",
    "address",
    "topics",
    "blockHash"
  ];
  if (isNullish(value) || typeof value !== "object")
    return false;
  if (!Object.keys(value).every((property) => expectedFilterProperties.includes(property)))
    return false;
  if (!isNullish(value.fromBlock) && !isBlockNumberOrTag(value.fromBlock) || !isNullish(value.toBlock) && !isBlockNumberOrTag(value.toBlock))
    return false;
  if (!isNullish(value.address)) {
    if (Array.isArray(value.address)) {
      if (!value.address.every((address) => isAddress(address)))
        return false;
    } else if (!isAddress(value.address))
      return false;
  }
  if (!isNullish(value.topics)) {
    if (!value.topics.every((topic) => {
      if (isNullish(topic))
        return true;
      if (Array.isArray(topic)) {
        return topic.every((nestedTopic) => isTopic(nestedTopic));
      }
      if (isTopic(topic))
        return true;
      return false;
    }))
      return false;
  }
  return true;
};

// node_modules/web3-validator/lib/esm/formats.js
var formats = {
  address: (data) => isAddress(data),
  bloom: (data) => isBloom(data),
  blockNumber: (data) => isBlockNumber(data),
  blockTag: (data) => isBlockTag(data),
  blockNumberOrTag: (data) => isBlockNumberOrTag(data),
  bool: (data) => isBoolean(data),
  bytes: (data) => isBytes(data),
  filter: (data) => isFilterObject(data),
  hex: (data) => isHexStrict(data),
  uint: (data) => isUInt(data),
  int: (data) => isInt(data),
  number: (data) => isNumber(data),
  string: (data) => isString(data)
};
for (let bitSize = 8; bitSize <= 256; bitSize += 8) {
  formats[`int${bitSize}`] = (data) => isInt(data, { bitSize });
  formats[`uint${bitSize}`] = (data) => isUInt(data, { bitSize });
}
for (let size = 1; size <= 32; size += 1) {
  formats[`bytes${size}`] = (data) => isBytes(data, { size });
}
formats.bytes256 = formats.bytes;
var formats_default = formats;

// node_modules/web3-validator/lib/esm/validator.js
var convertToZod = (schema) => {
  if ((!(schema === null || schema === void 0 ? void 0 : schema.type) || (schema === null || schema === void 0 ? void 0 : schema.type) === "object") && (schema === null || schema === void 0 ? void 0 : schema.properties)) {
    const obj = {};
    for (const name2 of Object.keys(schema.properties)) {
      const zItem = convertToZod(schema.properties[name2]);
      if (zItem) {
        obj[name2] = zItem;
      }
    }
    if (Array.isArray(schema.required)) {
      return z.object(obj).partial().required(schema.required.reduce((acc, v) => Object.assign(Object.assign({}, acc), { [v]: true }), {}));
    }
    return z.object(obj).partial();
  }
  if ((schema === null || schema === void 0 ? void 0 : schema.type) === "array" && (schema === null || schema === void 0 ? void 0 : schema.items)) {
    if (Array.isArray(schema.items) && schema.items.length > 0) {
      const arr = [];
      for (const item of schema.items) {
        const zItem = convertToZod(item);
        if (zItem) {
          arr.push(zItem);
        }
      }
      return z.tuple(arr);
    }
    return z.array(convertToZod(schema.items));
  }
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    return z.union(schema.oneOf.map((oneOfSchema) => convertToZod(oneOfSchema)));
  }
  if (schema === null || schema === void 0 ? void 0 : schema.format) {
    if (!formats_default[schema.format]) {
      throw new SchemaFormatError(schema.format);
    }
    return z.any().refine(formats_default[schema.format], (value) => ({
      params: { value, format: schema.format }
    }));
  }
  if ((schema === null || schema === void 0 ? void 0 : schema.type) && (schema === null || schema === void 0 ? void 0 : schema.type) !== "object" && typeof z[String(schema.type)] === "function") {
    return z[String(schema.type)]();
  }
  return z.object({ data: z.any() }).partial();
};
var Validator = class {
  static factory() {
    if (!Validator.validatorInstance) {
      Validator.validatorInstance = new Validator();
    }
    return Validator.validatorInstance;
  }
  validate(schema, data, options) {
    var _a16, _b;
    const zod = convertToZod(schema);
    const result = zod.safeParse(data);
    if (!result.success) {
      const errors = this.convertErrors((_b = (_a16 = result.error) === null || _a16 === void 0 ? void 0 : _a16.issues) !== null && _b !== void 0 ? _b : []);
      if (errors) {
        if (options === null || options === void 0 ? void 0 : options.silent) {
          return errors;
        }
        throw new Web3ValidatorError(errors);
      }
    }
    return void 0;
  }
  convertErrors(errors) {
    if (errors && Array.isArray(errors) && errors.length > 0) {
      return errors.map((error) => {
        var _a16;
        let message;
        let keyword;
        let params;
        let schemaPath;
        schemaPath = error.path.join("/");
        const field = String(error.path[error.path.length - 1]);
        const instancePath = error.path.join("/");
        if (error.code === ZodIssueCode.too_big) {
          keyword = "maxItems";
          schemaPath = `${instancePath}/maxItems`;
          params = { limit: error.maximum };
          message = `must NOT have more than ${error.maximum} items`;
        } else if (error.code === ZodIssueCode.too_small) {
          keyword = "minItems";
          schemaPath = `${instancePath}/minItems`;
          params = { limit: error.minimum };
          message = `must NOT have fewer than ${error.minimum} items`;
        } else if (error.code === ZodIssueCode.custom) {
          const { value, format: format5 } = (_a16 = error.params) !== null && _a16 !== void 0 ? _a16 : {};
          if (typeof value === "undefined") {
            message = `value at "/${schemaPath}" is required`;
          } else {
            message = `value "${typeof value === "object" ? JSON.stringify(value) : value}" at "/${schemaPath}" must pass "${format5}" validation`;
          }
          params = { value };
        }
        return {
          keyword: keyword !== null && keyword !== void 0 ? keyword : field,
          instancePath: instancePath ? `/${instancePath}` : "",
          schemaPath: schemaPath ? `#${schemaPath}` : "#",
          params: params !== null && params !== void 0 ? params : { value: error.message },
          message: message !== null && message !== void 0 ? message : error.message
        };
      });
    }
    return void 0;
  }
};

// node_modules/web3-validator/lib/esm/web3_validator.js
var Web3Validator = class {
  constructor() {
    this._validator = Validator.factory();
  }
  validateJSONSchema(schema, data, options) {
    return this._validator.validate(schema, data, options);
  }
  validate(schema, data, options = { silent: false }) {
    var _a16, _b;
    const jsonSchema = ethAbiToJsonSchema(schema);
    if (Array.isArray(jsonSchema.items) && ((_a16 = jsonSchema.items) === null || _a16 === void 0 ? void 0 : _a16.length) === 0 && data.length === 0) {
      return void 0;
    }
    if (Array.isArray(jsonSchema.items) && ((_b = jsonSchema.items) === null || _b === void 0 ? void 0 : _b.length) === 0 && data.length !== 0) {
      throw new Web3ValidatorError([
        {
          instancePath: "/0",
          schemaPath: "/",
          keyword: "required",
          message: "empty schema against data can not be validated",
          params: data
        }
      ]);
    }
    return this._validator.validate(jsonSchema, data, options);
  }
};

// node_modules/web3-validator/lib/esm/default_validator.js
init_shim();
var validator = new Web3Validator();

// node_modules/web3-validator/lib/esm/types.js
init_shim();

// node_modules/web3-validator/lib/esm/validation/index.js
init_shim();

// node_modules/web3-validator/lib/esm/validation/eth.js
init_shim();
var isValidEthBaseType = (type) => {
  const { baseType, baseTypeSize } = parseBaseType(type);
  if (!baseType) {
    return false;
  }
  if (baseType === type) {
    return true;
  }
  if ((baseType === "int" || baseType === "uint") && baseTypeSize) {
    if (!(baseTypeSize <= 256 && baseTypeSize % 8 === 0)) {
      return false;
    }
  }
  if (baseType === "bytes" && baseTypeSize) {
    if (!(baseTypeSize >= 1 && baseTypeSize <= 32)) {
      return false;
    }
  }
  return true;
};

// node_modules/web3/node_modules/web3-utils/lib/esm/converters.js
var ethUnitMap = {
  noether: BigInt(0),
  wei: BigInt(1),
  kwei: BigInt(1e3),
  Kwei: BigInt(1e3),
  babbage: BigInt(1e3),
  femtoether: BigInt(1e3),
  mwei: BigInt(1e6),
  Mwei: BigInt(1e6),
  lovelace: BigInt(1e6),
  picoether: BigInt(1e6),
  gwei: BigInt(1e9),
  Gwei: BigInt(1e9),
  shannon: BigInt(1e9),
  nanoether: BigInt(1e9),
  nano: BigInt(1e9),
  szabo: BigInt(1e12),
  microether: BigInt(1e12),
  micro: BigInt(1e12),
  finney: BigInt(1e15),
  milliether: BigInt(1e15),
  milli: BigInt(1e15),
  ether: BigInt("1000000000000000000"),
  kether: BigInt("1000000000000000000000"),
  grand: BigInt("1000000000000000000000"),
  mether: BigInt("1000000000000000000000000"),
  gether: BigInt("1000000000000000000000000000"),
  tether: BigInt("1000000000000000000000000000000")
};
var bytesToUint8Array = (data) => {
  validator.validate(["bytes"], [data]);
  if (data instanceof Uint8Array) {
    return data;
  }
  if (Array.isArray(data)) {
    return new Uint8Array(data);
  }
  if (typeof data === "string") {
    return utils_exports.hexToUint8Array(data);
  }
  throw new InvalidBytesError(data);
};
var { uint8ArrayToHexString: uint8ArrayToHexString2 } = utils_exports;
var bytesToHex2 = (bytes) => uint8ArrayToHexString2(bytesToUint8Array(bytes));
var hexToBytes2 = (bytes) => {
  if (typeof bytes === "string" && bytes.slice(0, 2).toLowerCase() !== "0x") {
    return bytesToUint8Array(`0x${bytes}`);
  }
  return bytesToUint8Array(bytes);
};
var hexToNumber2 = (value) => {
  validator.validate(["hex"], [value]);
  return utils_exports.hexToNumber(value);
};
var toDecimal = hexToNumber2;
var numberToHex2 = (value, hexstrict) => {
  if (typeof value !== "bigint")
    validator.validate(["int"], [value]);
  let updatedValue = utils_exports.numberToHex(value);
  if (hexstrict) {
    if (!updatedValue.startsWith("-") && updatedValue.length % 2 === 1) {
      updatedValue = "0x0".concat(updatedValue.slice(2));
    } else if (updatedValue.length % 2 === 0 && updatedValue.startsWith("-"))
      updatedValue = "-0x0".concat(updatedValue.slice(3));
  }
  return updatedValue;
};
var fromDecimal = numberToHex2;
var hexToNumberString = (data) => hexToNumber2(data).toString();
var utf8ToHex = (str) => {
  validator.validate(["string"], [str]);
  let strWithoutNullCharacter = str.replace(/^(?:\u0000)/, "");
  strWithoutNullCharacter = strWithoutNullCharacter.replace(/(?:\u0000)$/, "");
  return bytesToHex2(new TextEncoder().encode(strWithoutNullCharacter));
};
var fromUtf8 = utf8ToHex;
var stringToHex = utf8ToHex;
var hexToUtf8 = (str) => bytesToUtf8(hexToBytes2(str));
var toUtf8 = (input) => {
  if (typeof input === "string") {
    return hexToUtf8(input);
  }
  validator.validate(["bytes"], [input]);
  return bytesToUtf8(input);
};
var utf8ToBytes2 = utf8ToBytes;
var hexToString = hexToUtf8;
var asciiToHex = (str) => {
  validator.validate(["string"], [str]);
  let hexString = "";
  for (let i = 0; i < str.length; i += 1) {
    const hexCharCode = str.charCodeAt(i).toString(16);
    hexString += hexCharCode.length % 2 !== 0 ? `0${hexCharCode}` : hexCharCode;
  }
  return `0x${hexString}`;
};
var fromAscii = asciiToHex;
var hexToAscii = (str) => {
  const decoder = new TextDecoder("ascii");
  return decoder.decode(hexToBytes2(str));
};
var toAscii = hexToAscii;
var toHex = (value, returnType) => {
  if (typeof value === "string" && isAddress(value)) {
    return returnType ? "address" : `0x${value.toLowerCase().replace(/^0x/i, "")}`;
  }
  if (typeof value === "boolean") {
    return returnType ? "bool" : value ? "0x01" : "0x00";
  }
  if (typeof value === "number") {
    return returnType ? value < 0 ? "int256" : "uint256" : numberToHex2(value);
  }
  if (typeof value === "bigint") {
    return returnType ? "bigint" : numberToHex2(value);
  }
  if (typeof value === "object" && !!value) {
    return returnType ? "string" : utf8ToHex(JSON.stringify(value));
  }
  if (typeof value === "string") {
    if (value.startsWith("-0x") || value.startsWith("-0X")) {
      return returnType ? "int256" : numberToHex2(value);
    }
    if (isHexStrict(value)) {
      return returnType ? "bytes" : value;
    }
    if (isHex(value) && !isInt(value)) {
      return returnType ? "bytes" : `0x${value}`;
    }
    if (!Number.isFinite(value)) {
      return returnType ? "string" : utf8ToHex(value);
    }
  }
  throw new HexProcessingError(value);
};
var toNumber = (value) => {
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "bigint") {
    return value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER ? Number(value) : value;
  }
  if (typeof value === "string" && isHexStrict(value)) {
    return hexToNumber2(value);
  }
  try {
    return toNumber(BigInt(value));
  } catch (_a16) {
    throw new InvalidNumberError(value);
  }
};
var toBigInt = (value) => {
  if (typeof value === "number") {
    return BigInt(value);
  }
  if (typeof value === "bigint") {
    return value;
  }
  if (typeof value === "string" && isHex(value)) {
    if (value.startsWith("-")) {
      return -BigInt(value.substring(1));
    }
    return BigInt(value);
  }
  throw new InvalidNumberError(value);
};
var fromWei = (number, unit) => {
  const denomination = ethUnitMap[unit];
  if (!denomination) {
    throw new InvalidUnitError(unit);
  }
  const value = String(toNumber(number));
  const numberOfZerosInDenomination = denomination.toString().length - 1;
  if (numberOfZerosInDenomination <= 0) {
    return value.toString();
  }
  const zeroPaddedValue = value.padStart(numberOfZerosInDenomination, "0");
  const integer = zeroPaddedValue.slice(0, -numberOfZerosInDenomination);
  const fraction = zeroPaddedValue.slice(-numberOfZerosInDenomination).replace(/\.?0+$/, "");
  if (integer === "") {
    return `0.${fraction}`;
  }
  if (fraction === "") {
    return integer;
  }
  return `${integer}.${fraction}`;
};
var toWei = (number, unit) => {
  validator.validate(["number"], [number]);
  const denomination = ethUnitMap[unit];
  if (!denomination) {
    throw new InvalidUnitError(unit);
  }
  const [integer, fraction] = String(typeof number === "string" && !isHexStrict(number) ? number : toNumber(number)).split(".").concat("");
  const value = BigInt(`${integer}${fraction}`);
  const updatedValue = value * denomination;
  const numberOfZerosInDenomination = denomination.toString().length - 1;
  const decimals = Math.min(fraction.length, numberOfZerosInDenomination);
  if (decimals === 0) {
    return updatedValue.toString();
  }
  return updatedValue.toString().padStart(decimals, "0").slice(0, -decimals);
};
var toChecksumAddress = (address) => {
  if (!isAddress(address, false)) {
    throw new InvalidAddressError(address);
  }
  const lowerCaseAddress = address.toLowerCase().replace(/^0x/i, "");
  const hash = utils_exports.uint8ArrayToHexString(keccak256(utf8ToBytes2(lowerCaseAddress)));
  if (isNullish(hash) || hash === "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470")
    return "";
  let checksumAddress = "0x";
  const addressHash = hash.replace(/^0x/i, "");
  for (let i = 0; i < lowerCaseAddress.length; i += 1) {
    if (parseInt(addressHash[i], 16) > 7) {
      checksumAddress += lowerCaseAddress[i].toUpperCase();
    } else {
      checksumAddress += lowerCaseAddress[i];
    }
  }
  return checksumAddress;
};
var toBool = (value) => {
  if (typeof value === "boolean") {
    return value;
  }
  if (typeof value === "number" && (value === 0 || value === 1)) {
    return Boolean(value);
  }
  if (typeof value === "bigint" && (value === BigInt(0) || value === BigInt(1))) {
    return Boolean(value);
  }
  if (typeof value === "string" && !isHexStrict(value) && (value === "1" || value === "0" || value === "false" || value === "true")) {
    if (value === "true") {
      return true;
    }
    if (value === "false") {
      return false;
    }
    return Boolean(Number(value));
  }
  if (typeof value === "string" && isHexStrict(value) && (value === "0x1" || value === "0x0")) {
    return Boolean(toNumber(value));
  }
  throw new InvalidBooleanError(value);
};

// node_modules/web3/node_modules/web3-utils/lib/esm/event_emitter.js
init_shim();
var import_events = __toESM(require_events(), 1);
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var wrapFunction = (fn) => (params) => fn(params.detail);
var EventEmitterAtBrowser = class extends EventTarget {
  constructor() {
    super(...arguments);
    this._listeners = {};
    this.maxListeners = Number.MAX_SAFE_INTEGER;
  }
  on(eventName, fn) {
    this.addEventListener(eventName, fn);
    return this;
  }
  once(eventName, fn) {
    const onceCallback = (params) => __awaiter2(this, void 0, void 0, function* () {
      this.off(eventName, onceCallback);
      yield fn(params);
    });
    return this.on(eventName, onceCallback);
  }
  off(eventName, fn) {
    this.removeEventListener(eventName, fn);
    return this;
  }
  emit(eventName, params) {
    const event = new CustomEvent(eventName, { detail: params });
    return super.dispatchEvent(event);
  }
  listenerCount(eventName) {
    const eventListeners = this._listeners[eventName];
    return eventListeners ? eventListeners.length : 0;
  }
  listeners(eventName) {
    return this._listeners[eventName].map((value) => value[0]) || [];
  }
  eventNames() {
    return Object.keys(this._listeners);
  }
  removeAllListeners() {
    Object.keys(this._listeners).forEach((event) => {
      this._listeners[event].forEach((listener) => {
        super.removeEventListener(event, listener[1]);
      });
    });
    this._listeners = {};
    return this;
  }
  setMaxListeners(maxListeners) {
    this.maxListeners = maxListeners;
    return this;
  }
  getMaxListeners() {
    return this.maxListeners;
  }
  addEventListener(eventName, fn) {
    const wrappedFn = wrapFunction(fn);
    super.addEventListener(eventName, wrappedFn);
    if (!this._listeners[eventName]) {
      this._listeners[eventName] = [];
    }
    this._listeners[eventName].push([fn, wrappedFn]);
  }
  removeEventListener(eventName, fn) {
    const eventListeners = this._listeners[eventName];
    if (eventListeners) {
      const index = eventListeners.findIndex((item) => item[0] === fn);
      if (index !== -1) {
        super.removeEventListener(eventName, eventListeners[index][1]);
        eventListeners.splice(index, 1);
      }
    }
  }
};
var EventEmitterType;
if (typeof window === "undefined") {
  EventEmitterType = import_events.EventEmitter;
} else {
  EventEmitterType = EventEmitterAtBrowser;
}
var EventEmitter = class extends EventEmitterType {
};

// node_modules/web3/node_modules/web3-utils/lib/esm/validation.js
init_shim();
var isHexStrict2 = isHexStrict;
var isHex2 = isHex;
var checkAddressCheckSum2 = checkAddressCheckSum;
var isAddress2 = isAddress;
var isBloom2 = isBloom;
var isInBloom2 = isInBloom;
var isUserEthereumAddressInBloom2 = isUserEthereumAddressInBloom;
var isContractAddressInBloom2 = isContractAddressInBloom;
var isTopic2 = isTopic;
var isTopicInBloom2 = isTopicInBloom;
var compareBlockNumbers = (blockA, blockB) => {
  const isABlockTag = typeof blockA === "string" && isBlockTag(blockA);
  const isBBlockTag = typeof blockB === "string" && isBlockTag(blockB);
  if (blockA === blockB || (blockA === "earliest" || blockA === 0) && (blockB === "earliest" || blockB === 0)) {
    return 0;
  }
  if (blockA === "earliest" && blockB > 0) {
    return -1;
  }
  if (blockB === "earliest" && blockA > 0) {
    return 1;
  }
  if (isABlockTag && isBBlockTag) {
    const tagsOrder = {
      [BlockTags.EARLIEST]: 1,
      [BlockTags.FINALIZED]: 2,
      [BlockTags.SAFE]: 3,
      [BlockTags.LATEST]: 4,
      [BlockTags.PENDING]: 5
    };
    if (tagsOrder[blockA] < tagsOrder[blockB]) {
      return -1;
    }
    return 1;
  }
  if (isABlockTag && !isBBlockTag || !isABlockTag && isBBlockTag) {
    throw new InvalidBlockError("Cannot compare blocktag with provided non-blocktag input.");
  }
  const bigIntA = BigInt(blockA);
  const bigIntB = BigInt(blockB);
  if (bigIntA < bigIntB) {
    return -1;
  }
  if (bigIntA === bigIntB) {
    return 0;
  }
  return 1;
};
var isNullish2 = isNullish;

// node_modules/web3/node_modules/web3-utils/lib/esm/formatter.js
init_shim();

// node_modules/web3/node_modules/web3-utils/lib/esm/objects.js
init_shim();
var isIterable = (item) => typeof item === "object" && !isNullish(item) && !Array.isArray(item) && !(item instanceof TypedArray);
var mergeDeep = (destination, ...sources) => {
  const result = destination;
  if (!isIterable(result)) {
    return result;
  }
  for (const src of sources) {
    for (const key in src) {
      if (isIterable(src[key])) {
        if (!result[key]) {
          result[key] = {};
        }
        mergeDeep(result[key], src[key]);
      } else if (!isNullish(src[key]) && Object.hasOwnProperty.call(src, key)) {
        if (Array.isArray(src[key]) || src[key] instanceof TypedArray) {
          result[key] = src[key].slice(0);
        } else {
          result[key] = src[key];
        }
      }
    }
  }
  return result;
};

// node_modules/web3/node_modules/web3-utils/lib/esm/string_manipulation.js
init_shim();
var padLeft2 = (value, characterAmount, sign6 = "0") => {
  if (typeof value === "string") {
    if (!isHexStrict(value)) {
      return value.padStart(characterAmount, sign6);
    }
    return utils_exports.padLeft(value, characterAmount, sign6);
  }
  validator.validate(["int"], [value]);
  return utils_exports.padLeft(value, characterAmount, sign6);
};
var padRight = (value, characterAmount, sign6 = "0") => {
  if (typeof value === "string" && !isHexStrict(value)) {
    return value.padEnd(characterAmount, sign6);
  }
  validator.validate(["int"], [value]);
  const hexString = typeof value === "string" && isHexStrict(value) ? value : numberToHex2(value);
  const prefixLength = hexString.startsWith("-") ? 3 : 2;
  return hexString.padEnd(characterAmount + prefixLength, sign6);
};
var rightPad = padRight;
var leftPad = padLeft2;
var toTwosComplement = (value, nibbleWidth = 64) => {
  validator.validate(["int"], [value]);
  const val = toNumber(value);
  if (val >= 0)
    return padLeft2(toHex(val), nibbleWidth);
  const largestBit = bigintPower(BigInt(2), BigInt(nibbleWidth * 4));
  if (-val >= largestBit) {
    throw new NibbleWidthError(`value: ${value}, nibbleWidth: ${nibbleWidth}`);
  }
  const updatedVal = BigInt(val);
  const complement = updatedVal + largestBit;
  return padLeft2(numberToHex2(complement), nibbleWidth);
};
var fromTwosComplement = (value, nibbleWidth = 64) => {
  validator.validate(["int"], [value]);
  const val = toNumber(value);
  if (val < 0)
    return val;
  const largestBit = Math.ceil(Math.log(Number(val)) / Math.log(2));
  if (largestBit > nibbleWidth * 4)
    throw new NibbleWidthError(`value: "${value}", nibbleWidth: "${nibbleWidth}"`);
  if (nibbleWidth * 4 !== largestBit)
    return val;
  const complement = bigintPower(BigInt(2), BigInt(nibbleWidth) * BigInt(4));
  return toNumber(BigInt(val) - complement);
};

// node_modules/web3/node_modules/web3-utils/lib/esm/uint8array.js
init_shim();
function uint8ArrayConcat(...parts) {
  const length = parts.reduce((prev, part) => {
    const agg = prev + part.length;
    return agg;
  }, 0);
  const result = new Uint8Array(length);
  let offset = 0;
  for (const part of parts) {
    result.set(part, offset);
    offset += part.length;
  }
  return result;
}
function uint8ArrayEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i += 1) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/web3/node_modules/web3-utils/lib/esm/formatter.js
var { parseBaseType: parseBaseType2 } = utils_exports;
var isDataFormat = (dataFormat) => typeof dataFormat === "object" && !isNullish(dataFormat) && "number" in dataFormat && "bytes" in dataFormat;
var findSchemaByDataPath = (schema, dataPath, oneOfPath = []) => {
  let result = Object.assign({}, schema);
  let previousDataPath;
  for (const dataPart of dataPath) {
    if (result.oneOf && previousDataPath) {
      const path = oneOfPath.find(function(element) {
        return this === element[0];
      }, previousDataPath !== null && previousDataPath !== void 0 ? previousDataPath : "");
      if (path && path[0] === previousDataPath) {
        result = result.oneOf[path[1]];
      }
    }
    if (!result.properties && !result.items) {
      return void 0;
    }
    if (result.properties) {
      result = result.properties[dataPart];
    } else if (result.items && result.items.properties) {
      const node = result.items.properties;
      if (!node) {
        return void 0;
      }
      result = node[dataPart];
    } else if (result.items && isObject(result.items)) {
      result = result.items;
    } else if (result.items && Array.isArray(result.items)) {
      result = result.items[parseInt(dataPart, 10)];
    }
    if (result && dataPart)
      previousDataPath = dataPart;
  }
  return result;
};
var convertScalarValue = (value, ethType, format5) => {
  try {
    const { baseType, baseTypeSize } = parseBaseType2(ethType);
    if (baseType === "int" || baseType === "uint") {
      switch (format5.number) {
        case FMT_NUMBER.NUMBER:
          return Number(toBigInt(value));
        case FMT_NUMBER.HEX:
          return numberToHex2(toBigInt(value));
        case FMT_NUMBER.STR:
          return toBigInt(value).toString();
        case FMT_NUMBER.BIGINT:
          return toBigInt(value);
        default:
          throw new FormatterError(`Invalid format: ${String(format5.number)}`);
      }
    }
    if (baseType === "bytes") {
      let paddedValue;
      if (baseTypeSize) {
        if (typeof value === "string")
          paddedValue = padLeft2(value, baseTypeSize * 2);
        else if (value instanceof Uint8Array) {
          paddedValue = uint8ArrayConcat(new Uint8Array(baseTypeSize - value.length), value);
        }
      } else {
        paddedValue = value;
      }
      switch (format5.bytes) {
        case FMT_BYTES.HEX:
          return bytesToHex2(bytesToUint8Array(paddedValue));
        case FMT_BYTES.UINT8ARRAY:
          return bytesToUint8Array(paddedValue);
        default:
          throw new FormatterError(`Invalid format: ${String(format5.bytes)}`);
      }
    }
  } catch (error) {
    return value;
  }
  return value;
};
var convert = (data, schema, dataPath, format5, oneOfPath = []) => {
  var _a16, _b;
  if (!isObject(data) && !Array.isArray(data)) {
    return convertScalarValue(data, schema === null || schema === void 0 ? void 0 : schema.format, format5);
  }
  const object = data;
  for (const [key, value] of Object.entries(object)) {
    dataPath.push(key);
    const schemaProp = findSchemaByDataPath(schema, dataPath, oneOfPath);
    if (isNullish(schemaProp)) {
      delete object[key];
      dataPath.pop();
      continue;
    }
    if (isObject(value)) {
      convert(value, schema, dataPath, format5);
      dataPath.pop();
      continue;
    }
    if (Array.isArray(value)) {
      let _schemaProp = schemaProp;
      if ((schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.oneOf) !== void 0) {
        schemaProp.oneOf.forEach((oneOfSchemaProp, index) => {
          var _a17, _b2;
          if (!Array.isArray(schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.items) && (typeof value[0] === "object" && ((_a17 = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _a17 === void 0 ? void 0 : _a17.type) === "object" || typeof value[0] === "string" && ((_b2 = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _b2 === void 0 ? void 0 : _b2.type) !== "object")) {
            _schemaProp = oneOfSchemaProp;
            oneOfPath.push([key, index]);
          }
        });
      }
      if (isNullish(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {
        delete object[key];
        dataPath.pop();
        continue;
      }
      if (isObject(_schemaProp.items) && !isNullish(_schemaProp.items.format)) {
        for (let i = 0; i < value.length; i += 1) {
          object[key][i] = convertScalarValue(
            value[i],
            (_a16 = _schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) === null || _a16 === void 0 ? void 0 : _a16.format,
            format5
          );
        }
        dataPath.pop();
        continue;
      }
      if (!Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) && ((_b = _schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) === null || _b === void 0 ? void 0 : _b.type) === "object") {
        for (const arrObject of value) {
          convert(arrObject, schema, dataPath, format5, oneOfPath);
        }
        dataPath.pop();
        continue;
      }
      if (Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {
        for (let i = 0; i < value.length; i += 1) {
          object[key][i] = convertScalarValue(value[i], _schemaProp.items[i].format, format5);
        }
        dataPath.pop();
        continue;
      }
    }
    object[key] = convertScalarValue(value, schemaProp.format, format5);
    dataPath.pop();
  }
  return object;
};
var format = (schema, data, returnFormat) => {
  let dataToParse;
  if (isObject(data)) {
    dataToParse = mergeDeep({}, data);
  } else if (Array.isArray(data)) {
    dataToParse = [...data];
  } else {
    dataToParse = data;
  }
  const jsonSchema = isObject(schema) ? schema : utils_exports.ethAbiToJsonSchema(schema);
  if (!jsonSchema.properties && !jsonSchema.items && !jsonSchema.format) {
    throw new FormatterError("Invalid json schema for formatting");
  }
  return convert(dataToParse, jsonSchema, [], returnFormat);
};

// node_modules/web3/node_modules/web3-utils/lib/esm/hash.js
init_shim();
var SHA3_EMPTY_BYTES = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
var sha3 = (data) => {
  let updatedData;
  if (typeof data === "string") {
    if (data.startsWith("0x") && isHexStrict(data)) {
      updatedData = hexToBytes2(data);
    } else {
      updatedData = utf8ToBytes(data);
    }
  } else {
    updatedData = data;
  }
  const hash = bytesToHex2(keccak256(updatedData));
  return hash === SHA3_EMPTY_BYTES ? void 0 : hash;
};
var sha3Raw = (data) => {
  const hash = sha3(data);
  if (isNullish(hash)) {
    return SHA3_EMPTY_BYTES;
  }
  return hash;
};
var keccak256Wrapper = (data) => {
  let processedData;
  if (typeof data === "bigint" || typeof data === "number") {
    processedData = utf8ToBytes(data.toString());
  } else if (Array.isArray(data)) {
    processedData = new Uint8Array(data);
  } else if (typeof data === "string" && !isHexStrict(data)) {
    processedData = utf8ToBytes(data);
  } else {
    processedData = bytesToUint8Array(data);
  }
  return bytesToHex2(keccak256(processedData));
};
var getType = (arg) => {
  if (Array.isArray(arg)) {
    throw new Error("Autodetection of array types is not supported.");
  }
  let type;
  let value;
  if (typeof arg === "object" && ("t" in arg || "type" in arg) && ("v" in arg || "value" in arg)) {
    type = "t" in arg ? arg.t : arg.type;
    value = "v" in arg ? arg.v : arg.value;
    type = type.toLowerCase() === "bigint" ? "int" : type;
  } else if (typeof arg === "bigint") {
    return ["int", arg];
  } else {
    type = toHex(arg, true);
    value = toHex(arg);
    if (!type.startsWith("int") && !type.startsWith("uint")) {
      type = "bytes";
    }
  }
  if ((type.startsWith("int") || type.startsWith("uint")) && typeof value === "string" && !/^(-)?0x/i.test(value)) {
    value = toBigInt(value);
  }
  return [type, value];
};
var elementaryName = (name2) => {
  if (name2.startsWith("int[")) {
    return `int256${name2.slice(3)}`;
  }
  if (name2 === "int") {
    return "int256";
  }
  if (name2.startsWith("uint[")) {
    return `uint256'${name2.slice(4)}`;
  }
  if (name2 === "uint") {
    return "uint256";
  }
  return name2;
};
var parseTypeN = (value, typeLength) => {
  const typesize = /^(\d+).*$/.exec(value.slice(typeLength));
  return typesize ? parseInt(typesize[1], 10) : 0;
};
var bitLength = (value) => {
  const updatedVal = value.toString(2);
  return updatedVal.length;
};
var solidityPack = (type, val) => {
  const value = val.toString();
  if (type === "string") {
    if (typeof val === "string")
      return utf8ToHex(val);
    throw new InvalidStringError(val);
  }
  if (type === "bool" || type === "boolean") {
    if (typeof val === "boolean")
      return val ? "01" : "00";
    throw new InvalidBooleanError(val);
  }
  if (type === "address") {
    if (!isAddress(value)) {
      throw new InvalidAddressError(value);
    }
    return value;
  }
  const name2 = elementaryName(type);
  if (type.startsWith("uint")) {
    const size = parseTypeN(name2, "uint".length);
    if (size % 8 || size < 8 || size > 256) {
      throw new InvalidSizeError(value);
    }
    const num = toNumber(value);
    if (bitLength(num) > size) {
      throw new InvalidLargeValueError(value);
    }
    if (num < BigInt(0)) {
      throw new InvalidUnsignedIntegerError(value);
    }
    return size ? leftPad(num.toString(16), size / 8 * 2) : num.toString(16);
  }
  if (type.startsWith("int")) {
    const size = parseTypeN(name2, "int".length);
    if (size % 8 || size < 8 || size > 256) {
      throw new InvalidSizeError(type);
    }
    const num = toNumber(value);
    if (bitLength(num) > size) {
      throw new InvalidLargeValueError(value);
    }
    if (num < BigInt(0)) {
      return toTwosComplement(num.toString(), size / 8 * 2);
    }
    return size ? leftPad(num.toString(16), size / 4) : num.toString(16);
  }
  if (name2 === "bytes") {
    if (value.replace(/^0x/i, "").length % 2 !== 0) {
      throw new InvalidBytesError(value);
    }
    return value;
  }
  if (type.startsWith("bytes")) {
    if (value.replace(/^0x/i, "").length % 2 !== 0) {
      throw new InvalidBytesError(value);
    }
    const size = parseTypeN(type, "bytes".length);
    if (!size || size < 1 || size > 64 || size < value.replace(/^0x/i, "").length / 2) {
      throw new InvalidBytesError(value);
    }
    return rightPad(value, size * 2);
  }
  return "";
};
var processSolidityEncodePackedArgs = (arg) => {
  const [type, val] = getType(arg);
  if (Array.isArray(val)) {
    const hexArg2 = val.map((v) => solidityPack(type, v).replace("0x", ""));
    return hexArg2.join("");
  }
  const hexArg = solidityPack(type, val);
  return hexArg.replace("0x", "");
};
var encodePacked = (...values) => {
  const args = Array.prototype.slice.call(values);
  const hexArgs = args.map(processSolidityEncodePackedArgs);
  return `0x${hexArgs.join("").toLowerCase()}`;
};
var soliditySha3 = (...values) => sha3(encodePacked(...values));
var soliditySha3Raw = (...values) => sha3Raw(encodePacked(...values));
var getStorageSlotNumForLongString = (mainSlotNumber) => sha3(`0x${(typeof mainSlotNumber === "number" ? mainSlotNumber.toString() : mainSlotNumber).padStart(64, "0")}`);

// node_modules/web3/node_modules/web3-utils/lib/esm/random.js
init_shim();

// node_modules/web3/node_modules/ethereum-cryptography/esm/random.js
init_shim();
init_utils();
function getRandomBytesSync(bytes) {
  return randomBytes(bytes);
}

// node_modules/web3/node_modules/web3-utils/lib/esm/random.js
var randomBytes2 = (size) => getRandomBytesSync(size);
var randomHex = (byteSize) => bytesToHex2(randomBytes2(byteSize));

// node_modules/web3/node_modules/web3-utils/lib/esm/promise_helpers.js
init_shim();
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function isPromise(object) {
  return (typeof object === "object" || typeof object === "function") && typeof object.then === "function";
}
function waitWithTimeout(awaitable, timeout, error) {
  return __awaiter3(this, void 0, void 0, function* () {
    let timeoutId;
    const result = yield Promise.race([
      awaitable instanceof Promise ? awaitable : awaitable(),
      new Promise((resolve, reject) => {
        timeoutId = setTimeout(() => error ? reject(error) : resolve(void 0), timeout);
      })
    ]);
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    if (result instanceof Error) {
      throw result;
    }
    return result;
  });
}
function pollTillDefinedAndReturnIntervalId(func, interval) {
  let intervalId;
  const polledRes = new Promise((resolve, reject) => {
    intervalId = setInterval(
      function intervalCallbackFunc() {
        (() => __awaiter3(this, void 0, void 0, function* () {
          try {
            const res = yield waitWithTimeout(func, interval);
            if (!isNullish(res)) {
              clearInterval(intervalId);
              resolve(res);
            }
          } catch (error) {
            clearInterval(intervalId);
            reject(error);
          }
        }))();
        return intervalCallbackFunc;
      }(),
      interval
    );
  });
  return [polledRes, intervalId];
}
function pollTillDefined(func, interval) {
  return __awaiter3(this, void 0, void 0, function* () {
    return pollTillDefinedAndReturnIntervalId(func, interval)[0];
  });
}
function rejectIfTimeout(timeout, error) {
  let timeoutId;
  const rejectOnTimeout = new Promise((_, reject) => {
    timeoutId = setTimeout(() => {
      reject(error);
    }, timeout);
  });
  return [timeoutId, rejectOnTimeout];
}
function rejectIfConditionAtInterval(cond, interval) {
  let intervalId;
  const rejectIfCondition = new Promise((_, reject) => {
    intervalId = setInterval(() => {
      (() => __awaiter3(this, void 0, void 0, function* () {
        const error = yield cond();
        if (error) {
          clearInterval(intervalId);
          reject(error);
        }
      }))();
    }, interval);
  });
  return [intervalId, rejectIfCondition];
}

// node_modules/web3/node_modules/web3-utils/lib/esm/json_rpc.js
var json_rpc_exports = {};
__export(json_rpc_exports, {
  isBatchRequest: () => isBatchRequest,
  isBatchResponse: () => isBatchResponse,
  isResponseRpcError: () => isResponseRpcError,
  isResponseWithError: () => isResponseWithError2,
  isResponseWithNotification: () => isResponseWithNotification,
  isResponseWithResult: () => isResponseWithResult,
  isSubscriptionResult: () => isSubscriptionResult,
  isValidResponse: () => isValidResponse,
  setRequestIdStart: () => setRequestIdStart,
  toBatchPayload: () => toBatchPayload,
  toPayload: () => toPayload,
  validateResponse: () => validateResponse
});
init_shim();

// node_modules/web3/node_modules/web3-utils/lib/esm/uuid.js
init_shim();
var uuidV4 = () => {
  const bytes = randomBytes2(16);
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 63 | 128;
  const hexString = bytesToHex2(bytes);
  return [
    hexString.substring(2, 10),
    hexString.substring(10, 14),
    hexString.substring(14, 18),
    hexString.substring(18, 22),
    hexString.substring(22, 34)
  ].join("-");
};

// node_modules/web3/node_modules/web3-utils/lib/esm/json_rpc.js
var isResponseRpcError = (rpcError) => {
  const errorCode = rpcError.error.code;
  return rpcErrorsMap.has(errorCode) || errorCode >= -32099 && errorCode <= -32e3;
};
var isResponseWithResult = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && "result" in response && isNullish(response.error) && (typeof response.id === "number" || typeof response.id === "string");
var isResponseWithError2 = (response) => !Array.isArray(response) && response.jsonrpc === "2.0" && !!response && isNullish(response.result) && "error" in response && (typeof response.id === "number" || typeof response.id === "string");
var isResponseWithNotification = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && !isNullish(response.params) && !isNullish(response.method);
var isSubscriptionResult = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && "id" in response && "result" in response;
var validateResponse = (response) => isResponseWithResult(response) || isResponseWithError2(response);
var isValidResponse = (response) => Array.isArray(response) ? response.every(validateResponse) : validateResponse(response);
var isBatchResponse = (response) => Array.isArray(response) && response.length > 0 && isValidResponse(response);
var requestIdSeed;
var setRequestIdStart = (start) => {
  requestIdSeed = start;
};
var toPayload = (request) => {
  var _a16, _b, _c, _d;
  if (typeof requestIdSeed !== "undefined") {
    requestIdSeed += 1;
  }
  return {
    jsonrpc: (_a16 = request.jsonrpc) !== null && _a16 !== void 0 ? _a16 : "2.0",
    id: (_c = (_b = request.id) !== null && _b !== void 0 ? _b : requestIdSeed) !== null && _c !== void 0 ? _c : uuidV4(),
    method: request.method,
    params: (_d = request.params) !== null && _d !== void 0 ? _d : void 0
  };
};
var toBatchPayload = (requests) => requests.map((request) => toPayload(request));
var isBatchRequest = (request) => Array.isArray(request) && request.length > 0;

// node_modules/web3/node_modules/web3-utils/lib/esm/web3_deferred_promise.js
init_shim();
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a;
var Web3DeferredPromise = class {
  constructor({ timeout, eagerStart, timeoutMessage } = {
    timeout: 0,
    eagerStart: false,
    timeoutMessage: "DeferredPromise timed out"
  }) {
    this[_a] = "Promise";
    this._state = "pending";
    this._promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
    this._timeoutMessage = timeoutMessage;
    this._timeoutInterval = timeout;
    if (eagerStart) {
      this.startTimer();
    }
  }
  get state() {
    return this._state;
  }
  then(onfulfilled, onrejected) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this._promise.then(onfulfilled, onrejected);
    });
  }
  catch(onrejected) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this._promise.catch(onrejected);
    });
  }
  finally(onfinally) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this._promise.finally(onfinally);
    });
  }
  resolve(value) {
    this._resolve(value);
    this._state = "fulfilled";
    this._clearTimeout();
  }
  reject(reason) {
    this._reject(reason);
    this._state = "rejected";
    this._clearTimeout();
  }
  startTimer() {
    if (this._timeoutInterval && this._timeoutInterval > 0) {
      this._timeoutId = setTimeout(this._checkTimeout.bind(this), this._timeoutInterval);
    }
  }
  _checkTimeout() {
    if (this._state === "pending" && this._timeoutId) {
      this.reject(new OperationTimeoutError(this._timeoutMessage));
    }
  }
  _clearTimeout() {
    if (this._timeoutId) {
      clearTimeout(this._timeoutId);
    }
  }
};
_a = Symbol.toStringTag;

// node_modules/web3/node_modules/web3-utils/lib/esm/chunk_response_parser.js
init_shim();
var ChunkResponseParser = class {
  constructor(eventEmitter, autoReconnect) {
    this.eventEmitter = eventEmitter;
    this.autoReconnect = autoReconnect;
  }
  clearQueues() {
    if (typeof this._clearQueues === "function") {
      this._clearQueues();
    }
  }
  onError(clearQueues) {
    this._clearQueues = clearQueues;
  }
  parseResponse(data) {
    const returnValues = [];
    const dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
    dechunkedData.forEach((_chunkData) => {
      let chunkData = _chunkData;
      if (this.lastChunk) {
        chunkData = this.lastChunk + chunkData;
      }
      let result;
      try {
        result = JSON.parse(chunkData);
      } catch (e) {
        this.lastChunk = chunkData;
        if (this.lastChunkTimeout) {
          clearTimeout(this.lastChunkTimeout);
        }
        this.lastChunkTimeout = setTimeout(() => {
          if (this.autoReconnect)
            return;
          this.clearQueues();
          this.eventEmitter.emit("error", new InvalidResponseError({
            id: 1,
            jsonrpc: "2.0",
            error: { code: 2, message: "Chunk timeout" }
          }));
        }, 1e3 * 15);
        return;
      }
      clearTimeout(this.lastChunkTimeout);
      this.lastChunk = void 0;
      if (result)
        returnValues.push(result);
    });
    return returnValues;
  }
};

// node_modules/web3/node_modules/web3-utils/lib/esm/web3_eip1193_provider.js
init_shim();
var import_events2 = __toESM(require_events(), 1);
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Eip1193Provider = class extends Web3BaseProvider {
  constructor() {
    super(...arguments);
    this._eventEmitter = new import_events2.EventEmitter();
    this._chainId = "";
    this._accounts = [];
  }
  _getChainId() {
    var _a16;
    return __awaiter5(this, void 0, void 0, function* () {
      const data = yield this.request(toPayload({
        method: "eth_chainId",
        params: []
      }));
      return (_a16 = data === null || data === void 0 ? void 0 : data.result) !== null && _a16 !== void 0 ? _a16 : "";
    });
  }
  _getAccounts() {
    var _a16;
    return __awaiter5(this, void 0, void 0, function* () {
      const data = yield this.request(toPayload({
        method: "eth_accounts",
        params: []
      }));
      return (_a16 = data === null || data === void 0 ? void 0 : data.result) !== null && _a16 !== void 0 ? _a16 : [];
    });
  }
  _onConnect() {
    Promise.all([
      this._getChainId().then((chainId) => {
        if (chainId !== this._chainId) {
          this._chainId = chainId;
          this._eventEmitter.emit("chainChanged", this._chainId);
        }
      }).catch((err) => {
        console.error(err);
      }),
      this._getAccounts().then((accounts) => {
        if (!(this._accounts.length === accounts.length && accounts.every((v) => accounts.includes(v)))) {
          this._accounts = accounts;
          this._onAccountsChanged();
        }
      }).catch((err) => {
        console.error(err);
      })
    ]).then(() => this._eventEmitter.emit("connect", {
      chainId: this._chainId
    })).catch((err) => {
      console.error(err);
    });
  }
  _onDisconnect(code, data) {
    this._eventEmitter.emit("disconnect", new EIP1193ProviderRpcError(code, data));
  }
  _onAccountsChanged() {
    this._eventEmitter.emit("accountsChanged", this._accounts);
  }
};

// node_modules/web3/node_modules/web3-utils/lib/esm/socket_provider.js
init_shim();
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_RECONNECTION_OPTIONS = {
  autoReconnect: true,
  delay: 5e3,
  maxAttempts: 5
};
var NORMAL_CLOSE_CODE = 1e3;
var SocketProvider = class extends Eip1193Provider {
  constructor(socketPath, socketOptions, reconnectOptions) {
    super();
    this._connectionStatus = "connecting";
    this._onMessageHandler = this._onMessage.bind(this);
    this._onOpenHandler = this._onConnect.bind(this);
    this._onCloseHandler = this._onCloseEvent.bind(this);
    this._onErrorHandler = this._onError.bind(this);
    if (!this._validateProviderPath(socketPath))
      throw new InvalidClientError(socketPath);
    this._socketPath = socketPath;
    this._socketOptions = socketOptions;
    this._reconnectOptions = Object.assign(Object.assign({}, DEFAULT_RECONNECTION_OPTIONS), reconnectOptions !== null && reconnectOptions !== void 0 ? reconnectOptions : {});
    this._pendingRequestsQueue = /* @__PURE__ */ new Map();
    this._sentRequestsQueue = /* @__PURE__ */ new Map();
    this._init();
    this.connect();
    this.chunkResponseParser = new ChunkResponseParser(this._eventEmitter, this._reconnectOptions.autoReconnect);
    this.chunkResponseParser.onError(() => {
      this._clearQueues();
    });
    this.isReconnecting = false;
  }
  get SocketConnection() {
    return this._socketConnection;
  }
  _init() {
    this._reconnectAttempts = 0;
  }
  connect() {
    try {
      this._openSocketConnection();
      this._connectionStatus = "connecting";
      this._addSocketListeners();
    } catch (e) {
      if (!this.isReconnecting) {
        this._connectionStatus = "disconnected";
        if (e && e.message) {
          throw new ConnectionError(`Error while connecting to ${this._socketPath}. Reason: ${e.message}`);
        } else {
          throw new InvalidClientError(this._socketPath);
        }
      } else {
        setImmediate(() => {
          this._reconnect();
        });
      }
    }
  }
  _validateProviderPath(path) {
    return !!path;
  }
  supportsSubscriptions() {
    return true;
  }
  on(type, listener) {
    this._eventEmitter.on(type, listener);
  }
  once(type, listener) {
    this._eventEmitter.once(type, listener);
  }
  removeListener(type, listener) {
    this._eventEmitter.removeListener(type, listener);
  }
  _onDisconnect(code, data) {
    this._connectionStatus = "disconnected";
    super._onDisconnect(code, data);
  }
  disconnect(code, data) {
    const disconnectCode = code !== null && code !== void 0 ? code : NORMAL_CLOSE_CODE;
    this._removeSocketListeners();
    if (this.getStatus() !== "disconnected") {
      this._closeSocketConnection(disconnectCode, data);
    }
    this._onDisconnect(disconnectCode, data);
  }
  removeAllListeners(type) {
    this._eventEmitter.removeAllListeners(type);
  }
  _onError(event) {
    if (this.isReconnecting) {
      this._reconnect();
    } else {
      this._eventEmitter.emit("error", event);
    }
  }
  reset() {
    this._sentRequestsQueue.clear();
    this._pendingRequestsQueue.clear();
    this._init();
    this._removeSocketListeners();
    this._addSocketListeners();
  }
  _reconnect() {
    if (this.isReconnecting) {
      return;
    }
    this.isReconnecting = true;
    if (this._sentRequestsQueue.size > 0) {
      this._sentRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new PendingRequestsOnReconnectingError());
        this._sentRequestsQueue.delete(key);
      });
    }
    if (this._reconnectAttempts < this._reconnectOptions.maxAttempts) {
      this._reconnectAttempts += 1;
      setTimeout(() => {
        this._removeSocketListeners();
        this.connect();
        this.isReconnecting = false;
      }, this._reconnectOptions.delay);
    } else {
      this.isReconnecting = false;
      this._clearQueues();
      this._removeSocketListeners();
      this._eventEmitter.emit("error", new MaxAttemptsReachedOnReconnectingError(this._reconnectOptions.maxAttempts));
    }
  }
  request(request) {
    return __awaiter6(this, void 0, void 0, function* () {
      if (isNullish2(this._socketConnection)) {
        throw new Error("Connection is undefined");
      }
      if (this.getStatus() === "disconnected") {
        this.connect();
      }
      const requestId = isBatchRequest(request) ? request[0].id : request.id;
      if (!requestId) {
        throw new Web3WSProviderError("Request Id not defined");
      }
      if (this._sentRequestsQueue.has(requestId)) {
        throw new RequestAlreadySentError(requestId);
      }
      const deferredPromise = new Web3DeferredPromise();
      deferredPromise.catch((error) => {
        this._eventEmitter.emit("error", error);
      });
      const reqItem = {
        payload: request,
        deferredPromise
      };
      if (this.getStatus() === "connecting") {
        this._pendingRequestsQueue.set(requestId, reqItem);
        return reqItem.deferredPromise;
      }
      this._sentRequestsQueue.set(requestId, reqItem);
      try {
        this._sendToSocket(reqItem.payload);
      } catch (error) {
        this._sentRequestsQueue.delete(requestId);
        this._eventEmitter.emit("error", error);
      }
      return deferredPromise;
    });
  }
  _onConnect() {
    this._connectionStatus = "connected";
    this._reconnectAttempts = 0;
    super._onConnect();
    this._sendPendingRequests();
  }
  _sendPendingRequests() {
    for (const [id, value] of this._pendingRequestsQueue.entries()) {
      this._sendToSocket(value.payload);
      this._pendingRequestsQueue.delete(id);
      this._sentRequestsQueue.set(id, value);
    }
  }
  _onMessage(event) {
    const responses = this._parseResponses(event);
    if (isNullish2(responses) || responses.length === 0) {
      return;
    }
    for (const response of responses) {
      if (isResponseWithNotification(response) && response.method.endsWith("_subscription")) {
        this._eventEmitter.emit("message", response);
        return;
      }
      const requestId = isBatchResponse(response) ? response[0].id : response.id;
      const requestItem = this._sentRequestsQueue.get(requestId);
      if (!requestItem) {
        return;
      }
      if (isBatchResponse(response) || isResponseWithResult(response) || isResponseWithError2(response)) {
        this._eventEmitter.emit("message", response);
        requestItem.deferredPromise.resolve(response);
      }
      this._sentRequestsQueue.delete(requestId);
    }
  }
  _clearQueues(event) {
    if (this._pendingRequestsQueue.size > 0) {
      this._pendingRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new ConnectionNotOpenError(event));
        this._pendingRequestsQueue.delete(key);
      });
    }
    if (this._sentRequestsQueue.size > 0) {
      this._sentRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new ConnectionNotOpenError(event));
        this._sentRequestsQueue.delete(key);
      });
    }
    this._removeSocketListeners();
  }
};

// node_modules/web3/node_modules/web3-core/lib/esm/web3_event_emitter.js
init_shim();
var Web3EventEmitter = class {
  constructor() {
    this._emitter = new EventEmitter();
  }
  on(eventName, fn) {
    this._emitter.on(eventName, fn);
  }
  once(eventName, fn) {
    this._emitter.once(eventName, fn);
  }
  off(eventName, fn) {
    this._emitter.off(eventName, fn);
  }
  emit(eventName, params) {
    this._emitter.emit(eventName, params);
  }
  listenerCount(eventName) {
    return this._emitter.listenerCount(eventName);
  }
  listeners(eventName) {
    return this._emitter.listeners(eventName);
  }
  eventNames() {
    return this._emitter.eventNames();
  }
  removeAllListeners() {
    return this._emitter.removeAllListeners();
  }
  setMaxListenerWarningThreshold(maxListenersWarningThreshold) {
    this._emitter.setMaxListeners(maxListenersWarningThreshold);
  }
  getMaxListeners() {
    return this._emitter.getMaxListeners();
  }
};

// node_modules/web3/node_modules/web3-core/lib/esm/web3_config.js
var Web3ConfigEvent;
(function(Web3ConfigEvent7) {
  Web3ConfigEvent7["CONFIG_CHANGE"] = "CONFIG_CHANGE";
})(Web3ConfigEvent || (Web3ConfigEvent = {}));
var Web3Config = class extends Web3EventEmitter {
  constructor(options) {
    super();
    this.config = {
      handleRevert: false,
      defaultAccount: void 0,
      defaultBlock: "latest",
      transactionBlockTimeout: 50,
      transactionConfirmationBlocks: 24,
      transactionPollingInterval: 1e3,
      transactionPollingTimeout: 750 * 1e3,
      transactionReceiptPollingInterval: void 0,
      transactionSendTimeout: 750 * 1e3,
      transactionConfirmationPollingInterval: void 0,
      blockHeaderTimeout: 10,
      maxListenersWarningThreshold: 100,
      contractDataInputFill: "input",
      defaultNetworkId: void 0,
      defaultChain: "mainnet",
      defaultHardfork: "london",
      defaultCommon: void 0,
      defaultTransactionType: "0x2",
      defaultMaxPriorityFeePerGas: toHex(25e8),
      enableExperimentalFeatures: {
        useSubscriptionWhenCheckingBlockTimeout: false,
        useRpcCallSpecification: false
      },
      transactionBuilder: void 0,
      transactionTypeParser: void 0
    };
    this.setConfig(options !== null && options !== void 0 ? options : {});
  }
  setConfig(options) {
    Object.assign(this.config, options);
  }
  get handleRevert() {
    return this.config.handleRevert;
  }
  set handleRevert(val) {
    this._triggerConfigChange("handleRevert", val);
    this.config.handleRevert = val;
  }
  get contractDataInputFill() {
    return this.config.contractDataInputFill;
  }
  set contractDataInputFill(val) {
    this._triggerConfigChange("contractDataInputFill", val);
    this.config.contractDataInputFill = val;
  }
  get defaultAccount() {
    return this.config.defaultAccount;
  }
  set defaultAccount(val) {
    this._triggerConfigChange("defaultAccount", val);
    this.config.defaultAccount = val;
  }
  get defaultBlock() {
    return this.config.defaultBlock;
  }
  set defaultBlock(val) {
    this._triggerConfigChange("defaultBlock", val);
    this.config.defaultBlock = val;
  }
  get transactionSendTimeout() {
    return this.config.transactionSendTimeout;
  }
  set transactionSendTimeout(val) {
    this._triggerConfigChange("transactionSendTimeout", val);
    this.config.transactionSendTimeout = val;
  }
  get transactionBlockTimeout() {
    return this.config.transactionBlockTimeout;
  }
  set transactionBlockTimeout(val) {
    this._triggerConfigChange("transactionBlockTimeout", val);
    this.config.transactionBlockTimeout = val;
  }
  get transactionConfirmationBlocks() {
    return this.config.transactionConfirmationBlocks;
  }
  set transactionConfirmationBlocks(val) {
    this._triggerConfigChange("transactionConfirmationBlocks", val);
    this.config.transactionConfirmationBlocks = val;
  }
  get transactionPollingInterval() {
    return this.config.transactionPollingInterval;
  }
  set transactionPollingInterval(val) {
    this._triggerConfigChange("transactionPollingInterval", val);
    this.config.transactionPollingInterval = val;
    this.transactionReceiptPollingInterval = val;
    this.transactionConfirmationPollingInterval = val;
  }
  get transactionPollingTimeout() {
    return this.config.transactionPollingTimeout;
  }
  set transactionPollingTimeout(val) {
    this._triggerConfigChange("transactionPollingTimeout", val);
    this.config.transactionPollingTimeout = val;
  }
  get transactionReceiptPollingInterval() {
    return this.config.transactionReceiptPollingInterval;
  }
  set transactionReceiptPollingInterval(val) {
    this._triggerConfigChange("transactionReceiptPollingInterval", val);
    this.config.transactionReceiptPollingInterval = val;
  }
  get transactionConfirmationPollingInterval() {
    return this.config.transactionConfirmationPollingInterval;
  }
  set transactionConfirmationPollingInterval(val) {
    this._triggerConfigChange("transactionConfirmationPollingInterval", val);
    this.config.transactionConfirmationPollingInterval = val;
  }
  get blockHeaderTimeout() {
    return this.config.blockHeaderTimeout;
  }
  set blockHeaderTimeout(val) {
    this._triggerConfigChange("blockHeaderTimeout", val);
    this.config.blockHeaderTimeout = val;
  }
  get enableExperimentalFeatures() {
    return this.config.enableExperimentalFeatures;
  }
  set enableExperimentalFeatures(val) {
    this._triggerConfigChange("enableExperimentalFeatures", val);
    this.config.enableExperimentalFeatures = val;
  }
  get maxListenersWarningThreshold() {
    return this.config.maxListenersWarningThreshold;
  }
  set maxListenersWarningThreshold(val) {
    this._triggerConfigChange("maxListenersWarningThreshold", val);
    this.setMaxListenerWarningThreshold(val);
    this.config.maxListenersWarningThreshold = val;
  }
  get defaultNetworkId() {
    return this.config.defaultNetworkId;
  }
  set defaultNetworkId(val) {
    this._triggerConfigChange("defaultNetworkId", val);
    this.config.defaultNetworkId = val;
  }
  get defaultChain() {
    return this.config.defaultChain;
  }
  set defaultChain(val) {
    if (!isNullish2(this.config.defaultCommon) && !isNullish2(this.config.defaultCommon.baseChain) && val !== this.config.defaultCommon.baseChain)
      throw new ConfigChainMismatchError(this.config.defaultChain, val);
    this._triggerConfigChange("defaultChain", val);
    this.config.defaultChain = val;
  }
  get defaultHardfork() {
    return this.config.defaultHardfork;
  }
  set defaultHardfork(val) {
    if (!isNullish2(this.config.defaultCommon) && !isNullish2(this.config.defaultCommon.hardfork) && val !== this.config.defaultCommon.hardfork)
      throw new ConfigHardforkMismatchError(this.config.defaultCommon.hardfork, val);
    this._triggerConfigChange("defaultHardfork", val);
    this.config.defaultHardfork = val;
  }
  get defaultCommon() {
    return this.config.defaultCommon;
  }
  set defaultCommon(val) {
    if (!isNullish2(this.config.defaultHardfork) && !isNullish2(val) && !isNullish2(val.hardfork) && this.config.defaultHardfork !== val.hardfork)
      throw new ConfigHardforkMismatchError(this.config.defaultHardfork, val.hardfork);
    if (!isNullish2(this.config.defaultChain) && !isNullish2(val) && !isNullish2(val.baseChain) && this.config.defaultChain !== val.baseChain)
      throw new ConfigChainMismatchError(this.config.defaultChain, val.baseChain);
    this._triggerConfigChange("defaultCommon", val);
    this.config.defaultCommon = val;
  }
  get defaultTransactionType() {
    return this.config.defaultTransactionType;
  }
  set defaultTransactionType(val) {
    this._triggerConfigChange("defaultTransactionType", val);
    this.config.defaultTransactionType = val;
  }
  get defaultMaxPriorityFeePerGas() {
    return this.config.defaultMaxPriorityFeePerGas;
  }
  set defaultMaxPriorityFeePerGas(val) {
    this._triggerConfigChange("defaultMaxPriorityFeePerGas", val);
    this.config.defaultMaxPriorityFeePerGas = val;
  }
  get transactionBuilder() {
    return this.config.transactionBuilder;
  }
  set transactionBuilder(val) {
    this._triggerConfigChange("transactionBuilder", val);
    this.config.transactionBuilder = val;
  }
  get transactionTypeParser() {
    return this.config.transactionTypeParser;
  }
  set transactionTypeParser(val) {
    this._triggerConfigChange("transactionTypeParser", val);
    this.config.transactionTypeParser = val;
  }
  _triggerConfigChange(config, newValue) {
    this.emit(Web3ConfigEvent.CONFIG_CHANGE, {
      name: config,
      oldValue: this.config[config],
      newValue
    });
  }
};

// node_modules/web3/node_modules/web3-core/lib/esm/web3_request_manager.js
init_shim();

// node_modules/web3/node_modules/web3-providers-http/lib/esm/index.js
var esm_exports5 = {};
__export(esm_exports5, {
  HttpProvider: () => HttpProvider,
  default: () => HttpProvider
});
init_shim();
var import_cross_fetch = __toESM(require_browser_ponyfill());
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var HttpProvider = class extends Web3BaseProvider {
  constructor(clientUrl, httpProviderOptions) {
    super();
    if (!HttpProvider.validateClientUrl(clientUrl))
      throw new InvalidClientError(clientUrl);
    this.clientUrl = clientUrl;
    this.httpProviderOptions = httpProviderOptions;
  }
  static validateClientUrl(clientUrl) {
    return typeof clientUrl === "string" ? /^http(s)?:\/\//i.test(clientUrl) : false;
  }
  getStatus() {
    throw new MethodNotImplementedError();
  }
  supportsSubscriptions() {
    return false;
  }
  request(payload, requestOptions) {
    var _a16;
    return __awaiter7(this, void 0, void 0, function* () {
      const providerOptionsCombined = Object.assign(Object.assign({}, (_a16 = this.httpProviderOptions) === null || _a16 === void 0 ? void 0 : _a16.providerOptions), requestOptions);
      const response = yield (0, import_cross_fetch.default)(this.clientUrl, Object.assign(Object.assign({}, providerOptionsCombined), { method: "POST", headers: Object.assign(Object.assign({}, providerOptionsCombined.headers), { "Content-Type": "application/json" }), body: JSON.stringify(payload) }));
      if (!response.ok)
        throw new ResponseError(yield response.json());
      return yield response.json();
    });
  }
  on() {
    throw new MethodNotImplementedError();
  }
  removeListener() {
    throw new MethodNotImplementedError();
  }
  once() {
    throw new MethodNotImplementedError();
  }
  removeAllListeners() {
    throw new MethodNotImplementedError();
  }
  connect() {
    throw new MethodNotImplementedError();
  }
  disconnect() {
    throw new MethodNotImplementedError();
  }
  reset() {
    throw new MethodNotImplementedError();
  }
  reconnect() {
    throw new MethodNotImplementedError();
  }
};

// node_modules/web3/node_modules/web3-providers-ws/lib/esm/index.js
var esm_exports6 = {};
__export(esm_exports6, {
  WebSocketProvider: () => WebSocketProvider,
  default: () => WebSocketProvider
});
init_shim();

// node_modules/web3/node_modules/isomorphic-ws/browser.js
init_shim();
var ws = null;
if (typeof WebSocket !== "undefined") {
  ws = WebSocket;
} else if (typeof MozWebSocket !== "undefined") {
  ws = MozWebSocket;
} else if (typeof _global !== "undefined") {
  ws = _global.WebSocket || _global.MozWebSocket;
} else if (typeof window !== "undefined") {
  ws = window.WebSocket || window.MozWebSocket;
} else if (typeof self !== "undefined") {
  ws = self.WebSocket || self.MozWebSocket;
}
var browser_default = ws;

// node_modules/web3/node_modules/web3-providers-ws/lib/esm/index.js
var WebSocketProvider = class extends SocketProvider {
  constructor(socketPath, socketOptions, reconnectOptions) {
    super(socketPath, socketOptions, reconnectOptions);
  }
  _validateProviderPath(providerUrl) {
    return typeof providerUrl === "string" ? /^ws(s)?:\/\//i.test(providerUrl) : false;
  }
  getStatus() {
    if (this._socketConnection && !isNullish2(this._socketConnection)) {
      switch (this._socketConnection.readyState) {
        case this._socketConnection.CONNECTING: {
          return "connecting";
        }
        case this._socketConnection.OPEN: {
          return "connected";
        }
        default: {
          return "disconnected";
        }
      }
    }
    return "disconnected";
  }
  _openSocketConnection() {
    this._socketConnection = new browser_default(this._socketPath, void 0, this._socketOptions && Object.keys(this._socketOptions).length === 0 ? void 0 : this._socketOptions);
  }
  _closeSocketConnection(code, data) {
    var _a16;
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.close(code, data);
  }
  _sendToSocket(payload) {
    var _a16;
    if (this.getStatus() === "disconnected") {
      throw new ConnectionNotOpenError();
    }
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.send(JSON.stringify(payload));
  }
  _parseResponses(event) {
    return this.chunkResponseParser.parseResponse(event.data);
  }
  _addSocketListeners() {
    var _a16, _b, _c, _d;
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.addEventListener("open", this._onOpenHandler);
    (_b = this._socketConnection) === null || _b === void 0 ? void 0 : _b.addEventListener("message", this._onMessageHandler);
    (_c = this._socketConnection) === null || _c === void 0 ? void 0 : _c.addEventListener("close", (e) => this._onCloseHandler(e));
    (_d = this._socketConnection) === null || _d === void 0 ? void 0 : _d.addEventListener("error", this._onErrorHandler);
  }
  _removeSocketListeners() {
    var _a16, _b, _c;
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.removeEventListener("message", this._onMessageHandler);
    (_b = this._socketConnection) === null || _b === void 0 ? void 0 : _b.removeEventListener("open", this._onOpenHandler);
    (_c = this._socketConnection) === null || _c === void 0 ? void 0 : _c.removeEventListener("close", this._onCloseHandler);
  }
  _onCloseEvent(event) {
    var _a16;
    if (this._reconnectOptions.autoReconnect && (![1e3, 1001].includes(event.code) || !event.wasClean)) {
      this._reconnect();
      return;
    }
    this._clearQueues(event);
    this._removeSocketListeners();
    this._onDisconnect(event.code, event.reason);
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.removeEventListener("error", this._onErrorHandler);
  }
};

// node_modules/web3/node_modules/web3-core/lib/esm/utils.js
init_shim();
var isWeb3Provider = (provider) => Web3BaseProvider.isWeb3Provider(provider);
var isMetaMaskProvider = (provider) => typeof provider !== "string" && "request" in provider && provider.request.constructor.name === "AsyncFunction" && "isMetaMask" in provider && provider.isMetaMask;
var isLegacyRequestProvider = (provider) => typeof provider !== "string" && "request" in provider && provider.request.constructor.name === "Function";
var isEIP1193Provider = (provider) => typeof provider !== "string" && "request" in provider && provider.request.constructor.name === "AsyncFunction";
var isLegacySendProvider = (provider) => typeof provider !== "string" && "send" in provider;
var isLegacySendAsyncProvider = (provider) => typeof provider !== "string" && "sendAsync" in provider;
var isSupportedProvider = (provider) => provider && (isWeb3Provider(provider) || isEIP1193Provider(provider) || isLegacyRequestProvider(provider) || isLegacySendAsyncProvider(provider) || isLegacySendProvider(provider));
var isSupportSubscriptions = (provider) => {
  if (provider && "supportsSubscriptions" in provider) {
    return provider.supportsSubscriptions();
  }
  if (provider && typeof provider !== "string" && "on" in provider) {
    return true;
  }
  return false;
};

// node_modules/web3/node_modules/web3-core/lib/esm/web3_request_manager.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3RequestManagerEvent;
(function(Web3RequestManagerEvent7) {
  Web3RequestManagerEvent7["PROVIDER_CHANGED"] = "PROVIDER_CHANGED";
  Web3RequestManagerEvent7["BEFORE_PROVIDER_CHANGE"] = "BEFORE_PROVIDER_CHANGE";
})(Web3RequestManagerEvent || (Web3RequestManagerEvent = {}));
var availableProviders = {
  HttpProvider,
  WebsocketProvider: WebSocketProvider
};
var metamaskPayload = (payload) => {
  var _a16;
  if (Array.isArray(payload.params)) {
    const params = payload.params[0];
    if (params.input && !params.data) {
      return Object.assign(Object.assign({}, payload), { params: [Object.assign(Object.assign({}, params), { data: (_a16 = params.data) !== null && _a16 !== void 0 ? _a16 : params.input })] });
    }
  }
  return payload;
};
var Web3RequestManager = class extends Web3EventEmitter {
  constructor(provider, useRpcCallSpecification) {
    super();
    if (!isNullish2(provider)) {
      this.setProvider(provider);
    }
    this.useRpcCallSpecification = useRpcCallSpecification;
  }
  static get providers() {
    return availableProviders;
  }
  get provider() {
    return this._provider;
  }
  get providers() {
    return availableProviders;
  }
  setProvider(provider) {
    let newProvider;
    if (provider && typeof provider === "string" && this.providers) {
      if (/^http(s)?:\/\//i.test(provider)) {
        newProvider = new this.providers.HttpProvider(provider);
      } else if (/^ws(s)?:\/\//i.test(provider)) {
        newProvider = new this.providers.WebsocketProvider(provider);
      } else {
        throw new ProviderError(`Can't autodetect provider for "${provider}"`);
      }
    } else if (isNullish2(provider)) {
      newProvider = void 0;
    } else {
      newProvider = provider;
    }
    this.emit(Web3RequestManagerEvent.BEFORE_PROVIDER_CHANGE, this._provider);
    this._provider = newProvider;
    this.emit(Web3RequestManagerEvent.PROVIDER_CHANGED, this._provider);
    return true;
  }
  send(request) {
    return __awaiter8(this, void 0, void 0, function* () {
      const response = yield this._sendRequest(request);
      if (json_rpc_exports.isResponseWithResult(response)) {
        return response.result;
      }
      throw new ResponseError(response);
    });
  }
  sendBatch(request) {
    return __awaiter8(this, void 0, void 0, function* () {
      const response = yield this._sendRequest(request);
      return response;
    });
  }
  _sendRequest(request) {
    return __awaiter8(this, void 0, void 0, function* () {
      const { provider } = this;
      if (isNullish2(provider)) {
        throw new ProviderError("Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.");
      }
      let payload = json_rpc_exports.isBatchRequest(request) ? json_rpc_exports.toBatchPayload(request) : json_rpc_exports.toPayload(request);
      if (isMetaMaskProvider(provider)) {
        if (payload.method === "eth_sendTransaction") {
          if (!json_rpc_exports.isBatchRequest(payload)) {
            payload = metamaskPayload(payload);
          } else {
            payload = payload.map((p) => metamaskPayload(p));
          }
        }
      }
      if (isWeb3Provider(provider)) {
        let response;
        try {
          response = yield provider.request(payload);
        } catch (error) {
          response = error;
        }
        return this._processJsonRpcResponse(payload, response, { legacy: false, error: false });
      }
      if (isEIP1193Provider(provider)) {
        return provider.request(payload).then((res) => this._processJsonRpcResponse(payload, res, {
          legacy: true,
          error: false
        })).catch((error) => this._processJsonRpcResponse(payload, error, { legacy: true, error: true }));
      }
      if (isLegacyRequestProvider(provider)) {
        return new Promise((resolve, reject) => {
          const rejectWithError = (err) => reject(this._processJsonRpcResponse(payload, err, {
            legacy: true,
            error: true
          }));
          const resolveWithResponse = (response) => resolve(this._processJsonRpcResponse(payload, response, {
            legacy: true,
            error: false
          }));
          const result = provider.request(
            payload,
            (err, response) => {
              if (err) {
                return rejectWithError(err);
              }
              return resolveWithResponse(response);
            }
          );
          if (isPromise(result)) {
            const responsePromise = result;
            responsePromise.then(resolveWithResponse).catch(rejectWithError);
          }
        });
      }
      if (isLegacySendProvider(provider)) {
        return new Promise((resolve, reject) => {
          provider.send(payload, (err, response) => {
            if (err) {
              return reject(this._processJsonRpcResponse(payload, err, {
                legacy: true,
                error: true
              }));
            }
            if (isNullish2(response)) {
              throw new ResponseError("", 'Got a "nullish" response from provider.');
            }
            return resolve(this._processJsonRpcResponse(payload, response, {
              legacy: true,
              error: false
            }));
          });
        });
      }
      if (isLegacySendAsyncProvider(provider)) {
        return provider.sendAsync(payload).then((response) => this._processJsonRpcResponse(payload, response, { legacy: true, error: false })).catch((error) => this._processJsonRpcResponse(payload, error, {
          legacy: true,
          error: true
        }));
      }
      throw new ProviderError("Provider does not have a request or send method to use.");
    });
  }
  _processJsonRpcResponse(payload, response, { legacy, error }) {
    if (isNullish2(response)) {
      return this._buildResponse(
        payload,
        null,
        error
      );
    }
    if (json_rpc_exports.isResponseWithError(response)) {
      if (this.useRpcCallSpecification && isResponseRpcError(response)) {
        const rpcErrorResponse = response;
        if (rpcErrorsMap.get(rpcErrorResponse.error.code)) {
          const Err = rpcErrorsMap.get(rpcErrorResponse.error.code).error;
          throw new Err(rpcErrorResponse);
        } else {
          throw new RpcError(rpcErrorResponse);
        }
      } else if (!Web3RequestManager._isReverted(response)) {
        throw new InvalidResponseError(response, payload);
      }
    }
    if (json_rpc_exports.isResponseWithResult(response)) {
      return response;
    }
    if (response instanceof Error) {
      Web3RequestManager._isReverted(response);
      throw response;
    }
    if (!legacy && json_rpc_exports.isBatchRequest(payload) && json_rpc_exports.isBatchResponse(response)) {
      return response;
    }
    if (legacy && !error && json_rpc_exports.isBatchRequest(payload)) {
      return response;
    }
    if (legacy && error && json_rpc_exports.isBatchRequest(payload)) {
      throw response;
    }
    if (legacy && !json_rpc_exports.isResponseWithError(response) && !json_rpc_exports.isResponseWithResult(response)) {
      return this._buildResponse(payload, response, error);
    }
    if (json_rpc_exports.isBatchRequest(payload) && !Array.isArray(response)) {
      throw new ResponseError(response, "Got normal response for a batch request.");
    }
    if (!json_rpc_exports.isBatchRequest(payload) && Array.isArray(response)) {
      throw new ResponseError(response, "Got batch response for a normal request.");
    }
    if ((json_rpc_exports.isResponseWithError(response) || json_rpc_exports.isResponseWithResult(response)) && !json_rpc_exports.isBatchRequest(payload)) {
      if (response.id && payload.id !== response.id) {
        throw new InvalidResponseError(response);
      }
    }
    throw new ResponseError(response, "Invalid response");
  }
  static _isReverted(response) {
    let error;
    if (json_rpc_exports.isResponseWithError(response)) {
      error = response.error;
    } else if (response instanceof Error) {
      error = response;
    }
    if (error === null || error === void 0 ? void 0 : error.message.includes("revert"))
      throw new ContractExecutionError(error);
    return false;
  }
  _buildResponse(payload, response, error) {
    const res = {
      jsonrpc: "2.0",
      id: json_rpc_exports.isBatchRequest(payload) ? payload[0].id : "id" in payload ? payload.id : null
    };
    if (error) {
      return Object.assign(Object.assign({}, res), { error: response });
    }
    return Object.assign(Object.assign({}, res), { result: response });
  }
};

// node_modules/web3/node_modules/web3-core/lib/esm/web3_subscription_manager.js
init_shim();
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3SubscriptionManager = class {
  constructor(requestManager, registeredSubscriptions2, tolerateUnlinkedSubscription = false) {
    this.requestManager = requestManager;
    this.registeredSubscriptions = registeredSubscriptions2;
    this.tolerateUnlinkedSubscription = tolerateUnlinkedSubscription;
    this._subscriptions = /* @__PURE__ */ new Map();
    this.requestManager.on(Web3RequestManagerEvent.BEFORE_PROVIDER_CHANGE, () => __awaiter9(this, void 0, void 0, function* () {
      yield this.unsubscribe();
    }));
    this.requestManager.on(Web3RequestManagerEvent.PROVIDER_CHANGED, () => {
      this.clear();
      this.listenToProviderEvents();
    });
    this.listenToProviderEvents();
  }
  listenToProviderEvents() {
    const providerAsWebProvider = this.requestManager.provider;
    if (!this.requestManager.provider || typeof (providerAsWebProvider === null || providerAsWebProvider === void 0 ? void 0 : providerAsWebProvider.supportsSubscriptions) === "function" && !(providerAsWebProvider === null || providerAsWebProvider === void 0 ? void 0 : providerAsWebProvider.supportsSubscriptions())) {
      return;
    }
    if (typeof this.requestManager.provider.on === "function") {
      if (typeof this.requestManager.provider.request === "function") {
        this.requestManager.provider.on(
          "message",
          (message) => this.messageListener(message)
        );
      } else {
        providerAsWebProvider.on("data", (data) => this.messageListener(data));
      }
    }
  }
  messageListener(data) {
    var _a16, _b, _c;
    if (!data) {
      throw new SubscriptionError("Should not call messageListener with no data. Type was");
    }
    const subscriptionId = ((_a16 = data.params) === null || _a16 === void 0 ? void 0 : _a16.subscription) || ((_b = data.data) === null || _b === void 0 ? void 0 : _b.subscription) || ((_c = data.id) === null || _c === void 0 ? void 0 : _c.toString(16));
    if (subscriptionId) {
      const sub = this._subscriptions.get(subscriptionId);
      sub === null || sub === void 0 ? void 0 : sub.processSubscriptionData(data);
    }
  }
  subscribe(name2, args, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter9(this, void 0, void 0, function* () {
      const Klass = this.registeredSubscriptions[name2];
      if (!Klass) {
        throw new SubscriptionError("Invalid subscription type");
      }
      const subscription = new Klass(args !== null && args !== void 0 ? args : void 0, {
        subscriptionManager: this,
        returnFormat
      });
      yield this.addSubscription(subscription);
      return subscription;
    });
  }
  get subscriptions() {
    return this._subscriptions;
  }
  addSubscription(sub) {
    return __awaiter9(this, void 0, void 0, function* () {
      if (!this.requestManager.provider) {
        throw new ProviderError("Provider not available");
      }
      if (!this.supportsSubscriptions()) {
        throw new SubscriptionError("The current provider does not support subscriptions");
      }
      if (sub.id && this._subscriptions.has(sub.id)) {
        throw new SubscriptionError(`Subscription with id "${sub.id}" already exists`);
      }
      yield sub.sendSubscriptionRequest();
      if (isNullish2(sub.id)) {
        throw new SubscriptionError("Subscription is not subscribed yet.");
      }
      this._subscriptions.set(sub.id, sub);
      return sub.id;
    });
  }
  removeSubscription(sub) {
    return __awaiter9(this, void 0, void 0, function* () {
      const { id } = sub;
      if (isNullish2(id)) {
        throw new SubscriptionError("Subscription is not subscribed yet. Or, had already been unsubscribed but not through the Subscription Manager.");
      }
      if (!this._subscriptions.has(id) && !this.tolerateUnlinkedSubscription) {
        throw new SubscriptionError(`Subscription with id "${id.toString()}" does not exists`);
      }
      yield sub.sendUnsubscribeRequest();
      this._subscriptions.delete(id);
      return id;
    });
  }
  unsubscribe(condition) {
    return __awaiter9(this, void 0, void 0, function* () {
      const result = [];
      for (const [id, sub] of this.subscriptions.entries()) {
        if (!condition || typeof condition === "function" && condition({ id, sub })) {
          result.push(this.removeSubscription(sub));
        }
      }
      return Promise.all(result);
    });
  }
  clear() {
    this._subscriptions.clear();
  }
  supportsSubscriptions() {
    return isNullish2(this.requestManager.provider) ? false : isSupportSubscriptions(this.requestManager.provider);
  }
};

// node_modules/web3/node_modules/web3-core/lib/esm/web3_subscriptions.js
init_shim();
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3Subscription = class extends Web3EventEmitter {
  constructor(args, options) {
    var _a16;
    super();
    this.args = args;
    const { requestManager } = options;
    const { subscriptionManager } = options;
    if (requestManager && subscriptionManager) {
      throw new SubscriptionError("Only requestManager or subscriptionManager should be provided at Subscription constructor");
    }
    if (!requestManager && !subscriptionManager) {
      throw new SubscriptionError("Either requestManager or subscriptionManager should be provided at Subscription constructor");
    }
    if (requestManager) {
      this._subscriptionManager = new Web3SubscriptionManager(requestManager, {}, true);
    } else {
      this._subscriptionManager = subscriptionManager;
    }
    this._returnFormat = (_a16 = options === null || options === void 0 ? void 0 : options.returnFormat) !== null && _a16 !== void 0 ? _a16 : DEFAULT_RETURN_FORMAT;
  }
  get id() {
    return this._id;
  }
  get lastBlock() {
    return this._lastBlock;
  }
  subscribe() {
    return __awaiter10(this, void 0, void 0, function* () {
      return this._subscriptionManager.addSubscription(this);
    });
  }
  processSubscriptionData(data) {
    var _a16, _b;
    if (data === null || data === void 0 ? void 0 : data.data) {
      this._processSubscriptionResult((_b = (_a16 = data === null || data === void 0 ? void 0 : data.data) === null || _a16 === void 0 ? void 0 : _a16.result) !== null && _b !== void 0 ? _b : data === null || data === void 0 ? void 0 : data.data);
    } else if (data && json_rpc_exports.isResponseWithNotification(data)) {
      this._processSubscriptionResult(data === null || data === void 0 ? void 0 : data.params.result);
    }
  }
  sendSubscriptionRequest() {
    return __awaiter10(this, void 0, void 0, function* () {
      this._id = yield this._subscriptionManager.requestManager.send({
        method: "eth_subscribe",
        params: this._buildSubscriptionParams()
      });
      this.emit("connected", this._id);
      return this._id;
    });
  }
  get returnFormat() {
    return this._returnFormat;
  }
  get subscriptionManager() {
    return this._subscriptionManager;
  }
  resubscribe() {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.unsubscribe();
      yield this.subscribe();
    });
  }
  unsubscribe() {
    return __awaiter10(this, void 0, void 0, function* () {
      if (!this.id) {
        return;
      }
      yield this._subscriptionManager.removeSubscription(this);
    });
  }
  sendUnsubscribeRequest() {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this._subscriptionManager.requestManager.send({
        method: "eth_unsubscribe",
        params: [this.id]
      });
      this._id = void 0;
    });
  }
  formatSubscriptionResult(data) {
    return data;
  }
  _processSubscriptionResult(data) {
    this.emit("data", this.formatSubscriptionResult(data));
  }
  _processSubscriptionError(error) {
    this.emit("error", error);
  }
  _buildSubscriptionParams() {
    throw new Error("Implement in the child class");
  }
};

// node_modules/web3/node_modules/web3-core/lib/esm/web3_context.js
init_shim();

// node_modules/web3/node_modules/web3-core/lib/esm/web3_batch_request.js
init_shim();
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_BATCH_REQUEST_TIMEOUT = 1e3;
var Web3BatchRequest = class {
  constructor(requestManager) {
    this._requestManager = requestManager;
    this._requests = /* @__PURE__ */ new Map();
  }
  get requests() {
    return [...this._requests.values()].map((r) => r.payload);
  }
  add(request) {
    const payload = json_rpc_exports.toPayload(request);
    const promise = new Web3DeferredPromise();
    this._requests.set(payload.id, { payload, promise });
    return promise;
  }
  execute(options) {
    var _a16;
    return __awaiter11(this, void 0, void 0, function* () {
      if (this.requests.length === 0) {
        return Promise.resolve([]);
      }
      const request = new Web3DeferredPromise({
        timeout: (_a16 = options === null || options === void 0 ? void 0 : options.timeout) !== null && _a16 !== void 0 ? _a16 : DEFAULT_BATCH_REQUEST_TIMEOUT,
        eagerStart: true,
        timeoutMessage: "Batch request timeout"
      });
      this._processBatchRequest(request).catch((err) => request.reject(err));
      request.catch((err) => {
        if (err instanceof OperationTimeoutError) {
          this._abortAllRequests("Batch request timeout");
        }
        request.reject(err);
      });
      return request;
    });
  }
  _processBatchRequest(promise) {
    var _a16, _b;
    return __awaiter11(this, void 0, void 0, function* () {
      const response = yield this._requestManager.sendBatch([...this._requests.values()].map((r) => r.payload));
      if (response.length !== this._requests.size) {
        this._abortAllRequests("Invalid batch response");
        throw new ResponseError(response, `Batch request size mismatch the results size. Requests: ${this._requests.size}, Responses: ${response.length}`);
      }
      const requestIds = this.requests.map((r) => r.id).map(Number).sort((a, b) => a - b);
      const responseIds = response.map((r) => r.id).map(Number).sort((a, b) => a - b);
      if (JSON.stringify(requestIds) !== JSON.stringify(responseIds)) {
        this._abortAllRequests("Invalid batch response");
        throw new ResponseError(response, `Batch request mismatch the results. Requests: [${requestIds.join()}], Responses: [${responseIds.join()}]`);
      }
      for (const res of response) {
        if (json_rpc_exports.isResponseWithResult(res)) {
          (_a16 = this._requests.get(res.id)) === null || _a16 === void 0 ? void 0 : _a16.promise.resolve(res.result);
        } else if (json_rpc_exports.isResponseWithError(res)) {
          (_b = this._requests.get(res.id)) === null || _b === void 0 ? void 0 : _b.promise.reject(res.error);
        }
      }
      promise.resolve(response);
    });
  }
  _abortAllRequests(msg) {
    for (const { promise } of this._requests.values()) {
      promise.reject(new OperationAbortError(msg));
    }
  }
};

// node_modules/web3/node_modules/web3-core/lib/esm/web3_context.js
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3Context = class extends Web3Config {
  constructor(providerOrContext) {
    var _a16;
    super();
    this.providers = Web3RequestManager.providers;
    if (isNullish2(providerOrContext) || typeof providerOrContext === "string" && providerOrContext.trim() !== "" || isSupportedProvider(providerOrContext)) {
      this._requestManager = new Web3RequestManager(providerOrContext);
      this._subscriptionManager = new Web3SubscriptionManager(this._requestManager, {});
      return;
    }
    const { config, provider, requestManager, subscriptionManager, registeredSubscriptions: registeredSubscriptions2, accountProvider, wallet } = providerOrContext;
    this.setConfig(config !== null && config !== void 0 ? config : {});
    this._requestManager = requestManager !== null && requestManager !== void 0 ? requestManager : new Web3RequestManager(provider, (_a16 = config === null || config === void 0 ? void 0 : config.enableExperimentalFeatures) === null || _a16 === void 0 ? void 0 : _a16.useSubscriptionWhenCheckingBlockTimeout);
    if (subscriptionManager) {
      this._subscriptionManager = subscriptionManager;
    } else {
      this._subscriptionManager = new Web3SubscriptionManager(this.requestManager, registeredSubscriptions2 !== null && registeredSubscriptions2 !== void 0 ? registeredSubscriptions2 : {});
    }
    if (accountProvider) {
      this._accountProvider = accountProvider;
    }
    if (wallet) {
      this._wallet = wallet;
    }
  }
  get requestManager() {
    return this._requestManager;
  }
  get subscriptionManager() {
    return this._subscriptionManager;
  }
  get wallet() {
    return this._wallet;
  }
  get accountProvider() {
    return this._accountProvider;
  }
  static fromContextObject(...args) {
    return new this(...args.reverse());
  }
  getContextObject() {
    var _a16;
    return {
      config: this.config,
      provider: this.provider,
      requestManager: this.requestManager,
      subscriptionManager: this.subscriptionManager,
      registeredSubscriptions: (_a16 = this.subscriptionManager) === null || _a16 === void 0 ? void 0 : _a16.registeredSubscriptions,
      providers: this.providers,
      wallet: this.wallet,
      accountProvider: this.accountProvider
    };
  }
  use(ContextRef, ...args) {
    const newContextChild = new ContextRef(...[...args, this.getContextObject()]);
    this.on(Web3ConfigEvent.CONFIG_CHANGE, (event) => {
      newContextChild.setConfig({ [event.name]: event.newValue });
    });
    return newContextChild;
  }
  link(parentContext) {
    this.setConfig(parentContext.config);
    this._requestManager = parentContext.requestManager;
    this.provider = parentContext.provider;
    this._subscriptionManager = parentContext.subscriptionManager;
    this._wallet = parentContext.wallet;
    this._accountProvider = parentContext._accountProvider;
    parentContext.on(Web3ConfigEvent.CONFIG_CHANGE, (event) => {
      this.setConfig({ [event.name]: event.newValue });
    });
  }
  registerPlugin(plugin) {
    if (this[plugin.pluginNamespace] !== void 0)
      throw new ExistingPluginNamespaceError(plugin.pluginNamespace);
    const _pluginObject = {
      [plugin.pluginNamespace]: plugin
    };
    _pluginObject[plugin.pluginNamespace].link(this);
    Object.assign(this, _pluginObject);
  }
  get provider() {
    return this.currentProvider;
  }
  set provider(provider) {
    this.requestManager.setProvider(provider);
  }
  get currentProvider() {
    return this.requestManager.provider;
  }
  set currentProvider(provider) {
    this.requestManager.setProvider(provider);
  }
  get givenProvider() {
    return Web3Context.givenProvider;
  }
  setProvider(provider) {
    this.provider = provider;
    return true;
  }
  get BatchRequest() {
    return Web3BatchRequest.bind(void 0, this._requestManager);
  }
  extend(extendObj) {
    var _a16;
    if (extendObj.property && !this[extendObj.property])
      this[extendObj.property] = {};
    (_a16 = extendObj.methods) === null || _a16 === void 0 ? void 0 : _a16.forEach((element) => {
      const method = (...givenParams) => __awaiter12(this, void 0, void 0, function* () {
        return this.requestManager.send({
          method: element.call,
          params: givenParams
        });
      });
      if (extendObj.property)
        this[extendObj.property][element.name] = method;
      else
        this[element.name] = method;
    });
    return this;
  }
};
Web3Context.providers = Web3RequestManager.providers;
var Web3PluginBase = class extends Web3Context {
};
var Web3EthPluginBase = class extends Web3PluginBase {
};

// node_modules/web3/node_modules/web3-core/lib/esm/types.js
init_shim();

// node_modules/web3/node_modules/web3-core/lib/esm/formatters.js
var formatters_exports = {};
__export(formatters_exports, {
  inputAddressFormatter: () => inputAddressFormatter,
  inputBlockNumberFormatter: () => inputBlockNumberFormatter,
  inputCallFormatter: () => inputCallFormatter,
  inputDefaultBlockNumberFormatter: () => inputDefaultBlockNumberFormatter,
  inputLogFormatter: () => inputLogFormatter,
  inputPostFormatter: () => inputPostFormatter,
  inputSignFormatter: () => inputSignFormatter,
  inputStorageKeysFormatter: () => inputStorageKeysFormatter,
  inputTopicFormatter: () => inputTopicFormatter,
  inputTransactionFormatter: () => inputTransactionFormatter,
  outputBigIntegerFormatter: () => outputBigIntegerFormatter,
  outputBlockFormatter: () => outputBlockFormatter,
  outputLogFormatter: () => outputLogFormatter,
  outputPostFormatter: () => outputPostFormatter,
  outputProofFormatter: () => outputProofFormatter,
  outputSyncingFormatter: () => outputSyncingFormatter,
  outputTransactionFormatter: () => outputTransactionFormatter,
  outputTransactionReceiptFormatter: () => outputTransactionReceiptFormatter,
  txInputOptionsFormatter: () => txInputOptionsFormatter
});
init_shim();

// node_modules/web3/node_modules/web3-eth-iban/lib/esm/index.js
var esm_exports7 = {};
__export(esm_exports7, {
  Iban: () => Iban,
  default: () => esm_default
});
init_shim();

// node_modules/web3/node_modules/web3-eth-iban/lib/esm/iban.js
init_shim();
var Iban = class {
  constructor(iban) {
    this.toAddress = () => {
      if (this.isDirect()) {
        const base36 = this._iban.slice(4);
        const parsedBigInt = Iban._parseInt(base36, 36);
        const paddedBigInt = leftPad(parsedBigInt, 40);
        return toChecksumAddress(paddedBigInt);
      }
      throw new Error("Iban is indirect and cannot be converted. Must be length of 34 or 35");
    };
    if (Iban.isIndirect(iban) || Iban.isDirect(iban)) {
      this._iban = iban;
    } else {
      throw new Error("Invalid IBAN was provided");
    }
  }
  static isDirect(iban) {
    return iban.length === 34 || iban.length === 35;
  }
  isDirect() {
    return Iban.isDirect(this._iban);
  }
  static isIndirect(iban) {
    return iban.length === 20;
  }
  isIndirect() {
    return Iban.isIndirect(this._iban);
  }
  static isValid(iban) {
    return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(iban) && Iban._mod9710(Iban._iso13616Prepare(iban)) === 1;
  }
  isValid() {
    return Iban.isValid(this._iban);
  }
  static fromBban(bban) {
    const countryCode = "XE";
    const remainder = this._mod9710(this._iso13616Prepare(`${countryCode}00${bban}`));
    const checkDigit = `0${(98 - remainder).toString()}`.slice(-2);
    return new Iban(`${countryCode}${checkDigit}${bban}`);
  }
  static createIndirect(options) {
    return Iban.fromBban(`ETH${options.institution}${options.identifier}`);
  }
  static fromAddress(address) {
    if (!isAddress(address)) {
      throw new InvalidAddressError(address);
    }
    const num = BigInt(hexToNumber2(address));
    const base36 = num.toString(36);
    const padded = leftPad(base36, 15);
    return Iban.fromBban(padded.toUpperCase());
  }
  static toIban(address) {
    return Iban.fromAddress(address).toString();
  }
  client() {
    return this.isIndirect() ? this._iban.slice(11) : "";
  }
  checksum() {
    return this._iban.slice(2, 4);
  }
  institution() {
    return this.isIndirect() ? this._iban.slice(7, 11) : "";
  }
  toString() {
    return this._iban;
  }
};
Iban._iso13616Prepare = (iban) => {
  const A = "A".charCodeAt(0);
  const Z = "Z".charCodeAt(0);
  const upperIban = iban.toUpperCase();
  const modifiedIban = `${upperIban.slice(4)}${upperIban.slice(0, 4)}`;
  return modifiedIban.split("").map((n) => {
    const code = n.charCodeAt(0);
    if (code >= A && code <= Z) {
      return code - A + 10;
    }
    return n;
  }).join("");
};
Iban._parseInt = (str, base2) => [...str].reduce((acc, curr) => BigInt(parseInt(curr, base2)) + BigInt(base2) * acc, BigInt(0));
Iban._mod9710 = (iban) => {
  let remainder = iban;
  let block;
  while (remainder.length > 2) {
    block = remainder.slice(0, 9);
    remainder = `${(parseInt(block, 10) % 97).toString()}${remainder.slice(block.length)}`;
  }
  return parseInt(remainder, 10) % 97;
};
Iban.toAddress = (iban) => {
  const ibanObject = new Iban(iban);
  return ibanObject.toAddress();
};

// node_modules/web3/node_modules/web3-eth-iban/lib/esm/types.js
init_shim();

// node_modules/web3/node_modules/web3-eth-iban/lib/esm/index.js
var esm_default = Iban;

// node_modules/web3/node_modules/web3-core/lib/esm/formatters.js
var inputStorageKeysFormatter = (keys) => keys.map((num) => numberToHex2(num));
var outputProofFormatter = (proof) => ({
  address: toChecksumAddress(proof.address),
  nonce: hexToNumberString(proof.nonce),
  balance: hexToNumberString(proof.balance)
});
var outputBigIntegerFormatter = (number) => toNumber(number);
var inputBlockNumberFormatter = (blockNumber) => {
  if (isNullish(blockNumber)) {
    return void 0;
  }
  if (typeof blockNumber === "string" && isBlockTag(blockNumber)) {
    return blockNumber;
  }
  if (blockNumber === "genesis") {
    return "0x0";
  }
  if (typeof blockNumber === "string" && isHexStrict2(blockNumber)) {
    return blockNumber.toLowerCase();
  }
  return numberToHex2(blockNumber);
};
var inputDefaultBlockNumberFormatter = (blockNumber, defaultBlock) => {
  if (!blockNumber) {
    return inputBlockNumberFormatter(defaultBlock);
  }
  return inputBlockNumberFormatter(blockNumber);
};
var inputAddressFormatter = (address) => {
  if (Iban.isValid(address) && Iban.isDirect(address)) {
    const iban = new Iban(address);
    return iban.toAddress().toLowerCase();
  }
  if (isAddress2(address)) {
    return `0x${address.toLowerCase().replace("0x", "")}`;
  }
  throw new FormatterError(`Provided address ${address} is invalid, the capitalization checksum test failed, or it's an indirect IBAN address which can't be converted.`);
};
var txInputOptionsFormatter = (options) => {
  var _a16;
  const modifiedOptions = Object.assign({}, options);
  if (options.to) {
    modifiedOptions.to = inputAddressFormatter(options.to);
  }
  if (options.data && options.input) {
    throw new FormatterError(`You can't have "data" and "input" as properties of transactions at the same time, please use either "data" or "input" instead.`);
  }
  if (!options.input && options.data) {
    modifiedOptions.input = options.data;
    delete modifiedOptions.data;
  }
  if (options.input && !options.input.startsWith("0x")) {
    modifiedOptions.input = `0x${options.input}`;
  }
  if (modifiedOptions.input && !isHexStrict2(modifiedOptions.input)) {
    throw new FormatterError("The input field must be HEX encoded data.");
  }
  if (options.gas || options.gasLimit) {
    modifiedOptions.gas = toNumber((_a16 = options.gas) !== null && _a16 !== void 0 ? _a16 : options.gasLimit);
  }
  if (options.maxPriorityFeePerGas || options.maxFeePerGas) {
    delete modifiedOptions.gasPrice;
  }
  ["gasPrice", "gas", "value", "maxPriorityFeePerGas", "maxFeePerGas", "nonce", "chainId"].filter((key) => !isNullish(modifiedOptions[key])).forEach((key) => {
    modifiedOptions[key] = numberToHex2(modifiedOptions[key]);
  });
  return modifiedOptions;
};
var inputCallFormatter = (options, defaultAccount) => {
  var _a16;
  const opts = txInputOptionsFormatter(options);
  const from = (_a16 = opts.from) !== null && _a16 !== void 0 ? _a16 : defaultAccount;
  if (from) {
    opts.from = inputAddressFormatter(from);
  }
  return opts;
};
var inputTransactionFormatter = (options, defaultAccount) => {
  var _a16;
  const opts = txInputOptionsFormatter(options);
  if (!(typeof opts.from === "number") && !(!!opts.from && typeof opts.from === "object")) {
    opts.from = (_a16 = opts.from) !== null && _a16 !== void 0 ? _a16 : defaultAccount;
    if (!options.from && !(typeof options.from === "number")) {
      throw new FormatterError('The send transactions "from" field must be defined!');
    }
    opts.from = inputAddressFormatter(options.from);
  }
  return opts;
};
var inputSignFormatter = (data) => isHexStrict2(data) ? data : utf8ToHex(data);
var outputTransactionFormatter = (tx) => {
  const modifiedTx = Object.assign({}, tx);
  if (tx.blockNumber) {
    modifiedTx.blockNumber = hexToNumber2(tx.blockNumber);
  }
  if (tx.transactionIndex) {
    modifiedTx.transactionIndex = hexToNumber2(tx.transactionIndex);
  }
  modifiedTx.nonce = hexToNumber2(tx.nonce);
  modifiedTx.gas = hexToNumber2(tx.gas);
  if (tx.gasPrice) {
    modifiedTx.gasPrice = outputBigIntegerFormatter(tx.gasPrice);
  }
  if (tx.maxFeePerGas) {
    modifiedTx.maxFeePerGas = outputBigIntegerFormatter(tx.maxFeePerGas);
  }
  if (tx.maxPriorityFeePerGas) {
    modifiedTx.maxPriorityFeePerGas = outputBigIntegerFormatter(tx.maxPriorityFeePerGas);
  }
  if (tx.type) {
    modifiedTx.type = hexToNumber2(tx.type);
  }
  modifiedTx.value = outputBigIntegerFormatter(tx.value);
  if (tx.to && isAddress2(tx.to)) {
    modifiedTx.to = toChecksumAddress(tx.to);
  } else {
    modifiedTx.to = void 0;
  }
  if (tx.from) {
    modifiedTx.from = toChecksumAddress(tx.from);
  }
  return modifiedTx;
};
var inputTopicFormatter = (topic) => {
  if (isNullish(topic))
    return null;
  const value = String(topic);
  return isHex(value) ? value : fromUtf8(value);
};
var inputLogFormatter = (filter) => {
  var _a16;
  const val = isNullish(filter) ? {} : mergeDeep({}, filter);
  if (isNullish(val.fromBlock)) {
    val.fromBlock = BlockTags.LATEST;
  }
  val.fromBlock = inputBlockNumberFormatter(val.fromBlock);
  if (!isNullish(val.toBlock)) {
    val.toBlock = inputBlockNumberFormatter(val.toBlock);
  }
  val.topics = (_a16 = val.topics) !== null && _a16 !== void 0 ? _a16 : [];
  val.topics = val.topics.map((topic) => Array.isArray(topic) ? topic.map(inputTopicFormatter) : inputTopicFormatter(topic));
  if (val.address) {
    val.address = Array.isArray(val.address) ? val.address.map((addr) => inputAddressFormatter(addr)) : inputAddressFormatter(val.address);
  }
  return val;
};
var outputLogFormatter = (log) => {
  const modifiedLog = Object.assign({}, log);
  const logIndex = typeof log.logIndex === "string" ? log.logIndex : numberToHex2(log.logIndex);
  if (typeof log.blockHash === "string" && typeof log.transactionHash === "string") {
    const shaId = sha3Raw(`${log.blockHash.replace("0x", "")}${log.transactionHash.replace("0x", "")}${logIndex.replace("0x", "")}`);
    modifiedLog.id = `log_${shaId.replace("0x", "").slice(0, 8)}`;
  } else if (!log.id) {
    modifiedLog.id = void 0;
  }
  if (log.blockNumber && isHexStrict2(log.blockNumber)) {
    modifiedLog.blockNumber = hexToNumber2(log.blockNumber);
  }
  if (log.transactionIndex && isHexStrict2(log.transactionIndex)) {
    modifiedLog.transactionIndex = hexToNumber2(log.transactionIndex);
  }
  if (log.logIndex && isHexStrict2(log.logIndex)) {
    modifiedLog.logIndex = hexToNumber2(log.logIndex);
  }
  if (log.address) {
    modifiedLog.address = toChecksumAddress(log.address);
  }
  return modifiedLog;
};
var outputTransactionReceiptFormatter = (receipt) => {
  if (typeof receipt !== "object") {
    throw new FormatterError(`Received receipt is invalid: ${String(receipt)}`);
  }
  const modifiedReceipt = Object.assign({}, receipt);
  if (receipt.blockNumber) {
    modifiedReceipt.blockNumber = hexToNumber2(receipt.blockNumber);
  }
  if (receipt.transactionIndex) {
    modifiedReceipt.transactionIndex = hexToNumber2(receipt.transactionIndex);
  }
  modifiedReceipt.cumulativeGasUsed = hexToNumber2(receipt.cumulativeGasUsed);
  modifiedReceipt.gasUsed = hexToNumber2(receipt.gasUsed);
  if (receipt.logs && Array.isArray(receipt.logs)) {
    modifiedReceipt.logs = receipt.logs.map(outputLogFormatter);
  }
  if (receipt.effectiveGasPrice) {
    modifiedReceipt.effectiveGasPrice = hexToNumber2(receipt.effectiveGasPrice);
  }
  if (receipt.contractAddress) {
    modifiedReceipt.contractAddress = toChecksumAddress(receipt.contractAddress);
  }
  if (receipt.status) {
    modifiedReceipt.status = Boolean(parseInt(receipt.status, 10));
  }
  return modifiedReceipt;
};
var outputBlockFormatter = (block) => {
  const modifiedBlock = Object.assign({}, block);
  modifiedBlock.gasLimit = hexToNumber2(block.gasLimit);
  modifiedBlock.gasUsed = hexToNumber2(block.gasUsed);
  modifiedBlock.size = hexToNumber2(block.size);
  modifiedBlock.timestamp = hexToNumber2(block.timestamp);
  if (block.number) {
    modifiedBlock.number = hexToNumber2(block.number);
  }
  if (block.difficulty) {
    modifiedBlock.difficulty = outputBigIntegerFormatter(block.difficulty);
  }
  if (block.totalDifficulty) {
    modifiedBlock.totalDifficulty = outputBigIntegerFormatter(block.totalDifficulty);
  }
  if (block.transactions && Array.isArray(block.transactions)) {
    modifiedBlock.transactions = block.transactions.map(outputTransactionFormatter);
  }
  if (block.miner) {
    modifiedBlock.miner = toChecksumAddress(block.miner);
  }
  if (block.baseFeePerGas) {
    modifiedBlock.baseFeePerGas = outputBigIntegerFormatter(block.baseFeePerGas);
  }
  return modifiedBlock;
};
var inputPostFormatter = (post) => {
  var _a16;
  const modifiedPost = Object.assign({}, post);
  if (post.ttl) {
    modifiedPost.ttl = numberToHex2(post.ttl);
  }
  if (post.workToProve) {
    modifiedPost.workToProve = numberToHex2(post.workToProve);
  }
  if (post.priority) {
    modifiedPost.priority = numberToHex2(post.priority);
  }
  if (post.topics && !Array.isArray(post.topics)) {
    modifiedPost.topics = post.topics ? [post.topics] : [];
  }
  modifiedPost.topics = (_a16 = modifiedPost.topics) === null || _a16 === void 0 ? void 0 : _a16.map((topic) => topic.startsWith("0x") ? topic : fromUtf8(topic));
  return modifiedPost;
};
var outputPostFormatter = (post) => {
  var _a16;
  const modifiedPost = Object.assign({}, post);
  if (post.expiry) {
    modifiedPost.expiry = hexToNumber2(post.expiry);
  }
  if (post.sent) {
    modifiedPost.sent = hexToNumber2(post.sent);
  }
  if (post.ttl) {
    modifiedPost.ttl = hexToNumber2(post.ttl);
  }
  if (post.workProved) {
    modifiedPost.workProved = hexToNumber2(post.workProved);
  }
  if (!post.topics) {
    modifiedPost.topics = [];
  }
  modifiedPost.topics = (_a16 = modifiedPost.topics) === null || _a16 === void 0 ? void 0 : _a16.map(toUtf8);
  return modifiedPost;
};
var outputSyncingFormatter = (result) => {
  const modifiedResult = Object.assign({}, result);
  modifiedResult.startingBlock = hexToNumber2(result.startingBlock);
  modifiedResult.currentBlock = hexToNumber2(result.currentBlock);
  modifiedResult.highestBlock = hexToNumber2(result.highestBlock);
  if (result.knownStates) {
    modifiedResult.knownStates = hexToNumber2(result.knownStates);
  }
  if (result.pulledStates) {
    modifiedResult.pulledStates = hexToNumber2(result.pulledStates);
  }
  return modifiedResult;
};

// node_modules/web3/node_modules/web3-core/lib/esm/web3_promi_event.js
init_shim();
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a2;
var Web3PromiEvent = class extends Web3EventEmitter {
  constructor(executor) {
    super();
    this[_a2] = "Promise";
    this._promise = new Promise(executor);
  }
  then(onfulfilled, onrejected) {
    return __awaiter13(this, void 0, void 0, function* () {
      return this._promise.then(onfulfilled, onrejected);
    });
  }
  catch(onrejected) {
    return __awaiter13(this, void 0, void 0, function* () {
      return this._promise.catch(onrejected);
    });
  }
  finally(onfinally) {
    return __awaiter13(this, void 0, void 0, function* () {
      return this._promise.finally(onfinally);
    });
  }
  on(eventName, fn) {
    super.on(eventName, fn);
    return this;
  }
  once(eventName, fn) {
    super.once(eventName, fn);
    return this;
  }
};
_a2 = Symbol.toStringTag;

// node_modules/web3-eth/lib/esm/index.js
init_shim();
var import_setimmediate = __toESM(require_setImmediate());

// node_modules/web3-eth/lib/esm/web3_eth.js
init_shim();

// node_modules/web3-eth/node_modules/web3-core/lib/esm/index.js
init_shim();

// node_modules/web3-eth/node_modules/web3-core/lib/esm/web3_config.js
init_shim();

// node_modules/web3-eth/node_modules/web3-utils/lib/esm/index.js
init_shim();

// node_modules/web3-eth/node_modules/web3-utils/lib/esm/converters.js
init_shim();

// node_modules/web3-eth/node_modules/ethereum-cryptography/esm/keccak.js
init_shim();
init_sha3();

// node_modules/web3-eth/node_modules/ethereum-cryptography/esm/utils.js
init_shim();
init_assert();
init_utils();
init_utils();
var assertBool3 = assert_default.bool;
var assertBytes3 = assert_default.bytes;
function bytesToUtf82(data) {
  if (!(data instanceof Uint8Array)) {
    throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
  }
  return new TextDecoder().decode(data);
}
function wrapHash3(hash) {
  return (msg) => {
    assert_default.bytes(msg);
    return hash(msg);
  };
}
var crypto4 = (() => {
  const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
  return {
    node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
    web: webCrypto
  };
})();

// node_modules/web3-eth/node_modules/ethereum-cryptography/esm/keccak.js
var keccak2243 = wrapHash3(keccak_224);
var keccak2563 = (() => {
  const k = wrapHash3(keccak_256);
  k.create = keccak_256.create;
  return k;
})();
var keccak3843 = wrapHash3(keccak_384);
var keccak5123 = wrapHash3(keccak_512);

// node_modules/web3-eth/node_modules/web3-utils/lib/esm/converters.js
var ethUnitMap2 = {
  noether: BigInt(0),
  wei: BigInt(1),
  kwei: BigInt(1e3),
  Kwei: BigInt(1e3),
  babbage: BigInt(1e3),
  femtoether: BigInt(1e3),
  mwei: BigInt(1e6),
  Mwei: BigInt(1e6),
  lovelace: BigInt(1e6),
  picoether: BigInt(1e6),
  gwei: BigInt(1e9),
  Gwei: BigInt(1e9),
  shannon: BigInt(1e9),
  nanoether: BigInt(1e9),
  nano: BigInt(1e9),
  szabo: BigInt(1e12),
  microether: BigInt(1e12),
  micro: BigInt(1e12),
  finney: BigInt(1e15),
  milliether: BigInt(1e15),
  milli: BigInt(1e15),
  ether: BigInt("1000000000000000000"),
  kether: BigInt("1000000000000000000000"),
  grand: BigInt("1000000000000000000000"),
  mether: BigInt("1000000000000000000000000"),
  gether: BigInt("1000000000000000000000000000"),
  tether: BigInt("1000000000000000000000000000000")
};
var bytesToUint8Array2 = (data) => {
  validator.validate(["bytes"], [data]);
  if (data instanceof Uint8Array) {
    return data;
  }
  if (Array.isArray(data)) {
    return new Uint8Array(data);
  }
  if (typeof data === "string") {
    return utils_exports.hexToUint8Array(data);
  }
  throw new InvalidBytesError(data);
};
var { uint8ArrayToHexString: uint8ArrayToHexString3 } = utils_exports;
var bytesToHex3 = (bytes) => uint8ArrayToHexString3(bytesToUint8Array2(bytes));
var hexToBytes3 = (bytes) => {
  if (typeof bytes === "string" && bytes.slice(0, 2).toLowerCase() !== "0x") {
    return bytesToUint8Array2(`0x${bytes}`);
  }
  return bytesToUint8Array2(bytes);
};
var hexToNumber3 = (value) => {
  validator.validate(["hex"], [value]);
  return utils_exports.hexToNumber(value);
};
var numberToHex3 = (value, hexstrict) => {
  if (typeof value !== "bigint")
    validator.validate(["int"], [value]);
  let updatedValue = utils_exports.numberToHex(value);
  if (hexstrict) {
    if (!updatedValue.startsWith("-") && updatedValue.length % 2 === 1) {
      updatedValue = "0x0".concat(updatedValue.slice(2));
    } else if (updatedValue.length % 2 === 0 && updatedValue.startsWith("-"))
      updatedValue = "-0x0".concat(updatedValue.slice(3));
  }
  return updatedValue;
};
var hexToNumberString2 = (data) => hexToNumber3(data).toString();
var utf8ToHex2 = (str) => {
  validator.validate(["string"], [str]);
  let strWithoutNullCharacter = str.replace(/^(?:\u0000)/, "");
  strWithoutNullCharacter = strWithoutNullCharacter.replace(/(?:\u0000)$/, "");
  return bytesToHex3(new TextEncoder().encode(strWithoutNullCharacter));
};
var fromUtf82 = utf8ToHex2;
var hexToUtf82 = (str) => bytesToUtf82(hexToBytes3(str));
var toUtf82 = (input) => {
  if (typeof input === "string") {
    return hexToUtf82(input);
  }
  validator.validate(["bytes"], [input]);
  return bytesToUtf82(input);
};
var utf8ToBytes3 = utf8ToBytes;
var toHex2 = (value, returnType) => {
  if (typeof value === "string" && isAddress(value)) {
    return returnType ? "address" : `0x${value.toLowerCase().replace(/^0x/i, "")}`;
  }
  if (typeof value === "boolean") {
    return returnType ? "bool" : value ? "0x01" : "0x00";
  }
  if (typeof value === "number") {
    return returnType ? value < 0 ? "int256" : "uint256" : numberToHex3(value);
  }
  if (typeof value === "bigint") {
    return returnType ? "bigint" : numberToHex3(value);
  }
  if (typeof value === "object" && !!value) {
    return returnType ? "string" : utf8ToHex2(JSON.stringify(value));
  }
  if (typeof value === "string") {
    if (value.startsWith("-0x") || value.startsWith("-0X")) {
      return returnType ? "int256" : numberToHex3(value);
    }
    if (isHexStrict(value)) {
      return returnType ? "bytes" : value;
    }
    if (isHex(value) && !isInt(value)) {
      return returnType ? "bytes" : `0x${value}`;
    }
    if (!Number.isFinite(value)) {
      return returnType ? "string" : utf8ToHex2(value);
    }
  }
  throw new HexProcessingError(value);
};
var toNumber2 = (value) => {
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "bigint") {
    return value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER ? Number(value) : value;
  }
  if (typeof value === "string" && isHexStrict(value)) {
    return hexToNumber3(value);
  }
  try {
    return toNumber2(BigInt(value));
  } catch (_a16) {
    throw new InvalidNumberError(value);
  }
};
var toBigInt2 = (value) => {
  if (typeof value === "number") {
    return BigInt(value);
  }
  if (typeof value === "bigint") {
    return value;
  }
  if (typeof value === "string" && isHex(value)) {
    if (value.startsWith("-")) {
      return -BigInt(value.substring(1));
    }
    return BigInt(value);
  }
  throw new InvalidNumberError(value);
};
var toChecksumAddress2 = (address) => {
  if (!isAddress(address, false)) {
    throw new InvalidAddressError(address);
  }
  const lowerCaseAddress = address.toLowerCase().replace(/^0x/i, "");
  const hash = utils_exports.uint8ArrayToHexString(keccak2563(utf8ToBytes3(lowerCaseAddress)));
  if (isNullish(hash) || hash === "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470")
    return "";
  let checksumAddress = "0x";
  const addressHash = hash.replace(/^0x/i, "");
  for (let i = 0; i < lowerCaseAddress.length; i += 1) {
    if (parseInt(addressHash[i], 16) > 7) {
      checksumAddress += lowerCaseAddress[i].toUpperCase();
    } else {
      checksumAddress += lowerCaseAddress[i];
    }
  }
  return checksumAddress;
};

// node_modules/web3-eth/node_modules/web3-utils/lib/esm/event_emitter.js
init_shim();
var import_events3 = __toESM(require_events(), 1);
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var wrapFunction2 = (fn) => (params) => fn(params.detail);
var EventEmitterAtBrowser2 = class extends EventTarget {
  constructor() {
    super(...arguments);
    this._listeners = {};
    this.maxListeners = Number.MAX_SAFE_INTEGER;
  }
  on(eventName, fn) {
    this.addEventListener(eventName, fn);
    return this;
  }
  once(eventName, fn) {
    const onceCallback = (params) => __awaiter14(this, void 0, void 0, function* () {
      this.off(eventName, onceCallback);
      yield fn(params);
    });
    return this.on(eventName, onceCallback);
  }
  off(eventName, fn) {
    this.removeEventListener(eventName, fn);
    return this;
  }
  emit(eventName, params) {
    const event = new CustomEvent(eventName, { detail: params });
    return super.dispatchEvent(event);
  }
  listenerCount(eventName) {
    const eventListeners = this._listeners[eventName];
    return eventListeners ? eventListeners.length : 0;
  }
  listeners(eventName) {
    return this._listeners[eventName].map((value) => value[0]) || [];
  }
  eventNames() {
    return Object.keys(this._listeners);
  }
  removeAllListeners() {
    Object.keys(this._listeners).forEach((event) => {
      this._listeners[event].forEach((listener) => {
        super.removeEventListener(event, listener[1]);
      });
    });
    this._listeners = {};
    return this;
  }
  setMaxListeners(maxListeners) {
    this.maxListeners = maxListeners;
    return this;
  }
  getMaxListeners() {
    return this.maxListeners;
  }
  addEventListener(eventName, fn) {
    const wrappedFn = wrapFunction2(fn);
    super.addEventListener(eventName, wrappedFn);
    if (!this._listeners[eventName]) {
      this._listeners[eventName] = [];
    }
    this._listeners[eventName].push([fn, wrappedFn]);
  }
  removeEventListener(eventName, fn) {
    const eventListeners = this._listeners[eventName];
    if (eventListeners) {
      const index = eventListeners.findIndex((item) => item[0] === fn);
      if (index !== -1) {
        super.removeEventListener(eventName, eventListeners[index][1]);
        eventListeners.splice(index, 1);
      }
    }
  }
};
var EventEmitterType2;
if (typeof window === "undefined") {
  EventEmitterType2 = import_events3.EventEmitter;
} else {
  EventEmitterType2 = EventEmitterAtBrowser2;
}
var EventEmitter3 = class extends EventEmitterType2 {
};

// node_modules/web3-eth/node_modules/web3-utils/lib/esm/validation.js
init_shim();
var isHexStrict3 = isHexStrict;
var isAddress3 = isAddress;
var isNullish3 = isNullish;

// node_modules/web3-eth/node_modules/web3-utils/lib/esm/formatter.js
init_shim();

// node_modules/web3-eth/node_modules/web3-utils/lib/esm/objects.js
init_shim();
var isIterable2 = (item) => typeof item === "object" && !isNullish(item) && !Array.isArray(item) && !(item instanceof TypedArray);
var mergeDeep2 = (destination, ...sources) => {
  const result = destination;
  if (!isIterable2(result)) {
    return result;
  }
  for (const src of sources) {
    for (const key in src) {
      if (isIterable2(src[key])) {
        if (!result[key]) {
          result[key] = {};
        }
        mergeDeep2(result[key], src[key]);
      } else if (!isNullish(src[key]) && Object.hasOwnProperty.call(src, key)) {
        if (Array.isArray(src[key]) || src[key] instanceof TypedArray) {
          result[key] = src[key].slice(0);
        } else {
          result[key] = src[key];
        }
      }
    }
  }
  return result;
};

// node_modules/web3-eth/node_modules/web3-utils/lib/esm/string_manipulation.js
init_shim();
var padLeft3 = (value, characterAmount, sign6 = "0") => {
  if (typeof value === "string") {
    if (!isHexStrict(value)) {
      return value.padStart(characterAmount, sign6);
    }
    return utils_exports.padLeft(value, characterAmount, sign6);
  }
  validator.validate(["int"], [value]);
  return utils_exports.padLeft(value, characterAmount, sign6);
};
var leftPad2 = padLeft3;

// node_modules/web3-eth/node_modules/web3-utils/lib/esm/uint8array.js
init_shim();
function uint8ArrayConcat2(...parts) {
  const length = parts.reduce((prev, part) => {
    const agg = prev + part.length;
    return agg;
  }, 0);
  const result = new Uint8Array(length);
  let offset = 0;
  for (const part of parts) {
    result.set(part, offset);
    offset += part.length;
  }
  return result;
}

// node_modules/web3-eth/node_modules/web3-utils/lib/esm/formatter.js
var { parseBaseType: parseBaseType3 } = utils_exports;
var findSchemaByDataPath2 = (schema, dataPath, oneOfPath = []) => {
  let result = Object.assign({}, schema);
  let previousDataPath;
  for (const dataPart of dataPath) {
    if (result.oneOf && previousDataPath) {
      const path = oneOfPath.find(function(element) {
        return this === element[0];
      }, previousDataPath !== null && previousDataPath !== void 0 ? previousDataPath : "");
      if (path && path[0] === previousDataPath) {
        result = result.oneOf[path[1]];
      }
    }
    if (!result.properties && !result.items) {
      return void 0;
    }
    if (result.properties) {
      result = result.properties[dataPart];
    } else if (result.items && result.items.properties) {
      const node = result.items.properties;
      if (!node) {
        return void 0;
      }
      result = node[dataPart];
    } else if (result.items && isObject(result.items)) {
      result = result.items;
    } else if (result.items && Array.isArray(result.items)) {
      result = result.items[parseInt(dataPart, 10)];
    }
    if (result && dataPart)
      previousDataPath = dataPart;
  }
  return result;
};
var convertScalarValue2 = (value, ethType, format5) => {
  try {
    const { baseType, baseTypeSize } = parseBaseType3(ethType);
    if (baseType === "int" || baseType === "uint") {
      switch (format5.number) {
        case FMT_NUMBER.NUMBER:
          return Number(toBigInt2(value));
        case FMT_NUMBER.HEX:
          return numberToHex3(toBigInt2(value));
        case FMT_NUMBER.STR:
          return toBigInt2(value).toString();
        case FMT_NUMBER.BIGINT:
          return toBigInt2(value);
        default:
          throw new FormatterError(`Invalid format: ${String(format5.number)}`);
      }
    }
    if (baseType === "bytes") {
      let paddedValue;
      if (baseTypeSize) {
        if (typeof value === "string")
          paddedValue = padLeft3(value, baseTypeSize * 2);
        else if (value instanceof Uint8Array) {
          paddedValue = uint8ArrayConcat2(new Uint8Array(baseTypeSize - value.length), value);
        }
      } else {
        paddedValue = value;
      }
      switch (format5.bytes) {
        case FMT_BYTES.HEX:
          return bytesToHex3(bytesToUint8Array2(paddedValue));
        case FMT_BYTES.UINT8ARRAY:
          return bytesToUint8Array2(paddedValue);
        default:
          throw new FormatterError(`Invalid format: ${String(format5.bytes)}`);
      }
    }
  } catch (error) {
    return value;
  }
  return value;
};
var convert2 = (data, schema, dataPath, format5, oneOfPath = []) => {
  var _a16, _b;
  if (!isObject(data) && !Array.isArray(data)) {
    return convertScalarValue2(data, schema === null || schema === void 0 ? void 0 : schema.format, format5);
  }
  const object = data;
  for (const [key, value] of Object.entries(object)) {
    dataPath.push(key);
    const schemaProp = findSchemaByDataPath2(schema, dataPath, oneOfPath);
    if (isNullish(schemaProp)) {
      delete object[key];
      dataPath.pop();
      continue;
    }
    if (isObject(value)) {
      convert2(value, schema, dataPath, format5);
      dataPath.pop();
      continue;
    }
    if (Array.isArray(value)) {
      let _schemaProp = schemaProp;
      if ((schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.oneOf) !== void 0) {
        schemaProp.oneOf.forEach((oneOfSchemaProp, index) => {
          var _a17, _b2;
          if (!Array.isArray(schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.items) && (typeof value[0] === "object" && ((_a17 = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _a17 === void 0 ? void 0 : _a17.type) === "object" || typeof value[0] === "string" && ((_b2 = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _b2 === void 0 ? void 0 : _b2.type) !== "object")) {
            _schemaProp = oneOfSchemaProp;
            oneOfPath.push([key, index]);
          }
        });
      }
      if (isNullish(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {
        delete object[key];
        dataPath.pop();
        continue;
      }
      if (isObject(_schemaProp.items) && !isNullish(_schemaProp.items.format)) {
        for (let i = 0; i < value.length; i += 1) {
          object[key][i] = convertScalarValue2(
            value[i],
            (_a16 = _schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) === null || _a16 === void 0 ? void 0 : _a16.format,
            format5
          );
        }
        dataPath.pop();
        continue;
      }
      if (!Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) && ((_b = _schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) === null || _b === void 0 ? void 0 : _b.type) === "object") {
        for (const arrObject of value) {
          convert2(arrObject, schema, dataPath, format5, oneOfPath);
        }
        dataPath.pop();
        continue;
      }
      if (Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {
        for (let i = 0; i < value.length; i += 1) {
          object[key][i] = convertScalarValue2(value[i], _schemaProp.items[i].format, format5);
        }
        dataPath.pop();
        continue;
      }
    }
    object[key] = convertScalarValue2(value, schemaProp.format, format5);
    dataPath.pop();
  }
  return object;
};
var format2 = (schema, data, returnFormat) => {
  let dataToParse;
  if (isObject(data)) {
    dataToParse = mergeDeep2({}, data);
  } else if (Array.isArray(data)) {
    dataToParse = [...data];
  } else {
    dataToParse = data;
  }
  const jsonSchema = isObject(schema) ? schema : utils_exports.ethAbiToJsonSchema(schema);
  if (!jsonSchema.properties && !jsonSchema.items && !jsonSchema.format) {
    throw new FormatterError("Invalid json schema for formatting");
  }
  return convert2(dataToParse, jsonSchema, [], returnFormat);
};

// node_modules/web3-eth/node_modules/web3-utils/lib/esm/hash.js
init_shim();
var SHA3_EMPTY_BYTES2 = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
var sha32 = (data) => {
  let updatedData;
  if (typeof data === "string") {
    if (data.startsWith("0x") && isHexStrict(data)) {
      updatedData = hexToBytes3(data);
    } else {
      updatedData = utf8ToBytes(data);
    }
  } else {
    updatedData = data;
  }
  const hash = bytesToHex3(keccak2563(updatedData));
  return hash === SHA3_EMPTY_BYTES2 ? void 0 : hash;
};
var sha3Raw2 = (data) => {
  const hash = sha32(data);
  if (isNullish(hash)) {
    return SHA3_EMPTY_BYTES2;
  }
  return hash;
};
var keccak256Wrapper2 = (data) => {
  let processedData;
  if (typeof data === "bigint" || typeof data === "number") {
    processedData = utf8ToBytes(data.toString());
  } else if (Array.isArray(data)) {
    processedData = new Uint8Array(data);
  } else if (typeof data === "string" && !isHexStrict(data)) {
    processedData = utf8ToBytes(data);
  } else {
    processedData = bytesToUint8Array2(data);
  }
  return bytesToHex3(keccak2563(processedData));
};

// node_modules/web3-eth/node_modules/web3-utils/lib/esm/random.js
init_shim();

// node_modules/web3-eth/node_modules/ethereum-cryptography/esm/random.js
init_shim();
init_utils();
function getRandomBytesSync2(bytes) {
  return randomBytes(bytes);
}

// node_modules/web3-eth/node_modules/web3-utils/lib/esm/random.js
var randomBytes3 = (size) => getRandomBytesSync2(size);

// node_modules/web3-eth/node_modules/web3-utils/lib/esm/promise_helpers.js
init_shim();
var __awaiter15 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function isPromise2(object) {
  return (typeof object === "object" || typeof object === "function") && typeof object.then === "function";
}
function waitWithTimeout2(awaitable, timeout, error) {
  return __awaiter15(this, void 0, void 0, function* () {
    let timeoutId;
    const result = yield Promise.race([
      awaitable instanceof Promise ? awaitable : awaitable(),
      new Promise((resolve, reject) => {
        timeoutId = setTimeout(() => error ? reject(error) : resolve(void 0), timeout);
      })
    ]);
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    if (result instanceof Error) {
      throw result;
    }
    return result;
  });
}
function pollTillDefinedAndReturnIntervalId2(func, interval) {
  let intervalId;
  const polledRes = new Promise((resolve, reject) => {
    intervalId = setInterval(
      function intervalCallbackFunc() {
        (() => __awaiter15(this, void 0, void 0, function* () {
          try {
            const res = yield waitWithTimeout2(func, interval);
            if (!isNullish(res)) {
              clearInterval(intervalId);
              resolve(res);
            }
          } catch (error) {
            clearInterval(intervalId);
            reject(error);
          }
        }))();
        return intervalCallbackFunc;
      }(),
      interval
    );
  });
  return [polledRes, intervalId];
}
function rejectIfTimeout2(timeout, error) {
  let timeoutId;
  const rejectOnTimeout = new Promise((_, reject) => {
    timeoutId = setTimeout(() => {
      reject(error);
    }, timeout);
  });
  return [timeoutId, rejectOnTimeout];
}
function rejectIfConditionAtInterval2(cond, interval) {
  let intervalId;
  const rejectIfCondition = new Promise((_, reject) => {
    intervalId = setInterval(() => {
      (() => __awaiter15(this, void 0, void 0, function* () {
        const error = yield cond();
        if (error) {
          clearInterval(intervalId);
          reject(error);
        }
      }))();
    }, interval);
  });
  return [intervalId, rejectIfCondition];
}

// node_modules/web3-eth/node_modules/web3-utils/lib/esm/json_rpc.js
var json_rpc_exports2 = {};
__export(json_rpc_exports2, {
  isBatchRequest: () => isBatchRequest2,
  isBatchResponse: () => isBatchResponse2,
  isResponseRpcError: () => isResponseRpcError2,
  isResponseWithError: () => isResponseWithError3,
  isResponseWithNotification: () => isResponseWithNotification2,
  isResponseWithResult: () => isResponseWithResult2,
  isSubscriptionResult: () => isSubscriptionResult2,
  isValidResponse: () => isValidResponse2,
  setRequestIdStart: () => setRequestIdStart2,
  toBatchPayload: () => toBatchPayload2,
  toPayload: () => toPayload2,
  validateResponse: () => validateResponse2
});
init_shim();

// node_modules/web3-eth/node_modules/web3-utils/lib/esm/uuid.js
init_shim();
var uuidV42 = () => {
  const bytes = randomBytes3(16);
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 63 | 128;
  const hexString = bytesToHex3(bytes);
  return [
    hexString.substring(2, 10),
    hexString.substring(10, 14),
    hexString.substring(14, 18),
    hexString.substring(18, 22),
    hexString.substring(22, 34)
  ].join("-");
};

// node_modules/web3-eth/node_modules/web3-utils/lib/esm/json_rpc.js
var isResponseRpcError2 = (rpcError) => {
  const errorCode = rpcError.error.code;
  return rpcErrorsMap.has(errorCode) || errorCode >= -32099 && errorCode <= -32e3;
};
var isResponseWithResult2 = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && "result" in response && isNullish(response.error) && (typeof response.id === "number" || typeof response.id === "string");
var isResponseWithError3 = (response) => !Array.isArray(response) && response.jsonrpc === "2.0" && !!response && isNullish(response.result) && "error" in response && (typeof response.id === "number" || typeof response.id === "string");
var isResponseWithNotification2 = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && !isNullish(response.params) && !isNullish(response.method);
var isSubscriptionResult2 = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && "id" in response && "result" in response;
var validateResponse2 = (response) => isResponseWithResult2(response) || isResponseWithError3(response);
var isValidResponse2 = (response) => Array.isArray(response) ? response.every(validateResponse2) : validateResponse2(response);
var isBatchResponse2 = (response) => Array.isArray(response) && response.length > 0 && isValidResponse2(response);
var requestIdSeed2;
var setRequestIdStart2 = (start) => {
  requestIdSeed2 = start;
};
var toPayload2 = (request) => {
  var _a16, _b, _c, _d;
  if (typeof requestIdSeed2 !== "undefined") {
    requestIdSeed2 += 1;
  }
  return {
    jsonrpc: (_a16 = request.jsonrpc) !== null && _a16 !== void 0 ? _a16 : "2.0",
    id: (_c = (_b = request.id) !== null && _b !== void 0 ? _b : requestIdSeed2) !== null && _c !== void 0 ? _c : uuidV42(),
    method: request.method,
    params: (_d = request.params) !== null && _d !== void 0 ? _d : void 0
  };
};
var toBatchPayload2 = (requests) => requests.map((request) => toPayload2(request));
var isBatchRequest2 = (request) => Array.isArray(request) && request.length > 0;

// node_modules/web3-eth/node_modules/web3-utils/lib/esm/web3_deferred_promise.js
init_shim();
var __awaiter16 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a3;
var Web3DeferredPromise2 = class {
  constructor({ timeout, eagerStart, timeoutMessage } = {
    timeout: 0,
    eagerStart: false,
    timeoutMessage: "DeferredPromise timed out"
  }) {
    this[_a3] = "Promise";
    this._state = "pending";
    this._promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
    this._timeoutMessage = timeoutMessage;
    this._timeoutInterval = timeout;
    if (eagerStart) {
      this.startTimer();
    }
  }
  get state() {
    return this._state;
  }
  then(onfulfilled, onrejected) {
    return __awaiter16(this, void 0, void 0, function* () {
      return this._promise.then(onfulfilled, onrejected);
    });
  }
  catch(onrejected) {
    return __awaiter16(this, void 0, void 0, function* () {
      return this._promise.catch(onrejected);
    });
  }
  finally(onfinally) {
    return __awaiter16(this, void 0, void 0, function* () {
      return this._promise.finally(onfinally);
    });
  }
  resolve(value) {
    this._resolve(value);
    this._state = "fulfilled";
    this._clearTimeout();
  }
  reject(reason) {
    this._reject(reason);
    this._state = "rejected";
    this._clearTimeout();
  }
  startTimer() {
    if (this._timeoutInterval && this._timeoutInterval > 0) {
      this._timeoutId = setTimeout(this._checkTimeout.bind(this), this._timeoutInterval);
    }
  }
  _checkTimeout() {
    if (this._state === "pending" && this._timeoutId) {
      this.reject(new OperationTimeoutError(this._timeoutMessage));
    }
  }
  _clearTimeout() {
    if (this._timeoutId) {
      clearTimeout(this._timeoutId);
    }
  }
};
_a3 = Symbol.toStringTag;

// node_modules/web3-eth/node_modules/web3-utils/lib/esm/chunk_response_parser.js
init_shim();
var ChunkResponseParser2 = class {
  constructor(eventEmitter, autoReconnect) {
    this.eventEmitter = eventEmitter;
    this.autoReconnect = autoReconnect;
  }
  clearQueues() {
    if (typeof this._clearQueues === "function") {
      this._clearQueues();
    }
  }
  onError(clearQueues) {
    this._clearQueues = clearQueues;
  }
  parseResponse(data) {
    const returnValues = [];
    const dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
    dechunkedData.forEach((_chunkData) => {
      let chunkData = _chunkData;
      if (this.lastChunk) {
        chunkData = this.lastChunk + chunkData;
      }
      let result;
      try {
        result = JSON.parse(chunkData);
      } catch (e) {
        this.lastChunk = chunkData;
        if (this.lastChunkTimeout) {
          clearTimeout(this.lastChunkTimeout);
        }
        this.lastChunkTimeout = setTimeout(() => {
          if (this.autoReconnect)
            return;
          this.clearQueues();
          this.eventEmitter.emit("error", new InvalidResponseError({
            id: 1,
            jsonrpc: "2.0",
            error: { code: 2, message: "Chunk timeout" }
          }));
        }, 1e3 * 15);
        return;
      }
      clearTimeout(this.lastChunkTimeout);
      this.lastChunk = void 0;
      if (result)
        returnValues.push(result);
    });
    return returnValues;
  }
};

// node_modules/web3-eth/node_modules/web3-utils/lib/esm/web3_eip1193_provider.js
init_shim();
var import_events4 = __toESM(require_events(), 1);
var __awaiter17 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Eip1193Provider2 = class extends Web3BaseProvider {
  constructor() {
    super(...arguments);
    this._eventEmitter = new import_events4.EventEmitter();
    this._chainId = "";
    this._accounts = [];
  }
  _getChainId() {
    var _a16;
    return __awaiter17(this, void 0, void 0, function* () {
      const data = yield this.request(toPayload2({
        method: "eth_chainId",
        params: []
      }));
      return (_a16 = data === null || data === void 0 ? void 0 : data.result) !== null && _a16 !== void 0 ? _a16 : "";
    });
  }
  _getAccounts() {
    var _a16;
    return __awaiter17(this, void 0, void 0, function* () {
      const data = yield this.request(toPayload2({
        method: "eth_accounts",
        params: []
      }));
      return (_a16 = data === null || data === void 0 ? void 0 : data.result) !== null && _a16 !== void 0 ? _a16 : [];
    });
  }
  _onConnect() {
    Promise.all([
      this._getChainId().then((chainId) => {
        if (chainId !== this._chainId) {
          this._chainId = chainId;
          this._eventEmitter.emit("chainChanged", this._chainId);
        }
      }).catch((err) => {
        console.error(err);
      }),
      this._getAccounts().then((accounts) => {
        if (!(this._accounts.length === accounts.length && accounts.every((v) => accounts.includes(v)))) {
          this._accounts = accounts;
          this._onAccountsChanged();
        }
      }).catch((err) => {
        console.error(err);
      })
    ]).then(() => this._eventEmitter.emit("connect", {
      chainId: this._chainId
    })).catch((err) => {
      console.error(err);
    });
  }
  _onDisconnect(code, data) {
    this._eventEmitter.emit("disconnect", new EIP1193ProviderRpcError(code, data));
  }
  _onAccountsChanged() {
    this._eventEmitter.emit("accountsChanged", this._accounts);
  }
};

// node_modules/web3-eth/node_modules/web3-utils/lib/esm/socket_provider.js
init_shim();
var __awaiter18 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_RECONNECTION_OPTIONS2 = {
  autoReconnect: true,
  delay: 5e3,
  maxAttempts: 5
};
var NORMAL_CLOSE_CODE2 = 1e3;
var SocketProvider2 = class extends Eip1193Provider2 {
  constructor(socketPath, socketOptions, reconnectOptions) {
    super();
    this._connectionStatus = "connecting";
    this._onMessageHandler = this._onMessage.bind(this);
    this._onOpenHandler = this._onConnect.bind(this);
    this._onCloseHandler = this._onCloseEvent.bind(this);
    this._onErrorHandler = this._onError.bind(this);
    if (!this._validateProviderPath(socketPath))
      throw new InvalidClientError(socketPath);
    this._socketPath = socketPath;
    this._socketOptions = socketOptions;
    this._reconnectOptions = Object.assign(Object.assign({}, DEFAULT_RECONNECTION_OPTIONS2), reconnectOptions !== null && reconnectOptions !== void 0 ? reconnectOptions : {});
    this._pendingRequestsQueue = /* @__PURE__ */ new Map();
    this._sentRequestsQueue = /* @__PURE__ */ new Map();
    this._init();
    this.connect();
    this.chunkResponseParser = new ChunkResponseParser2(this._eventEmitter, this._reconnectOptions.autoReconnect);
    this.chunkResponseParser.onError(() => {
      this._clearQueues();
    });
    this.isReconnecting = false;
  }
  get SocketConnection() {
    return this._socketConnection;
  }
  _init() {
    this._reconnectAttempts = 0;
  }
  connect() {
    try {
      this._openSocketConnection();
      this._connectionStatus = "connecting";
      this._addSocketListeners();
    } catch (e) {
      if (!this.isReconnecting) {
        this._connectionStatus = "disconnected";
        if (e && e.message) {
          throw new ConnectionError(`Error while connecting to ${this._socketPath}. Reason: ${e.message}`);
        } else {
          throw new InvalidClientError(this._socketPath);
        }
      } else {
        setImmediate(() => {
          this._reconnect();
        });
      }
    }
  }
  _validateProviderPath(path) {
    return !!path;
  }
  supportsSubscriptions() {
    return true;
  }
  on(type, listener) {
    this._eventEmitter.on(type, listener);
  }
  once(type, listener) {
    this._eventEmitter.once(type, listener);
  }
  removeListener(type, listener) {
    this._eventEmitter.removeListener(type, listener);
  }
  _onDisconnect(code, data) {
    this._connectionStatus = "disconnected";
    super._onDisconnect(code, data);
  }
  disconnect(code, data) {
    const disconnectCode = code !== null && code !== void 0 ? code : NORMAL_CLOSE_CODE2;
    this._removeSocketListeners();
    if (this.getStatus() !== "disconnected") {
      this._closeSocketConnection(disconnectCode, data);
    }
    this._onDisconnect(disconnectCode, data);
  }
  removeAllListeners(type) {
    this._eventEmitter.removeAllListeners(type);
  }
  _onError(event) {
    if (this.isReconnecting) {
      this._reconnect();
    } else {
      this._eventEmitter.emit("error", event);
    }
  }
  reset() {
    this._sentRequestsQueue.clear();
    this._pendingRequestsQueue.clear();
    this._init();
    this._removeSocketListeners();
    this._addSocketListeners();
  }
  _reconnect() {
    if (this.isReconnecting) {
      return;
    }
    this.isReconnecting = true;
    if (this._sentRequestsQueue.size > 0) {
      this._sentRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new PendingRequestsOnReconnectingError());
        this._sentRequestsQueue.delete(key);
      });
    }
    if (this._reconnectAttempts < this._reconnectOptions.maxAttempts) {
      this._reconnectAttempts += 1;
      setTimeout(() => {
        this._removeSocketListeners();
        this.connect();
        this.isReconnecting = false;
      }, this._reconnectOptions.delay);
    } else {
      this.isReconnecting = false;
      this._clearQueues();
      this._removeSocketListeners();
      this._eventEmitter.emit("error", new MaxAttemptsReachedOnReconnectingError(this._reconnectOptions.maxAttempts));
    }
  }
  request(request) {
    return __awaiter18(this, void 0, void 0, function* () {
      if (isNullish3(this._socketConnection)) {
        throw new Error("Connection is undefined");
      }
      if (this.getStatus() === "disconnected") {
        this.connect();
      }
      const requestId = isBatchRequest2(request) ? request[0].id : request.id;
      if (!requestId) {
        throw new Web3WSProviderError("Request Id not defined");
      }
      if (this._sentRequestsQueue.has(requestId)) {
        throw new RequestAlreadySentError(requestId);
      }
      const deferredPromise = new Web3DeferredPromise2();
      deferredPromise.catch((error) => {
        this._eventEmitter.emit("error", error);
      });
      const reqItem = {
        payload: request,
        deferredPromise
      };
      if (this.getStatus() === "connecting") {
        this._pendingRequestsQueue.set(requestId, reqItem);
        return reqItem.deferredPromise;
      }
      this._sentRequestsQueue.set(requestId, reqItem);
      try {
        this._sendToSocket(reqItem.payload);
      } catch (error) {
        this._sentRequestsQueue.delete(requestId);
        this._eventEmitter.emit("error", error);
      }
      return deferredPromise;
    });
  }
  _onConnect() {
    this._connectionStatus = "connected";
    this._reconnectAttempts = 0;
    super._onConnect();
    this._sendPendingRequests();
  }
  _sendPendingRequests() {
    for (const [id, value] of this._pendingRequestsQueue.entries()) {
      this._sendToSocket(value.payload);
      this._pendingRequestsQueue.delete(id);
      this._sentRequestsQueue.set(id, value);
    }
  }
  _onMessage(event) {
    const responses = this._parseResponses(event);
    if (isNullish3(responses) || responses.length === 0) {
      return;
    }
    for (const response of responses) {
      if (isResponseWithNotification2(response) && response.method.endsWith("_subscription")) {
        this._eventEmitter.emit("message", response);
        return;
      }
      const requestId = isBatchResponse2(response) ? response[0].id : response.id;
      const requestItem = this._sentRequestsQueue.get(requestId);
      if (!requestItem) {
        return;
      }
      if (isBatchResponse2(response) || isResponseWithResult2(response) || isResponseWithError3(response)) {
        this._eventEmitter.emit("message", response);
        requestItem.deferredPromise.resolve(response);
      }
      this._sentRequestsQueue.delete(requestId);
    }
  }
  _clearQueues(event) {
    if (this._pendingRequestsQueue.size > 0) {
      this._pendingRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new ConnectionNotOpenError(event));
        this._pendingRequestsQueue.delete(key);
      });
    }
    if (this._sentRequestsQueue.size > 0) {
      this._sentRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new ConnectionNotOpenError(event));
        this._sentRequestsQueue.delete(key);
      });
    }
    this._removeSocketListeners();
  }
};

// node_modules/web3-eth/node_modules/web3-core/lib/esm/web3_event_emitter.js
init_shim();
var Web3EventEmitter2 = class {
  constructor() {
    this._emitter = new EventEmitter3();
  }
  on(eventName, fn) {
    this._emitter.on(eventName, fn);
  }
  once(eventName, fn) {
    this._emitter.once(eventName, fn);
  }
  off(eventName, fn) {
    this._emitter.off(eventName, fn);
  }
  emit(eventName, params) {
    this._emitter.emit(eventName, params);
  }
  listenerCount(eventName) {
    return this._emitter.listenerCount(eventName);
  }
  listeners(eventName) {
    return this._emitter.listeners(eventName);
  }
  eventNames() {
    return this._emitter.eventNames();
  }
  removeAllListeners() {
    return this._emitter.removeAllListeners();
  }
  setMaxListenerWarningThreshold(maxListenersWarningThreshold) {
    this._emitter.setMaxListeners(maxListenersWarningThreshold);
  }
  getMaxListeners() {
    return this._emitter.getMaxListeners();
  }
};

// node_modules/web3-eth/node_modules/web3-core/lib/esm/web3_config.js
var Web3ConfigEvent2;
(function(Web3ConfigEvent7) {
  Web3ConfigEvent7["CONFIG_CHANGE"] = "CONFIG_CHANGE";
})(Web3ConfigEvent2 || (Web3ConfigEvent2 = {}));
var Web3Config2 = class extends Web3EventEmitter2 {
  constructor(options) {
    super();
    this.config = {
      handleRevert: false,
      defaultAccount: void 0,
      defaultBlock: "latest",
      transactionBlockTimeout: 50,
      transactionConfirmationBlocks: 24,
      transactionPollingInterval: 1e3,
      transactionPollingTimeout: 750 * 1e3,
      transactionReceiptPollingInterval: void 0,
      transactionSendTimeout: 750 * 1e3,
      transactionConfirmationPollingInterval: void 0,
      blockHeaderTimeout: 10,
      maxListenersWarningThreshold: 100,
      contractDataInputFill: "input",
      defaultNetworkId: void 0,
      defaultChain: "mainnet",
      defaultHardfork: "london",
      defaultCommon: void 0,
      defaultTransactionType: "0x2",
      defaultMaxPriorityFeePerGas: toHex2(25e8),
      enableExperimentalFeatures: {
        useSubscriptionWhenCheckingBlockTimeout: false,
        useRpcCallSpecification: false
      },
      transactionBuilder: void 0,
      transactionTypeParser: void 0
    };
    this.setConfig(options !== null && options !== void 0 ? options : {});
  }
  setConfig(options) {
    Object.assign(this.config, options);
  }
  get handleRevert() {
    return this.config.handleRevert;
  }
  set handleRevert(val) {
    this._triggerConfigChange("handleRevert", val);
    this.config.handleRevert = val;
  }
  get contractDataInputFill() {
    return this.config.contractDataInputFill;
  }
  set contractDataInputFill(val) {
    this._triggerConfigChange("contractDataInputFill", val);
    this.config.contractDataInputFill = val;
  }
  get defaultAccount() {
    return this.config.defaultAccount;
  }
  set defaultAccount(val) {
    this._triggerConfigChange("defaultAccount", val);
    this.config.defaultAccount = val;
  }
  get defaultBlock() {
    return this.config.defaultBlock;
  }
  set defaultBlock(val) {
    this._triggerConfigChange("defaultBlock", val);
    this.config.defaultBlock = val;
  }
  get transactionSendTimeout() {
    return this.config.transactionSendTimeout;
  }
  set transactionSendTimeout(val) {
    this._triggerConfigChange("transactionSendTimeout", val);
    this.config.transactionSendTimeout = val;
  }
  get transactionBlockTimeout() {
    return this.config.transactionBlockTimeout;
  }
  set transactionBlockTimeout(val) {
    this._triggerConfigChange("transactionBlockTimeout", val);
    this.config.transactionBlockTimeout = val;
  }
  get transactionConfirmationBlocks() {
    return this.config.transactionConfirmationBlocks;
  }
  set transactionConfirmationBlocks(val) {
    this._triggerConfigChange("transactionConfirmationBlocks", val);
    this.config.transactionConfirmationBlocks = val;
  }
  get transactionPollingInterval() {
    return this.config.transactionPollingInterval;
  }
  set transactionPollingInterval(val) {
    this._triggerConfigChange("transactionPollingInterval", val);
    this.config.transactionPollingInterval = val;
    this.transactionReceiptPollingInterval = val;
    this.transactionConfirmationPollingInterval = val;
  }
  get transactionPollingTimeout() {
    return this.config.transactionPollingTimeout;
  }
  set transactionPollingTimeout(val) {
    this._triggerConfigChange("transactionPollingTimeout", val);
    this.config.transactionPollingTimeout = val;
  }
  get transactionReceiptPollingInterval() {
    return this.config.transactionReceiptPollingInterval;
  }
  set transactionReceiptPollingInterval(val) {
    this._triggerConfigChange("transactionReceiptPollingInterval", val);
    this.config.transactionReceiptPollingInterval = val;
  }
  get transactionConfirmationPollingInterval() {
    return this.config.transactionConfirmationPollingInterval;
  }
  set transactionConfirmationPollingInterval(val) {
    this._triggerConfigChange("transactionConfirmationPollingInterval", val);
    this.config.transactionConfirmationPollingInterval = val;
  }
  get blockHeaderTimeout() {
    return this.config.blockHeaderTimeout;
  }
  set blockHeaderTimeout(val) {
    this._triggerConfigChange("blockHeaderTimeout", val);
    this.config.blockHeaderTimeout = val;
  }
  get enableExperimentalFeatures() {
    return this.config.enableExperimentalFeatures;
  }
  set enableExperimentalFeatures(val) {
    this._triggerConfigChange("enableExperimentalFeatures", val);
    this.config.enableExperimentalFeatures = val;
  }
  get maxListenersWarningThreshold() {
    return this.config.maxListenersWarningThreshold;
  }
  set maxListenersWarningThreshold(val) {
    this._triggerConfigChange("maxListenersWarningThreshold", val);
    this.setMaxListenerWarningThreshold(val);
    this.config.maxListenersWarningThreshold = val;
  }
  get defaultNetworkId() {
    return this.config.defaultNetworkId;
  }
  set defaultNetworkId(val) {
    this._triggerConfigChange("defaultNetworkId", val);
    this.config.defaultNetworkId = val;
  }
  get defaultChain() {
    return this.config.defaultChain;
  }
  set defaultChain(val) {
    if (!isNullish3(this.config.defaultCommon) && !isNullish3(this.config.defaultCommon.baseChain) && val !== this.config.defaultCommon.baseChain)
      throw new ConfigChainMismatchError(this.config.defaultChain, val);
    this._triggerConfigChange("defaultChain", val);
    this.config.defaultChain = val;
  }
  get defaultHardfork() {
    return this.config.defaultHardfork;
  }
  set defaultHardfork(val) {
    if (!isNullish3(this.config.defaultCommon) && !isNullish3(this.config.defaultCommon.hardfork) && val !== this.config.defaultCommon.hardfork)
      throw new ConfigHardforkMismatchError(this.config.defaultCommon.hardfork, val);
    this._triggerConfigChange("defaultHardfork", val);
    this.config.defaultHardfork = val;
  }
  get defaultCommon() {
    return this.config.defaultCommon;
  }
  set defaultCommon(val) {
    if (!isNullish3(this.config.defaultHardfork) && !isNullish3(val) && !isNullish3(val.hardfork) && this.config.defaultHardfork !== val.hardfork)
      throw new ConfigHardforkMismatchError(this.config.defaultHardfork, val.hardfork);
    if (!isNullish3(this.config.defaultChain) && !isNullish3(val) && !isNullish3(val.baseChain) && this.config.defaultChain !== val.baseChain)
      throw new ConfigChainMismatchError(this.config.defaultChain, val.baseChain);
    this._triggerConfigChange("defaultCommon", val);
    this.config.defaultCommon = val;
  }
  get defaultTransactionType() {
    return this.config.defaultTransactionType;
  }
  set defaultTransactionType(val) {
    this._triggerConfigChange("defaultTransactionType", val);
    this.config.defaultTransactionType = val;
  }
  get defaultMaxPriorityFeePerGas() {
    return this.config.defaultMaxPriorityFeePerGas;
  }
  set defaultMaxPriorityFeePerGas(val) {
    this._triggerConfigChange("defaultMaxPriorityFeePerGas", val);
    this.config.defaultMaxPriorityFeePerGas = val;
  }
  get transactionBuilder() {
    return this.config.transactionBuilder;
  }
  set transactionBuilder(val) {
    this._triggerConfigChange("transactionBuilder", val);
    this.config.transactionBuilder = val;
  }
  get transactionTypeParser() {
    return this.config.transactionTypeParser;
  }
  set transactionTypeParser(val) {
    this._triggerConfigChange("transactionTypeParser", val);
    this.config.transactionTypeParser = val;
  }
  _triggerConfigChange(config, newValue) {
    this.emit(Web3ConfigEvent2.CONFIG_CHANGE, {
      name: config,
      oldValue: this.config[config],
      newValue
    });
  }
};

// node_modules/web3-eth/node_modules/web3-core/lib/esm/web3_request_manager.js
init_shim();

// node_modules/web3-eth/node_modules/web3-providers-http/lib/esm/index.js
init_shim();
var import_cross_fetch2 = __toESM(require_browser_ponyfill2());
var __awaiter19 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var HttpProvider2 = class extends Web3BaseProvider {
  constructor(clientUrl, httpProviderOptions) {
    super();
    if (!HttpProvider2.validateClientUrl(clientUrl))
      throw new InvalidClientError(clientUrl);
    this.clientUrl = clientUrl;
    this.httpProviderOptions = httpProviderOptions;
  }
  static validateClientUrl(clientUrl) {
    return typeof clientUrl === "string" ? /^http(s)?:\/\//i.test(clientUrl) : false;
  }
  getStatus() {
    throw new MethodNotImplementedError();
  }
  supportsSubscriptions() {
    return false;
  }
  request(payload, requestOptions) {
    var _a16;
    return __awaiter19(this, void 0, void 0, function* () {
      const providerOptionsCombined = Object.assign(Object.assign({}, (_a16 = this.httpProviderOptions) === null || _a16 === void 0 ? void 0 : _a16.providerOptions), requestOptions);
      const response = yield (0, import_cross_fetch2.default)(this.clientUrl, Object.assign(Object.assign({}, providerOptionsCombined), { method: "POST", headers: Object.assign(Object.assign({}, providerOptionsCombined.headers), { "Content-Type": "application/json" }), body: JSON.stringify(payload) }));
      if (!response.ok)
        throw new ResponseError(yield response.json());
      return yield response.json();
    });
  }
  on() {
    throw new MethodNotImplementedError();
  }
  removeListener() {
    throw new MethodNotImplementedError();
  }
  once() {
    throw new MethodNotImplementedError();
  }
  removeAllListeners() {
    throw new MethodNotImplementedError();
  }
  connect() {
    throw new MethodNotImplementedError();
  }
  disconnect() {
    throw new MethodNotImplementedError();
  }
  reset() {
    throw new MethodNotImplementedError();
  }
  reconnect() {
    throw new MethodNotImplementedError();
  }
};

// node_modules/web3-eth/node_modules/web3-providers-ws/lib/esm/index.js
init_shim();

// node_modules/web3-eth/node_modules/isomorphic-ws/browser.js
init_shim();
var ws2 = null;
if (typeof WebSocket !== "undefined") {
  ws2 = WebSocket;
} else if (typeof MozWebSocket !== "undefined") {
  ws2 = MozWebSocket;
} else if (typeof _global !== "undefined") {
  ws2 = _global.WebSocket || _global.MozWebSocket;
} else if (typeof window !== "undefined") {
  ws2 = window.WebSocket || window.MozWebSocket;
} else if (typeof self !== "undefined") {
  ws2 = self.WebSocket || self.MozWebSocket;
}
var browser_default2 = ws2;

// node_modules/web3-eth/node_modules/web3-providers-ws/lib/esm/index.js
var WebSocketProvider2 = class extends SocketProvider2 {
  constructor(socketPath, socketOptions, reconnectOptions) {
    super(socketPath, socketOptions, reconnectOptions);
  }
  _validateProviderPath(providerUrl) {
    return typeof providerUrl === "string" ? /^ws(s)?:\/\//i.test(providerUrl) : false;
  }
  getStatus() {
    if (this._socketConnection && !isNullish3(this._socketConnection)) {
      switch (this._socketConnection.readyState) {
        case this._socketConnection.CONNECTING: {
          return "connecting";
        }
        case this._socketConnection.OPEN: {
          return "connected";
        }
        default: {
          return "disconnected";
        }
      }
    }
    return "disconnected";
  }
  _openSocketConnection() {
    this._socketConnection = new browser_default2(this._socketPath, void 0, this._socketOptions && Object.keys(this._socketOptions).length === 0 ? void 0 : this._socketOptions);
  }
  _closeSocketConnection(code, data) {
    var _a16;
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.close(code, data);
  }
  _sendToSocket(payload) {
    var _a16;
    if (this.getStatus() === "disconnected") {
      throw new ConnectionNotOpenError();
    }
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.send(JSON.stringify(payload));
  }
  _parseResponses(event) {
    return this.chunkResponseParser.parseResponse(event.data);
  }
  _addSocketListeners() {
    var _a16, _b, _c, _d;
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.addEventListener("open", this._onOpenHandler);
    (_b = this._socketConnection) === null || _b === void 0 ? void 0 : _b.addEventListener("message", this._onMessageHandler);
    (_c = this._socketConnection) === null || _c === void 0 ? void 0 : _c.addEventListener("close", (e) => this._onCloseHandler(e));
    (_d = this._socketConnection) === null || _d === void 0 ? void 0 : _d.addEventListener("error", this._onErrorHandler);
  }
  _removeSocketListeners() {
    var _a16, _b, _c;
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.removeEventListener("message", this._onMessageHandler);
    (_b = this._socketConnection) === null || _b === void 0 ? void 0 : _b.removeEventListener("open", this._onOpenHandler);
    (_c = this._socketConnection) === null || _c === void 0 ? void 0 : _c.removeEventListener("close", this._onCloseHandler);
  }
  _onCloseEvent(event) {
    var _a16;
    if (this._reconnectOptions.autoReconnect && (![1e3, 1001].includes(event.code) || !event.wasClean)) {
      this._reconnect();
      return;
    }
    this._clearQueues(event);
    this._removeSocketListeners();
    this._onDisconnect(event.code, event.reason);
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.removeEventListener("error", this._onErrorHandler);
  }
};

// node_modules/web3-eth/node_modules/web3-core/lib/esm/utils.js
init_shim();
var isWeb3Provider2 = (provider) => Web3BaseProvider.isWeb3Provider(provider);
var isMetaMaskProvider2 = (provider) => typeof provider !== "string" && "request" in provider && provider.request.constructor.name === "AsyncFunction" && "isMetaMask" in provider && provider.isMetaMask;
var isLegacyRequestProvider2 = (provider) => typeof provider !== "string" && "request" in provider && provider.request.constructor.name === "Function";
var isEIP1193Provider2 = (provider) => typeof provider !== "string" && "request" in provider && provider.request.constructor.name === "AsyncFunction";
var isLegacySendProvider2 = (provider) => typeof provider !== "string" && "send" in provider;
var isLegacySendAsyncProvider2 = (provider) => typeof provider !== "string" && "sendAsync" in provider;
var isSupportedProvider2 = (provider) => provider && (isWeb3Provider2(provider) || isEIP1193Provider2(provider) || isLegacyRequestProvider2(provider) || isLegacySendAsyncProvider2(provider) || isLegacySendProvider2(provider));
var isSupportSubscriptions2 = (provider) => {
  if (provider && "supportsSubscriptions" in provider) {
    return provider.supportsSubscriptions();
  }
  if (provider && typeof provider !== "string" && "on" in provider) {
    return true;
  }
  return false;
};

// node_modules/web3-eth/node_modules/web3-core/lib/esm/web3_request_manager.js
var __awaiter20 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3RequestManagerEvent2;
(function(Web3RequestManagerEvent7) {
  Web3RequestManagerEvent7["PROVIDER_CHANGED"] = "PROVIDER_CHANGED";
  Web3RequestManagerEvent7["BEFORE_PROVIDER_CHANGE"] = "BEFORE_PROVIDER_CHANGE";
})(Web3RequestManagerEvent2 || (Web3RequestManagerEvent2 = {}));
var availableProviders2 = {
  HttpProvider: HttpProvider2,
  WebsocketProvider: WebSocketProvider2
};
var metamaskPayload2 = (payload) => {
  var _a16;
  if (Array.isArray(payload.params)) {
    const params = payload.params[0];
    if (params.input && !params.data) {
      return Object.assign(Object.assign({}, payload), { params: [Object.assign(Object.assign({}, params), { data: (_a16 = params.data) !== null && _a16 !== void 0 ? _a16 : params.input })] });
    }
  }
  return payload;
};
var Web3RequestManager2 = class extends Web3EventEmitter2 {
  constructor(provider, useRpcCallSpecification) {
    super();
    if (!isNullish3(provider)) {
      this.setProvider(provider);
    }
    this.useRpcCallSpecification = useRpcCallSpecification;
  }
  static get providers() {
    return availableProviders2;
  }
  get provider() {
    return this._provider;
  }
  get providers() {
    return availableProviders2;
  }
  setProvider(provider) {
    let newProvider;
    if (provider && typeof provider === "string" && this.providers) {
      if (/^http(s)?:\/\//i.test(provider)) {
        newProvider = new this.providers.HttpProvider(provider);
      } else if (/^ws(s)?:\/\//i.test(provider)) {
        newProvider = new this.providers.WebsocketProvider(provider);
      } else {
        throw new ProviderError(`Can't autodetect provider for "${provider}"`);
      }
    } else if (isNullish3(provider)) {
      newProvider = void 0;
    } else {
      newProvider = provider;
    }
    this.emit(Web3RequestManagerEvent2.BEFORE_PROVIDER_CHANGE, this._provider);
    this._provider = newProvider;
    this.emit(Web3RequestManagerEvent2.PROVIDER_CHANGED, this._provider);
    return true;
  }
  send(request) {
    return __awaiter20(this, void 0, void 0, function* () {
      const response = yield this._sendRequest(request);
      if (json_rpc_exports2.isResponseWithResult(response)) {
        return response.result;
      }
      throw new ResponseError(response);
    });
  }
  sendBatch(request) {
    return __awaiter20(this, void 0, void 0, function* () {
      const response = yield this._sendRequest(request);
      return response;
    });
  }
  _sendRequest(request) {
    return __awaiter20(this, void 0, void 0, function* () {
      const { provider } = this;
      if (isNullish3(provider)) {
        throw new ProviderError("Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.");
      }
      let payload = json_rpc_exports2.isBatchRequest(request) ? json_rpc_exports2.toBatchPayload(request) : json_rpc_exports2.toPayload(request);
      if (isMetaMaskProvider2(provider)) {
        if (payload.method === "eth_sendTransaction") {
          if (!json_rpc_exports2.isBatchRequest(payload)) {
            payload = metamaskPayload2(payload);
          } else {
            payload = payload.map((p) => metamaskPayload2(p));
          }
        }
      }
      if (isWeb3Provider2(provider)) {
        let response;
        try {
          response = yield provider.request(payload);
        } catch (error) {
          response = error;
        }
        return this._processJsonRpcResponse(payload, response, { legacy: false, error: false });
      }
      if (isEIP1193Provider2(provider)) {
        return provider.request(payload).then((res) => this._processJsonRpcResponse(payload, res, {
          legacy: true,
          error: false
        })).catch((error) => this._processJsonRpcResponse(payload, error, { legacy: true, error: true }));
      }
      if (isLegacyRequestProvider2(provider)) {
        return new Promise((resolve, reject) => {
          const rejectWithError = (err) => reject(this._processJsonRpcResponse(payload, err, {
            legacy: true,
            error: true
          }));
          const resolveWithResponse = (response) => resolve(this._processJsonRpcResponse(payload, response, {
            legacy: true,
            error: false
          }));
          const result = provider.request(
            payload,
            (err, response) => {
              if (err) {
                return rejectWithError(err);
              }
              return resolveWithResponse(response);
            }
          );
          if (isPromise2(result)) {
            const responsePromise = result;
            responsePromise.then(resolveWithResponse).catch(rejectWithError);
          }
        });
      }
      if (isLegacySendProvider2(provider)) {
        return new Promise((resolve, reject) => {
          provider.send(payload, (err, response) => {
            if (err) {
              return reject(this._processJsonRpcResponse(payload, err, {
                legacy: true,
                error: true
              }));
            }
            if (isNullish3(response)) {
              throw new ResponseError("", 'Got a "nullish" response from provider.');
            }
            return resolve(this._processJsonRpcResponse(payload, response, {
              legacy: true,
              error: false
            }));
          });
        });
      }
      if (isLegacySendAsyncProvider2(provider)) {
        return provider.sendAsync(payload).then((response) => this._processJsonRpcResponse(payload, response, { legacy: true, error: false })).catch((error) => this._processJsonRpcResponse(payload, error, {
          legacy: true,
          error: true
        }));
      }
      throw new ProviderError("Provider does not have a request or send method to use.");
    });
  }
  _processJsonRpcResponse(payload, response, { legacy, error }) {
    if (isNullish3(response)) {
      return this._buildResponse(
        payload,
        null,
        error
      );
    }
    if (json_rpc_exports2.isResponseWithError(response)) {
      if (this.useRpcCallSpecification && isResponseRpcError2(response)) {
        const rpcErrorResponse = response;
        if (rpcErrorsMap.get(rpcErrorResponse.error.code)) {
          const Err = rpcErrorsMap.get(rpcErrorResponse.error.code).error;
          throw new Err(rpcErrorResponse);
        } else {
          throw new RpcError(rpcErrorResponse);
        }
      } else if (!Web3RequestManager2._isReverted(response)) {
        throw new InvalidResponseError(response, payload);
      }
    }
    if (json_rpc_exports2.isResponseWithResult(response)) {
      return response;
    }
    if (response instanceof Error) {
      Web3RequestManager2._isReverted(response);
      throw response;
    }
    if (!legacy && json_rpc_exports2.isBatchRequest(payload) && json_rpc_exports2.isBatchResponse(response)) {
      return response;
    }
    if (legacy && !error && json_rpc_exports2.isBatchRequest(payload)) {
      return response;
    }
    if (legacy && error && json_rpc_exports2.isBatchRequest(payload)) {
      throw response;
    }
    if (legacy && !json_rpc_exports2.isResponseWithError(response) && !json_rpc_exports2.isResponseWithResult(response)) {
      return this._buildResponse(payload, response, error);
    }
    if (json_rpc_exports2.isBatchRequest(payload) && !Array.isArray(response)) {
      throw new ResponseError(response, "Got normal response for a batch request.");
    }
    if (!json_rpc_exports2.isBatchRequest(payload) && Array.isArray(response)) {
      throw new ResponseError(response, "Got batch response for a normal request.");
    }
    if ((json_rpc_exports2.isResponseWithError(response) || json_rpc_exports2.isResponseWithResult(response)) && !json_rpc_exports2.isBatchRequest(payload)) {
      if (response.id && payload.id !== response.id) {
        throw new InvalidResponseError(response);
      }
    }
    throw new ResponseError(response, "Invalid response");
  }
  static _isReverted(response) {
    let error;
    if (json_rpc_exports2.isResponseWithError(response)) {
      error = response.error;
    } else if (response instanceof Error) {
      error = response;
    }
    if (error === null || error === void 0 ? void 0 : error.message.includes("revert"))
      throw new ContractExecutionError(error);
    return false;
  }
  _buildResponse(payload, response, error) {
    const res = {
      jsonrpc: "2.0",
      id: json_rpc_exports2.isBatchRequest(payload) ? payload[0].id : "id" in payload ? payload.id : null
    };
    if (error) {
      return Object.assign(Object.assign({}, res), { error: response });
    }
    return Object.assign(Object.assign({}, res), { result: response });
  }
};

// node_modules/web3-eth/node_modules/web3-core/lib/esm/web3_subscription_manager.js
init_shim();
var __awaiter21 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3SubscriptionManager2 = class {
  constructor(requestManager, registeredSubscriptions2, tolerateUnlinkedSubscription = false) {
    this.requestManager = requestManager;
    this.registeredSubscriptions = registeredSubscriptions2;
    this.tolerateUnlinkedSubscription = tolerateUnlinkedSubscription;
    this._subscriptions = /* @__PURE__ */ new Map();
    this.requestManager.on(Web3RequestManagerEvent2.BEFORE_PROVIDER_CHANGE, () => __awaiter21(this, void 0, void 0, function* () {
      yield this.unsubscribe();
    }));
    this.requestManager.on(Web3RequestManagerEvent2.PROVIDER_CHANGED, () => {
      this.clear();
      this.listenToProviderEvents();
    });
    this.listenToProviderEvents();
  }
  listenToProviderEvents() {
    const providerAsWebProvider = this.requestManager.provider;
    if (!this.requestManager.provider || typeof (providerAsWebProvider === null || providerAsWebProvider === void 0 ? void 0 : providerAsWebProvider.supportsSubscriptions) === "function" && !(providerAsWebProvider === null || providerAsWebProvider === void 0 ? void 0 : providerAsWebProvider.supportsSubscriptions())) {
      return;
    }
    if (typeof this.requestManager.provider.on === "function") {
      if (typeof this.requestManager.provider.request === "function") {
        this.requestManager.provider.on(
          "message",
          (message) => this.messageListener(message)
        );
      } else {
        providerAsWebProvider.on("data", (data) => this.messageListener(data));
      }
    }
  }
  messageListener(data) {
    var _a16, _b, _c;
    if (!data) {
      throw new SubscriptionError("Should not call messageListener with no data. Type was");
    }
    const subscriptionId = ((_a16 = data.params) === null || _a16 === void 0 ? void 0 : _a16.subscription) || ((_b = data.data) === null || _b === void 0 ? void 0 : _b.subscription) || ((_c = data.id) === null || _c === void 0 ? void 0 : _c.toString(16));
    if (subscriptionId) {
      const sub = this._subscriptions.get(subscriptionId);
      sub === null || sub === void 0 ? void 0 : sub.processSubscriptionData(data);
    }
  }
  subscribe(name2, args, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter21(this, void 0, void 0, function* () {
      const Klass = this.registeredSubscriptions[name2];
      if (!Klass) {
        throw new SubscriptionError("Invalid subscription type");
      }
      const subscription = new Klass(args !== null && args !== void 0 ? args : void 0, {
        subscriptionManager: this,
        returnFormat
      });
      yield this.addSubscription(subscription);
      return subscription;
    });
  }
  get subscriptions() {
    return this._subscriptions;
  }
  addSubscription(sub) {
    return __awaiter21(this, void 0, void 0, function* () {
      if (!this.requestManager.provider) {
        throw new ProviderError("Provider not available");
      }
      if (!this.supportsSubscriptions()) {
        throw new SubscriptionError("The current provider does not support subscriptions");
      }
      if (sub.id && this._subscriptions.has(sub.id)) {
        throw new SubscriptionError(`Subscription with id "${sub.id}" already exists`);
      }
      yield sub.sendSubscriptionRequest();
      if (isNullish3(sub.id)) {
        throw new SubscriptionError("Subscription is not subscribed yet.");
      }
      this._subscriptions.set(sub.id, sub);
      return sub.id;
    });
  }
  removeSubscription(sub) {
    return __awaiter21(this, void 0, void 0, function* () {
      const { id } = sub;
      if (isNullish3(id)) {
        throw new SubscriptionError("Subscription is not subscribed yet. Or, had already been unsubscribed but not through the Subscription Manager.");
      }
      if (!this._subscriptions.has(id) && !this.tolerateUnlinkedSubscription) {
        throw new SubscriptionError(`Subscription with id "${id.toString()}" does not exists`);
      }
      yield sub.sendUnsubscribeRequest();
      this._subscriptions.delete(id);
      return id;
    });
  }
  unsubscribe(condition) {
    return __awaiter21(this, void 0, void 0, function* () {
      const result = [];
      for (const [id, sub] of this.subscriptions.entries()) {
        if (!condition || typeof condition === "function" && condition({ id, sub })) {
          result.push(this.removeSubscription(sub));
        }
      }
      return Promise.all(result);
    });
  }
  clear() {
    this._subscriptions.clear();
  }
  supportsSubscriptions() {
    return isNullish3(this.requestManager.provider) ? false : isSupportSubscriptions2(this.requestManager.provider);
  }
};

// node_modules/web3-eth/node_modules/web3-core/lib/esm/web3_subscriptions.js
init_shim();
var __awaiter22 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3Subscription2 = class extends Web3EventEmitter2 {
  constructor(args, options) {
    var _a16;
    super();
    this.args = args;
    const { requestManager } = options;
    const { subscriptionManager } = options;
    if (requestManager && subscriptionManager) {
      throw new SubscriptionError("Only requestManager or subscriptionManager should be provided at Subscription constructor");
    }
    if (!requestManager && !subscriptionManager) {
      throw new SubscriptionError("Either requestManager or subscriptionManager should be provided at Subscription constructor");
    }
    if (requestManager) {
      this._subscriptionManager = new Web3SubscriptionManager2(requestManager, {}, true);
    } else {
      this._subscriptionManager = subscriptionManager;
    }
    this._returnFormat = (_a16 = options === null || options === void 0 ? void 0 : options.returnFormat) !== null && _a16 !== void 0 ? _a16 : DEFAULT_RETURN_FORMAT;
  }
  get id() {
    return this._id;
  }
  get lastBlock() {
    return this._lastBlock;
  }
  subscribe() {
    return __awaiter22(this, void 0, void 0, function* () {
      return this._subscriptionManager.addSubscription(this);
    });
  }
  processSubscriptionData(data) {
    var _a16, _b;
    if (data === null || data === void 0 ? void 0 : data.data) {
      this._processSubscriptionResult((_b = (_a16 = data === null || data === void 0 ? void 0 : data.data) === null || _a16 === void 0 ? void 0 : _a16.result) !== null && _b !== void 0 ? _b : data === null || data === void 0 ? void 0 : data.data);
    } else if (data && json_rpc_exports2.isResponseWithNotification(data)) {
      this._processSubscriptionResult(data === null || data === void 0 ? void 0 : data.params.result);
    }
  }
  sendSubscriptionRequest() {
    return __awaiter22(this, void 0, void 0, function* () {
      this._id = yield this._subscriptionManager.requestManager.send({
        method: "eth_subscribe",
        params: this._buildSubscriptionParams()
      });
      this.emit("connected", this._id);
      return this._id;
    });
  }
  get returnFormat() {
    return this._returnFormat;
  }
  get subscriptionManager() {
    return this._subscriptionManager;
  }
  resubscribe() {
    return __awaiter22(this, void 0, void 0, function* () {
      yield this.unsubscribe();
      yield this.subscribe();
    });
  }
  unsubscribe() {
    return __awaiter22(this, void 0, void 0, function* () {
      if (!this.id) {
        return;
      }
      yield this._subscriptionManager.removeSubscription(this);
    });
  }
  sendUnsubscribeRequest() {
    return __awaiter22(this, void 0, void 0, function* () {
      yield this._subscriptionManager.requestManager.send({
        method: "eth_unsubscribe",
        params: [this.id]
      });
      this._id = void 0;
    });
  }
  formatSubscriptionResult(data) {
    return data;
  }
  _processSubscriptionResult(data) {
    this.emit("data", this.formatSubscriptionResult(data));
  }
  _processSubscriptionError(error) {
    this.emit("error", error);
  }
  _buildSubscriptionParams() {
    throw new Error("Implement in the child class");
  }
};

// node_modules/web3-eth/node_modules/web3-core/lib/esm/web3_context.js
init_shim();

// node_modules/web3-eth/node_modules/web3-core/lib/esm/web3_batch_request.js
init_shim();
var __awaiter23 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_BATCH_REQUEST_TIMEOUT2 = 1e3;
var Web3BatchRequest2 = class {
  constructor(requestManager) {
    this._requestManager = requestManager;
    this._requests = /* @__PURE__ */ new Map();
  }
  get requests() {
    return [...this._requests.values()].map((r) => r.payload);
  }
  add(request) {
    const payload = json_rpc_exports2.toPayload(request);
    const promise = new Web3DeferredPromise2();
    this._requests.set(payload.id, { payload, promise });
    return promise;
  }
  execute(options) {
    var _a16;
    return __awaiter23(this, void 0, void 0, function* () {
      if (this.requests.length === 0) {
        return Promise.resolve([]);
      }
      const request = new Web3DeferredPromise2({
        timeout: (_a16 = options === null || options === void 0 ? void 0 : options.timeout) !== null && _a16 !== void 0 ? _a16 : DEFAULT_BATCH_REQUEST_TIMEOUT2,
        eagerStart: true,
        timeoutMessage: "Batch request timeout"
      });
      this._processBatchRequest(request).catch((err) => request.reject(err));
      request.catch((err) => {
        if (err instanceof OperationTimeoutError) {
          this._abortAllRequests("Batch request timeout");
        }
        request.reject(err);
      });
      return request;
    });
  }
  _processBatchRequest(promise) {
    var _a16, _b;
    return __awaiter23(this, void 0, void 0, function* () {
      const response = yield this._requestManager.sendBatch([...this._requests.values()].map((r) => r.payload));
      if (response.length !== this._requests.size) {
        this._abortAllRequests("Invalid batch response");
        throw new ResponseError(response, `Batch request size mismatch the results size. Requests: ${this._requests.size}, Responses: ${response.length}`);
      }
      const requestIds = this.requests.map((r) => r.id).map(Number).sort((a, b) => a - b);
      const responseIds = response.map((r) => r.id).map(Number).sort((a, b) => a - b);
      if (JSON.stringify(requestIds) !== JSON.stringify(responseIds)) {
        this._abortAllRequests("Invalid batch response");
        throw new ResponseError(response, `Batch request mismatch the results. Requests: [${requestIds.join()}], Responses: [${responseIds.join()}]`);
      }
      for (const res of response) {
        if (json_rpc_exports2.isResponseWithResult(res)) {
          (_a16 = this._requests.get(res.id)) === null || _a16 === void 0 ? void 0 : _a16.promise.resolve(res.result);
        } else if (json_rpc_exports2.isResponseWithError(res)) {
          (_b = this._requests.get(res.id)) === null || _b === void 0 ? void 0 : _b.promise.reject(res.error);
        }
      }
      promise.resolve(response);
    });
  }
  _abortAllRequests(msg) {
    for (const { promise } of this._requests.values()) {
      promise.reject(new OperationAbortError(msg));
    }
  }
};

// node_modules/web3-eth/node_modules/web3-core/lib/esm/web3_context.js
var __awaiter24 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3Context2 = class extends Web3Config2 {
  constructor(providerOrContext) {
    var _a16;
    super();
    this.providers = Web3RequestManager2.providers;
    if (isNullish3(providerOrContext) || typeof providerOrContext === "string" && providerOrContext.trim() !== "" || isSupportedProvider2(providerOrContext)) {
      this._requestManager = new Web3RequestManager2(providerOrContext);
      this._subscriptionManager = new Web3SubscriptionManager2(this._requestManager, {});
      return;
    }
    const { config, provider, requestManager, subscriptionManager, registeredSubscriptions: registeredSubscriptions2, accountProvider, wallet } = providerOrContext;
    this.setConfig(config !== null && config !== void 0 ? config : {});
    this._requestManager = requestManager !== null && requestManager !== void 0 ? requestManager : new Web3RequestManager2(provider, (_a16 = config === null || config === void 0 ? void 0 : config.enableExperimentalFeatures) === null || _a16 === void 0 ? void 0 : _a16.useSubscriptionWhenCheckingBlockTimeout);
    if (subscriptionManager) {
      this._subscriptionManager = subscriptionManager;
    } else {
      this._subscriptionManager = new Web3SubscriptionManager2(this.requestManager, registeredSubscriptions2 !== null && registeredSubscriptions2 !== void 0 ? registeredSubscriptions2 : {});
    }
    if (accountProvider) {
      this._accountProvider = accountProvider;
    }
    if (wallet) {
      this._wallet = wallet;
    }
  }
  get requestManager() {
    return this._requestManager;
  }
  get subscriptionManager() {
    return this._subscriptionManager;
  }
  get wallet() {
    return this._wallet;
  }
  get accountProvider() {
    return this._accountProvider;
  }
  static fromContextObject(...args) {
    return new this(...args.reverse());
  }
  getContextObject() {
    var _a16;
    return {
      config: this.config,
      provider: this.provider,
      requestManager: this.requestManager,
      subscriptionManager: this.subscriptionManager,
      registeredSubscriptions: (_a16 = this.subscriptionManager) === null || _a16 === void 0 ? void 0 : _a16.registeredSubscriptions,
      providers: this.providers,
      wallet: this.wallet,
      accountProvider: this.accountProvider
    };
  }
  use(ContextRef, ...args) {
    const newContextChild = new ContextRef(...[...args, this.getContextObject()]);
    this.on(Web3ConfigEvent2.CONFIG_CHANGE, (event) => {
      newContextChild.setConfig({ [event.name]: event.newValue });
    });
    return newContextChild;
  }
  link(parentContext) {
    this.setConfig(parentContext.config);
    this._requestManager = parentContext.requestManager;
    this.provider = parentContext.provider;
    this._subscriptionManager = parentContext.subscriptionManager;
    this._wallet = parentContext.wallet;
    this._accountProvider = parentContext._accountProvider;
    parentContext.on(Web3ConfigEvent2.CONFIG_CHANGE, (event) => {
      this.setConfig({ [event.name]: event.newValue });
    });
  }
  registerPlugin(plugin) {
    if (this[plugin.pluginNamespace] !== void 0)
      throw new ExistingPluginNamespaceError(plugin.pluginNamespace);
    const _pluginObject = {
      [plugin.pluginNamespace]: plugin
    };
    _pluginObject[plugin.pluginNamespace].link(this);
    Object.assign(this, _pluginObject);
  }
  get provider() {
    return this.currentProvider;
  }
  set provider(provider) {
    this.requestManager.setProvider(provider);
  }
  get currentProvider() {
    return this.requestManager.provider;
  }
  set currentProvider(provider) {
    this.requestManager.setProvider(provider);
  }
  get givenProvider() {
    return Web3Context2.givenProvider;
  }
  setProvider(provider) {
    this.provider = provider;
    return true;
  }
  get BatchRequest() {
    return Web3BatchRequest2.bind(void 0, this._requestManager);
  }
  extend(extendObj) {
    var _a16;
    if (extendObj.property && !this[extendObj.property])
      this[extendObj.property] = {};
    (_a16 = extendObj.methods) === null || _a16 === void 0 ? void 0 : _a16.forEach((element) => {
      const method = (...givenParams) => __awaiter24(this, void 0, void 0, function* () {
        return this.requestManager.send({
          method: element.call,
          params: givenParams
        });
      });
      if (extendObj.property)
        this[extendObj.property][element.name] = method;
      else
        this[element.name] = method;
    });
    return this;
  }
};
Web3Context2.providers = Web3RequestManager2.providers;

// node_modules/web3-eth/node_modules/web3-core/lib/esm/types.js
init_shim();

// node_modules/web3-eth/node_modules/web3-core/lib/esm/formatters.js
var formatters_exports2 = {};
__export(formatters_exports2, {
  inputAddressFormatter: () => inputAddressFormatter2,
  inputBlockNumberFormatter: () => inputBlockNumberFormatter2,
  inputCallFormatter: () => inputCallFormatter2,
  inputDefaultBlockNumberFormatter: () => inputDefaultBlockNumberFormatter2,
  inputLogFormatter: () => inputLogFormatter2,
  inputPostFormatter: () => inputPostFormatter2,
  inputSignFormatter: () => inputSignFormatter2,
  inputStorageKeysFormatter: () => inputStorageKeysFormatter2,
  inputTopicFormatter: () => inputTopicFormatter2,
  inputTransactionFormatter: () => inputTransactionFormatter2,
  outputBigIntegerFormatter: () => outputBigIntegerFormatter2,
  outputBlockFormatter: () => outputBlockFormatter2,
  outputLogFormatter: () => outputLogFormatter2,
  outputPostFormatter: () => outputPostFormatter2,
  outputProofFormatter: () => outputProofFormatter2,
  outputSyncingFormatter: () => outputSyncingFormatter2,
  outputTransactionFormatter: () => outputTransactionFormatter2,
  outputTransactionReceiptFormatter: () => outputTransactionReceiptFormatter2,
  txInputOptionsFormatter: () => txInputOptionsFormatter2
});
init_shim();

// node_modules/web3-eth/node_modules/web3-eth-iban/lib/esm/index.js
init_shim();

// node_modules/web3-eth/node_modules/web3-eth-iban/lib/esm/iban.js
init_shim();
var Iban2 = class {
  constructor(iban) {
    this.toAddress = () => {
      if (this.isDirect()) {
        const base36 = this._iban.slice(4);
        const parsedBigInt = Iban2._parseInt(base36, 36);
        const paddedBigInt = leftPad2(parsedBigInt, 40);
        return toChecksumAddress2(paddedBigInt);
      }
      throw new Error("Iban is indirect and cannot be converted. Must be length of 34 or 35");
    };
    if (Iban2.isIndirect(iban) || Iban2.isDirect(iban)) {
      this._iban = iban;
    } else {
      throw new Error("Invalid IBAN was provided");
    }
  }
  static isDirect(iban) {
    return iban.length === 34 || iban.length === 35;
  }
  isDirect() {
    return Iban2.isDirect(this._iban);
  }
  static isIndirect(iban) {
    return iban.length === 20;
  }
  isIndirect() {
    return Iban2.isIndirect(this._iban);
  }
  static isValid(iban) {
    return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(iban) && Iban2._mod9710(Iban2._iso13616Prepare(iban)) === 1;
  }
  isValid() {
    return Iban2.isValid(this._iban);
  }
  static fromBban(bban) {
    const countryCode = "XE";
    const remainder = this._mod9710(this._iso13616Prepare(`${countryCode}00${bban}`));
    const checkDigit = `0${(98 - remainder).toString()}`.slice(-2);
    return new Iban2(`${countryCode}${checkDigit}${bban}`);
  }
  static createIndirect(options) {
    return Iban2.fromBban(`ETH${options.institution}${options.identifier}`);
  }
  static fromAddress(address) {
    if (!isAddress(address)) {
      throw new InvalidAddressError(address);
    }
    const num = BigInt(hexToNumber3(address));
    const base36 = num.toString(36);
    const padded = leftPad2(base36, 15);
    return Iban2.fromBban(padded.toUpperCase());
  }
  static toIban(address) {
    return Iban2.fromAddress(address).toString();
  }
  client() {
    return this.isIndirect() ? this._iban.slice(11) : "";
  }
  checksum() {
    return this._iban.slice(2, 4);
  }
  institution() {
    return this.isIndirect() ? this._iban.slice(7, 11) : "";
  }
  toString() {
    return this._iban;
  }
};
Iban2._iso13616Prepare = (iban) => {
  const A = "A".charCodeAt(0);
  const Z = "Z".charCodeAt(0);
  const upperIban = iban.toUpperCase();
  const modifiedIban = `${upperIban.slice(4)}${upperIban.slice(0, 4)}`;
  return modifiedIban.split("").map((n) => {
    const code = n.charCodeAt(0);
    if (code >= A && code <= Z) {
      return code - A + 10;
    }
    return n;
  }).join("");
};
Iban2._parseInt = (str, base2) => [...str].reduce((acc, curr) => BigInt(parseInt(curr, base2)) + BigInt(base2) * acc, BigInt(0));
Iban2._mod9710 = (iban) => {
  let remainder = iban;
  let block;
  while (remainder.length > 2) {
    block = remainder.slice(0, 9);
    remainder = `${(parseInt(block, 10) % 97).toString()}${remainder.slice(block.length)}`;
  }
  return parseInt(remainder, 10) % 97;
};
Iban2.toAddress = (iban) => {
  const ibanObject = new Iban2(iban);
  return ibanObject.toAddress();
};

// node_modules/web3-eth/node_modules/web3-eth-iban/lib/esm/types.js
init_shim();

// node_modules/web3-eth/node_modules/web3-core/lib/esm/formatters.js
var inputStorageKeysFormatter2 = (keys) => keys.map((num) => numberToHex3(num));
var outputProofFormatter2 = (proof) => ({
  address: toChecksumAddress2(proof.address),
  nonce: hexToNumberString2(proof.nonce),
  balance: hexToNumberString2(proof.balance)
});
var outputBigIntegerFormatter2 = (number) => toNumber2(number);
var inputBlockNumberFormatter2 = (blockNumber) => {
  if (isNullish(blockNumber)) {
    return void 0;
  }
  if (typeof blockNumber === "string" && isBlockTag(blockNumber)) {
    return blockNumber;
  }
  if (blockNumber === "genesis") {
    return "0x0";
  }
  if (typeof blockNumber === "string" && isHexStrict3(blockNumber)) {
    return blockNumber.toLowerCase();
  }
  return numberToHex3(blockNumber);
};
var inputDefaultBlockNumberFormatter2 = (blockNumber, defaultBlock) => {
  if (!blockNumber) {
    return inputBlockNumberFormatter2(defaultBlock);
  }
  return inputBlockNumberFormatter2(blockNumber);
};
var inputAddressFormatter2 = (address) => {
  if (Iban2.isValid(address) && Iban2.isDirect(address)) {
    const iban = new Iban2(address);
    return iban.toAddress().toLowerCase();
  }
  if (isAddress3(address)) {
    return `0x${address.toLowerCase().replace("0x", "")}`;
  }
  throw new FormatterError(`Provided address ${address} is invalid, the capitalization checksum test failed, or it's an indirect IBAN address which can't be converted.`);
};
var txInputOptionsFormatter2 = (options) => {
  var _a16;
  const modifiedOptions = Object.assign({}, options);
  if (options.to) {
    modifiedOptions.to = inputAddressFormatter2(options.to);
  }
  if (options.data && options.input) {
    throw new FormatterError(`You can't have "data" and "input" as properties of transactions at the same time, please use either "data" or "input" instead.`);
  }
  if (!options.input && options.data) {
    modifiedOptions.input = options.data;
    delete modifiedOptions.data;
  }
  if (options.input && !options.input.startsWith("0x")) {
    modifiedOptions.input = `0x${options.input}`;
  }
  if (modifiedOptions.input && !isHexStrict3(modifiedOptions.input)) {
    throw new FormatterError("The input field must be HEX encoded data.");
  }
  if (options.gas || options.gasLimit) {
    modifiedOptions.gas = toNumber2((_a16 = options.gas) !== null && _a16 !== void 0 ? _a16 : options.gasLimit);
  }
  if (options.maxPriorityFeePerGas || options.maxFeePerGas) {
    delete modifiedOptions.gasPrice;
  }
  ["gasPrice", "gas", "value", "maxPriorityFeePerGas", "maxFeePerGas", "nonce", "chainId"].filter((key) => !isNullish(modifiedOptions[key])).forEach((key) => {
    modifiedOptions[key] = numberToHex3(modifiedOptions[key]);
  });
  return modifiedOptions;
};
var inputCallFormatter2 = (options, defaultAccount) => {
  var _a16;
  const opts = txInputOptionsFormatter2(options);
  const from = (_a16 = opts.from) !== null && _a16 !== void 0 ? _a16 : defaultAccount;
  if (from) {
    opts.from = inputAddressFormatter2(from);
  }
  return opts;
};
var inputTransactionFormatter2 = (options, defaultAccount) => {
  var _a16;
  const opts = txInputOptionsFormatter2(options);
  if (!(typeof opts.from === "number") && !(!!opts.from && typeof opts.from === "object")) {
    opts.from = (_a16 = opts.from) !== null && _a16 !== void 0 ? _a16 : defaultAccount;
    if (!options.from && !(typeof options.from === "number")) {
      throw new FormatterError('The send transactions "from" field must be defined!');
    }
    opts.from = inputAddressFormatter2(options.from);
  }
  return opts;
};
var inputSignFormatter2 = (data) => isHexStrict3(data) ? data : utf8ToHex2(data);
var outputTransactionFormatter2 = (tx) => {
  const modifiedTx = Object.assign({}, tx);
  if (tx.blockNumber) {
    modifiedTx.blockNumber = hexToNumber3(tx.blockNumber);
  }
  if (tx.transactionIndex) {
    modifiedTx.transactionIndex = hexToNumber3(tx.transactionIndex);
  }
  modifiedTx.nonce = hexToNumber3(tx.nonce);
  modifiedTx.gas = hexToNumber3(tx.gas);
  if (tx.gasPrice) {
    modifiedTx.gasPrice = outputBigIntegerFormatter2(tx.gasPrice);
  }
  if (tx.maxFeePerGas) {
    modifiedTx.maxFeePerGas = outputBigIntegerFormatter2(tx.maxFeePerGas);
  }
  if (tx.maxPriorityFeePerGas) {
    modifiedTx.maxPriorityFeePerGas = outputBigIntegerFormatter2(tx.maxPriorityFeePerGas);
  }
  if (tx.type) {
    modifiedTx.type = hexToNumber3(tx.type);
  }
  modifiedTx.value = outputBigIntegerFormatter2(tx.value);
  if (tx.to && isAddress3(tx.to)) {
    modifiedTx.to = toChecksumAddress2(tx.to);
  } else {
    modifiedTx.to = void 0;
  }
  if (tx.from) {
    modifiedTx.from = toChecksumAddress2(tx.from);
  }
  return modifiedTx;
};
var inputTopicFormatter2 = (topic) => {
  if (isNullish(topic))
    return null;
  const value = String(topic);
  return isHex(value) ? value : fromUtf82(value);
};
var inputLogFormatter2 = (filter) => {
  var _a16;
  const val = isNullish(filter) ? {} : mergeDeep2({}, filter);
  if (isNullish(val.fromBlock)) {
    val.fromBlock = BlockTags.LATEST;
  }
  val.fromBlock = inputBlockNumberFormatter2(val.fromBlock);
  if (!isNullish(val.toBlock)) {
    val.toBlock = inputBlockNumberFormatter2(val.toBlock);
  }
  val.topics = (_a16 = val.topics) !== null && _a16 !== void 0 ? _a16 : [];
  val.topics = val.topics.map((topic) => Array.isArray(topic) ? topic.map(inputTopicFormatter2) : inputTopicFormatter2(topic));
  if (val.address) {
    val.address = Array.isArray(val.address) ? val.address.map((addr) => inputAddressFormatter2(addr)) : inputAddressFormatter2(val.address);
  }
  return val;
};
var outputLogFormatter2 = (log) => {
  const modifiedLog = Object.assign({}, log);
  const logIndex = typeof log.logIndex === "string" ? log.logIndex : numberToHex3(log.logIndex);
  if (typeof log.blockHash === "string" && typeof log.transactionHash === "string") {
    const shaId = sha3Raw2(`${log.blockHash.replace("0x", "")}${log.transactionHash.replace("0x", "")}${logIndex.replace("0x", "")}`);
    modifiedLog.id = `log_${shaId.replace("0x", "").slice(0, 8)}`;
  } else if (!log.id) {
    modifiedLog.id = void 0;
  }
  if (log.blockNumber && isHexStrict3(log.blockNumber)) {
    modifiedLog.blockNumber = hexToNumber3(log.blockNumber);
  }
  if (log.transactionIndex && isHexStrict3(log.transactionIndex)) {
    modifiedLog.transactionIndex = hexToNumber3(log.transactionIndex);
  }
  if (log.logIndex && isHexStrict3(log.logIndex)) {
    modifiedLog.logIndex = hexToNumber3(log.logIndex);
  }
  if (log.address) {
    modifiedLog.address = toChecksumAddress2(log.address);
  }
  return modifiedLog;
};
var outputTransactionReceiptFormatter2 = (receipt) => {
  if (typeof receipt !== "object") {
    throw new FormatterError(`Received receipt is invalid: ${String(receipt)}`);
  }
  const modifiedReceipt = Object.assign({}, receipt);
  if (receipt.blockNumber) {
    modifiedReceipt.blockNumber = hexToNumber3(receipt.blockNumber);
  }
  if (receipt.transactionIndex) {
    modifiedReceipt.transactionIndex = hexToNumber3(receipt.transactionIndex);
  }
  modifiedReceipt.cumulativeGasUsed = hexToNumber3(receipt.cumulativeGasUsed);
  modifiedReceipt.gasUsed = hexToNumber3(receipt.gasUsed);
  if (receipt.logs && Array.isArray(receipt.logs)) {
    modifiedReceipt.logs = receipt.logs.map(outputLogFormatter2);
  }
  if (receipt.effectiveGasPrice) {
    modifiedReceipt.effectiveGasPrice = hexToNumber3(receipt.effectiveGasPrice);
  }
  if (receipt.contractAddress) {
    modifiedReceipt.contractAddress = toChecksumAddress2(receipt.contractAddress);
  }
  if (receipt.status) {
    modifiedReceipt.status = Boolean(parseInt(receipt.status, 10));
  }
  return modifiedReceipt;
};
var outputBlockFormatter2 = (block) => {
  const modifiedBlock = Object.assign({}, block);
  modifiedBlock.gasLimit = hexToNumber3(block.gasLimit);
  modifiedBlock.gasUsed = hexToNumber3(block.gasUsed);
  modifiedBlock.size = hexToNumber3(block.size);
  modifiedBlock.timestamp = hexToNumber3(block.timestamp);
  if (block.number) {
    modifiedBlock.number = hexToNumber3(block.number);
  }
  if (block.difficulty) {
    modifiedBlock.difficulty = outputBigIntegerFormatter2(block.difficulty);
  }
  if (block.totalDifficulty) {
    modifiedBlock.totalDifficulty = outputBigIntegerFormatter2(block.totalDifficulty);
  }
  if (block.transactions && Array.isArray(block.transactions)) {
    modifiedBlock.transactions = block.transactions.map(outputTransactionFormatter2);
  }
  if (block.miner) {
    modifiedBlock.miner = toChecksumAddress2(block.miner);
  }
  if (block.baseFeePerGas) {
    modifiedBlock.baseFeePerGas = outputBigIntegerFormatter2(block.baseFeePerGas);
  }
  return modifiedBlock;
};
var inputPostFormatter2 = (post) => {
  var _a16;
  const modifiedPost = Object.assign({}, post);
  if (post.ttl) {
    modifiedPost.ttl = numberToHex3(post.ttl);
  }
  if (post.workToProve) {
    modifiedPost.workToProve = numberToHex3(post.workToProve);
  }
  if (post.priority) {
    modifiedPost.priority = numberToHex3(post.priority);
  }
  if (post.topics && !Array.isArray(post.topics)) {
    modifiedPost.topics = post.topics ? [post.topics] : [];
  }
  modifiedPost.topics = (_a16 = modifiedPost.topics) === null || _a16 === void 0 ? void 0 : _a16.map((topic) => topic.startsWith("0x") ? topic : fromUtf82(topic));
  return modifiedPost;
};
var outputPostFormatter2 = (post) => {
  var _a16;
  const modifiedPost = Object.assign({}, post);
  if (post.expiry) {
    modifiedPost.expiry = hexToNumber3(post.expiry);
  }
  if (post.sent) {
    modifiedPost.sent = hexToNumber3(post.sent);
  }
  if (post.ttl) {
    modifiedPost.ttl = hexToNumber3(post.ttl);
  }
  if (post.workProved) {
    modifiedPost.workProved = hexToNumber3(post.workProved);
  }
  if (!post.topics) {
    modifiedPost.topics = [];
  }
  modifiedPost.topics = (_a16 = modifiedPost.topics) === null || _a16 === void 0 ? void 0 : _a16.map(toUtf82);
  return modifiedPost;
};
var outputSyncingFormatter2 = (result) => {
  const modifiedResult = Object.assign({}, result);
  modifiedResult.startingBlock = hexToNumber3(result.startingBlock);
  modifiedResult.currentBlock = hexToNumber3(result.currentBlock);
  modifiedResult.highestBlock = hexToNumber3(result.highestBlock);
  if (result.knownStates) {
    modifiedResult.knownStates = hexToNumber3(result.knownStates);
  }
  if (result.pulledStates) {
    modifiedResult.pulledStates = hexToNumber3(result.pulledStates);
  }
  return modifiedResult;
};

// node_modules/web3-eth/node_modules/web3-core/lib/esm/web3_promi_event.js
init_shim();
var __awaiter25 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a4;
var Web3PromiEvent2 = class extends Web3EventEmitter2 {
  constructor(executor) {
    super();
    this[_a4] = "Promise";
    this._promise = new Promise(executor);
  }
  then(onfulfilled, onrejected) {
    return __awaiter25(this, void 0, void 0, function* () {
      return this._promise.then(onfulfilled, onrejected);
    });
  }
  catch(onrejected) {
    return __awaiter25(this, void 0, void 0, function* () {
      return this._promise.catch(onrejected);
    });
  }
  finally(onfinally) {
    return __awaiter25(this, void 0, void 0, function* () {
      return this._promise.finally(onfinally);
    });
  }
  on(eventName, fn) {
    super.on(eventName, fn);
    return this;
  }
  once(eventName, fn) {
    super.once(eventName, fn);
    return this;
  }
};
_a4 = Symbol.toStringTag;

// node_modules/web3-rpc-methods/lib/esm/index.js
var esm_exports9 = {};
__export(esm_exports9, {
  ethRpcMethods: () => eth_rpc_methods_exports,
  netRpcMethods: () => net_rpc_methods_exports,
  personalRpcMethods: () => personal_rpc_methods_exports
});
init_shim();

// node_modules/web3-rpc-methods/lib/esm/eth_rpc_methods.js
var eth_rpc_methods_exports = {};
__export(eth_rpc_methods_exports, {
  call: () => call,
  compileLLL: () => compileLLL,
  compileSerpent: () => compileSerpent,
  compileSolidity: () => compileSolidity,
  createAccessList: () => createAccessList,
  estimateGas: () => estimateGas,
  getAccounts: () => getAccounts,
  getBalance: () => getBalance,
  getBlockByHash: () => getBlockByHash,
  getBlockByNumber: () => getBlockByNumber,
  getBlockNumber: () => getBlockNumber,
  getBlockTransactionCountByHash: () => getBlockTransactionCountByHash,
  getBlockTransactionCountByNumber: () => getBlockTransactionCountByNumber,
  getChainId: () => getChainId,
  getCode: () => getCode,
  getCoinbase: () => getCoinbase,
  getCompilers: () => getCompilers,
  getFeeHistory: () => getFeeHistory,
  getFilterChanges: () => getFilterChanges,
  getFilterLogs: () => getFilterLogs,
  getGasPrice: () => getGasPrice,
  getHashRate: () => getHashRate,
  getLogs: () => getLogs,
  getMining: () => getMining,
  getNodeInfo: () => getNodeInfo,
  getPendingTransactions: () => getPendingTransactions,
  getProof: () => getProof,
  getProtocolVersion: () => getProtocolVersion,
  getStorageAt: () => getStorageAt,
  getSyncing: () => getSyncing,
  getTransactionByBlockHashAndIndex: () => getTransactionByBlockHashAndIndex,
  getTransactionByBlockNumberAndIndex: () => getTransactionByBlockNumberAndIndex,
  getTransactionByHash: () => getTransactionByHash,
  getTransactionCount: () => getTransactionCount,
  getTransactionReceipt: () => getTransactionReceipt,
  getUncleByBlockHashAndIndex: () => getUncleByBlockHashAndIndex,
  getUncleByBlockNumberAndIndex: () => getUncleByBlockNumberAndIndex,
  getUncleCountByBlockHash: () => getUncleCountByBlockHash,
  getUncleCountByBlockNumber: () => getUncleCountByBlockNumber,
  getWork: () => getWork,
  newBlockFilter: () => newBlockFilter,
  newFilter: () => newFilter,
  newPendingTransactionFilter: () => newPendingTransactionFilter,
  requestAccounts: () => requestAccounts,
  sendRawTransaction: () => sendRawTransaction,
  sendTransaction: () => sendTransaction,
  sign: () => sign,
  signTransaction: () => signTransaction,
  signTypedData: () => signTypedData,
  submitHashrate: () => submitHashrate,
  submitWork: () => submitWork,
  uninstallFilter: () => uninstallFilter
});
init_shim();
var __awaiter26 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getProtocolVersion(requestManager) {
  return __awaiter26(this, void 0, void 0, function* () {
    return requestManager.send({
      method: "eth_protocolVersion",
      params: []
    });
  });
}
function getSyncing(requestManager) {
  return __awaiter26(this, void 0, void 0, function* () {
    return requestManager.send({
      method: "eth_syncing",
      params: []
    });
  });
}
function getCoinbase(requestManager) {
  return __awaiter26(this, void 0, void 0, function* () {
    return requestManager.send({
      method: "eth_coinbase",
      params: []
    });
  });
}
function getMining(requestManager) {
  return __awaiter26(this, void 0, void 0, function* () {
    return requestManager.send({
      method: "eth_mining",
      params: []
    });
  });
}
function getHashRate(requestManager) {
  return __awaiter26(this, void 0, void 0, function* () {
    return requestManager.send({
      method: "eth_hashrate",
      params: []
    });
  });
}
function getGasPrice(requestManager) {
  return __awaiter26(this, void 0, void 0, function* () {
    return requestManager.send({
      method: "eth_gasPrice",
      params: []
    });
  });
}
function getAccounts(requestManager) {
  return __awaiter26(this, void 0, void 0, function* () {
    return requestManager.send({
      method: "eth_accounts",
      params: []
    });
  });
}
function getBlockNumber(requestManager) {
  return __awaiter26(this, void 0, void 0, function* () {
    return requestManager.send({
      method: "eth_blockNumber",
      params: []
    });
  });
}
function getBalance(requestManager, address, blockNumber) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["address", "blockNumberOrTag"], [address, blockNumber]);
    return requestManager.send({
      method: "eth_getBalance",
      params: [address, blockNumber]
    });
  });
}
function getStorageAt(requestManager, address, storageSlot, blockNumber) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["address", "hex", "blockNumberOrTag"], [address, storageSlot, blockNumber]);
    return requestManager.send({
      method: "eth_getStorageAt",
      params: [address, storageSlot, blockNumber]
    });
  });
}
function getTransactionCount(requestManager, address, blockNumber) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["address", "blockNumberOrTag"], [address, blockNumber]);
    return requestManager.send({
      method: "eth_getTransactionCount",
      params: [address, blockNumber]
    });
  });
}
function getBlockTransactionCountByHash(requestManager, blockHash) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["bytes32"], [blockHash]);
    return requestManager.send({
      method: "eth_getBlockTransactionCountByHash",
      params: [blockHash]
    });
  });
}
function getBlockTransactionCountByNumber(requestManager, blockNumber) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["blockNumberOrTag"], [blockNumber]);
    return requestManager.send({
      method: "eth_getBlockTransactionCountByNumber",
      params: [blockNumber]
    });
  });
}
function getUncleCountByBlockHash(requestManager, blockHash) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["bytes32"], [blockHash]);
    return requestManager.send({
      method: "eth_getUncleCountByBlockHash",
      params: [blockHash]
    });
  });
}
function getUncleCountByBlockNumber(requestManager, blockNumber) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["blockNumberOrTag"], [blockNumber]);
    return requestManager.send({
      method: "eth_getUncleCountByBlockNumber",
      params: [blockNumber]
    });
  });
}
function getCode(requestManager, address, blockNumber) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["address", "blockNumberOrTag"], [address, blockNumber]);
    return requestManager.send({
      method: "eth_getCode",
      params: [address, blockNumber]
    });
  });
}
function sign(requestManager, address, message) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["address", "hex"], [address, message]);
    return requestManager.send({
      method: "eth_sign",
      params: [address, message]
    });
  });
}
function signTransaction(requestManager, transaction) {
  return __awaiter26(this, void 0, void 0, function* () {
    return requestManager.send({
      method: "eth_signTransaction",
      params: [transaction]
    });
  });
}
function sendTransaction(requestManager, transaction) {
  return __awaiter26(this, void 0, void 0, function* () {
    return requestManager.send({
      method: "eth_sendTransaction",
      params: [transaction]
    });
  });
}
function sendRawTransaction(requestManager, transaction) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["hex"], [transaction]);
    return requestManager.send({
      method: "eth_sendRawTransaction",
      params: [transaction]
    });
  });
}
function call(requestManager, transaction, blockNumber) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["blockNumberOrTag"], [blockNumber]);
    return requestManager.send({
      method: "eth_call",
      params: [transaction, blockNumber]
    });
  });
}
function estimateGas(requestManager, transaction, blockNumber) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["blockNumberOrTag"], [blockNumber]);
    return requestManager.send({
      method: "eth_estimateGas",
      params: [transaction, blockNumber]
    });
  });
}
function getBlockByHash(requestManager, blockHash, hydrated) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["bytes32", "bool"], [blockHash, hydrated]);
    return requestManager.send({
      method: "eth_getBlockByHash",
      params: [blockHash, hydrated]
    });
  });
}
function getBlockByNumber(requestManager, blockNumber, hydrated) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["blockNumberOrTag", "bool"], [blockNumber, hydrated]);
    return requestManager.send({
      method: "eth_getBlockByNumber",
      params: [blockNumber, hydrated]
    });
  });
}
function getTransactionByHash(requestManager, transactionHash) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["bytes32"], [transactionHash]);
    return requestManager.send({
      method: "eth_getTransactionByHash",
      params: [transactionHash]
    });
  });
}
function getTransactionByBlockHashAndIndex(requestManager, blockHash, transactionIndex) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["bytes32", "hex"], [blockHash, transactionIndex]);
    return requestManager.send({
      method: "eth_getTransactionByBlockHashAndIndex",
      params: [blockHash, transactionIndex]
    });
  });
}
function getTransactionByBlockNumberAndIndex(requestManager, blockNumber, transactionIndex) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["blockNumberOrTag", "hex"], [blockNumber, transactionIndex]);
    return requestManager.send({
      method: "eth_getTransactionByBlockNumberAndIndex",
      params: [blockNumber, transactionIndex]
    });
  });
}
function getTransactionReceipt(requestManager, transactionHash) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["bytes32"], [transactionHash]);
    return requestManager.send({
      method: "eth_getTransactionReceipt",
      params: [transactionHash]
    });
  });
}
function getUncleByBlockHashAndIndex(requestManager, blockHash, uncleIndex) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["bytes32", "hex"], [blockHash, uncleIndex]);
    return requestManager.send({
      method: "eth_getUncleByBlockHashAndIndex",
      params: [blockHash, uncleIndex]
    });
  });
}
function getUncleByBlockNumberAndIndex(requestManager, blockNumber, uncleIndex) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["blockNumberOrTag", "hex"], [blockNumber, uncleIndex]);
    return requestManager.send({
      method: "eth_getUncleByBlockNumberAndIndex",
      params: [blockNumber, uncleIndex]
    });
  });
}
function getCompilers(requestManager) {
  return __awaiter26(this, void 0, void 0, function* () {
    return requestManager.send({
      method: "eth_getCompilers",
      params: []
    });
  });
}
function compileSolidity(requestManager, code) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["string"], [code]);
    return requestManager.send({
      method: "eth_compileSolidity",
      params: [code]
    });
  });
}
function compileLLL(requestManager, code) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["string"], [code]);
    return requestManager.send({
      method: "eth_compileLLL",
      params: [code]
    });
  });
}
function compileSerpent(requestManager, code) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["string"], [code]);
    return requestManager.send({
      method: "eth_compileSerpent",
      params: [code]
    });
  });
}
function newFilter(requestManager, filter) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["filter"], [filter]);
    return requestManager.send({
      method: "eth_newFilter",
      params: [filter]
    });
  });
}
function newBlockFilter(requestManager) {
  return __awaiter26(this, void 0, void 0, function* () {
    return requestManager.send({
      method: "eth_newBlockFilter",
      params: []
    });
  });
}
function newPendingTransactionFilter(requestManager) {
  return __awaiter26(this, void 0, void 0, function* () {
    return requestManager.send({
      method: "eth_newPendingTransactionFilter",
      params: []
    });
  });
}
function uninstallFilter(requestManager, filterIdentifier) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["hex"], [filterIdentifier]);
    return requestManager.send({
      method: "eth_uninstallFilter",
      params: [filterIdentifier]
    });
  });
}
function getFilterChanges(requestManager, filterIdentifier) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["hex"], [filterIdentifier]);
    return requestManager.send({
      method: "eth_getFilterChanges",
      params: [filterIdentifier]
    });
  });
}
function getFilterLogs(requestManager, filterIdentifier) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["hex"], [filterIdentifier]);
    return requestManager.send({
      method: "eth_getFilterLogs",
      params: [filterIdentifier]
    });
  });
}
function getLogs(requestManager, filter) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["filter"], [filter]);
    return requestManager.send({
      method: "eth_getLogs",
      params: [filter]
    });
  });
}
function getWork(requestManager) {
  return __awaiter26(this, void 0, void 0, function* () {
    return requestManager.send({
      method: "eth_getWork",
      params: []
    });
  });
}
function submitWork(requestManager, nonce, hash, digest) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["bytes8", "bytes32", "bytes32"], [nonce, hash, digest]);
    return requestManager.send({
      method: "eth_submitWork",
      params: [nonce, hash, digest]
    });
  });
}
function submitHashrate(requestManager, hashRate, id) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["bytes32", "bytes32"], [hashRate, id]);
    return requestManager.send({
      method: "eth_submitHashrate",
      params: [hashRate, id]
    });
  });
}
function getFeeHistory(requestManager, blockCount, newestBlock, rewardPercentiles) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["hex", "blockNumberOrTag"], [blockCount, newestBlock]);
    for (const rewardPercentile of rewardPercentiles) {
      validator.validate(["number"], [rewardPercentile]);
    }
    return requestManager.send({
      method: "eth_feeHistory",
      params: [blockCount, newestBlock, rewardPercentiles]
    });
  });
}
function getPendingTransactions(requestManager) {
  return __awaiter26(this, void 0, void 0, function* () {
    return requestManager.send({
      method: "eth_pendingTransactions",
      params: []
    });
  });
}
function requestAccounts(requestManager) {
  return __awaiter26(this, void 0, void 0, function* () {
    return requestManager.send({
      method: "eth_requestAccounts",
      params: []
    });
  });
}
function getChainId(requestManager) {
  return __awaiter26(this, void 0, void 0, function* () {
    return requestManager.send({
      method: "eth_chainId",
      params: []
    });
  });
}
function getProof(requestManager, address, storageKeys, blockNumber) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["address", "bytes32[]", "blockNumberOrTag"], [address, storageKeys, blockNumber]);
    return requestManager.send({
      method: "eth_getProof",
      params: [address, storageKeys, blockNumber]
    });
  });
}
function getNodeInfo(requestManager) {
  return __awaiter26(this, void 0, void 0, function* () {
    return requestManager.send({
      method: "web3_clientVersion",
      params: []
    });
  });
}
function createAccessList(requestManager, transaction, blockNumber) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["blockNumberOrTag"], [blockNumber]);
    return requestManager.send({
      method: "eth_createAccessList",
      params: [transaction, blockNumber]
    });
  });
}
function signTypedData(requestManager, address, typedData, useLegacy = false) {
  return __awaiter26(this, void 0, void 0, function* () {
    validator.validate(["address"], [address]);
    return requestManager.send({
      method: `eth_signTypedData${useLegacy ? "" : "_v4"}`,
      params: [address, typedData]
    });
  });
}

// node_modules/web3-rpc-methods/lib/esm/net_rpc_methods.js
var net_rpc_methods_exports = {};
__export(net_rpc_methods_exports, {
  getId: () => getId,
  getPeerCount: () => getPeerCount,
  isListening: () => isListening
});
init_shim();
var __awaiter27 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getId(requestManager) {
  return __awaiter27(this, void 0, void 0, function* () {
    return requestManager.send({
      method: "net_version",
      params: []
    });
  });
}
function getPeerCount(requestManager) {
  return __awaiter27(this, void 0, void 0, function* () {
    return requestManager.send({
      method: "net_peerCount",
      params: []
    });
  });
}
function isListening(requestManager) {
  return __awaiter27(this, void 0, void 0, function* () {
    return requestManager.send({
      method: "net_listening",
      params: []
    });
  });
}

// node_modules/web3-rpc-methods/lib/esm/personal_rpc_methods.js
var personal_rpc_methods_exports = {};
__export(personal_rpc_methods_exports, {
  ecRecover: () => ecRecover,
  getAccounts: () => getAccounts2,
  importRawKey: () => importRawKey,
  lockAccount: () => lockAccount,
  newAccount: () => newAccount,
  sendTransaction: () => sendTransaction2,
  sign: () => sign2,
  signTransaction: () => signTransaction2,
  unlockAccount: () => unlockAccount
});
init_shim();
var __awaiter28 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getAccounts2 = (requestManager) => __awaiter28(void 0, void 0, void 0, function* () {
  return requestManager.send({
    method: "personal_listAccounts",
    params: []
  });
});
var newAccount = (requestManager, password) => __awaiter28(void 0, void 0, void 0, function* () {
  return requestManager.send({
    method: "personal_newAccount",
    params: [password]
  });
});
var unlockAccount = (requestManager, address, password, unlockDuration) => __awaiter28(void 0, void 0, void 0, function* () {
  return requestManager.send({
    method: "personal_unlockAccount",
    params: [address, password, unlockDuration]
  });
});
var lockAccount = (requestManager, address) => __awaiter28(void 0, void 0, void 0, function* () {
  return requestManager.send({
    method: "personal_lockAccount",
    params: [address]
  });
});
var importRawKey = (requestManager, keyData, passphrase) => __awaiter28(void 0, void 0, void 0, function* () {
  return requestManager.send({
    method: "personal_importRawKey",
    params: [keyData, passphrase]
  });
});
var sendTransaction2 = (requestManager, tx, passphrase) => __awaiter28(void 0, void 0, void 0, function* () {
  return requestManager.send({
    method: "personal_sendTransaction",
    params: [tx, passphrase]
  });
});
var signTransaction2 = (requestManager, tx, passphrase) => __awaiter28(void 0, void 0, void 0, function* () {
  return requestManager.send({
    method: "personal_signTransaction",
    params: [tx, passphrase]
  });
});
var sign2 = (requestManager, data, address, passphrase) => __awaiter28(void 0, void 0, void 0, function* () {
  return requestManager.send({
    method: "personal_sign",
    params: [data, address, passphrase]
  });
});
var ecRecover = (requestManager, signedData, signature) => __awaiter28(void 0, void 0, void 0, function* () {
  return requestManager.send({
    method: "personal_ecRecover",
    params: [signedData, signature]
  });
});

// node_modules/web3-eth/lib/esm/rpc_method_wrappers.js
init_shim();

// node_modules/web3-eth-accounts/lib/esm/index.js
var esm_exports10 = {};
__export(esm_exports10, {
  AccessListEIP2930Transaction: () => AccessListEIP2930Transaction,
  BaseTransaction: () => BaseTransaction,
  Capability: () => Capability,
  Chain: () => Chain,
  Common: () => Common,
  ConsensusAlgorithm: () => ConsensusAlgorithm,
  ConsensusType: () => ConsensusType,
  CustomChain: () => CustomChain,
  FeeMarketEIP1559Transaction: () => FeeMarketEIP1559Transaction,
  Hardfork: () => Hardfork,
  Transaction: () => Transaction,
  TransactionFactory: () => TransactionFactory,
  TypeOutput: () => TypeOutput,
  Wallet: () => Wallet,
  assertIsUint8Array: () => assertIsUint8Array,
  bigIntToHex: () => bigIntToHex,
  bigIntToUint8Array: () => bigIntToUint8Array,
  bigIntToUnpaddedUint8Array: () => bigIntToUnpaddedUint8Array,
  create: () => create,
  decrypt: () => decrypt2,
  ecrecover: () => ecrecover,
  encrypt: () => encrypt2,
  hashMessage: () => hashMessage,
  intToUint8Array: () => intToUint8Array,
  isAccessList: () => isAccessList,
  isAccessListUint8Array: () => isAccessListUint8Array,
  keyStoreSchema: () => keyStoreSchema,
  padToEven: () => padToEven,
  parseAndValidatePrivateKey: () => parseAndValidatePrivateKey,
  parseGethGenesis: () => parseGethGenesis,
  privateKeyToAccount: () => privateKeyToAccount,
  privateKeyToAddress: () => privateKeyToAddress,
  privateKeyToPublicKey: () => privateKeyToPublicKey,
  recover: () => recover,
  recoverTransaction: () => recoverTransaction,
  setLengthLeft: () => setLengthLeft,
  sign: () => sign3,
  signTransaction: () => signTransaction3,
  stripHexPrefix: () => stripHexPrefix,
  stripZeros: () => stripZeros,
  toType: () => toType,
  toUint8Array: () => toUint8Array,
  txUtils: () => utils_exports2,
  uint8ArrayToBigInt: () => uint8ArrayToBigInt,
  unpadUint8Array: () => unpadUint8Array,
  zeros: () => zeros
});
init_shim();

// node_modules/web3-eth-accounts/lib/esm/wallet.js
init_shim();
var __awaiter29 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Wallet = class extends Web3BaseWallet {
  constructor() {
    super(...arguments);
    this._addressMap = /* @__PURE__ */ new Map();
    this._defaultKeyName = "web3js_wallet";
  }
  static getStorage() {
    let storage;
    try {
      storage = window.localStorage;
      const x = "__storage_test__";
      storage.setItem(x, x);
      storage.removeItem(x);
      return storage;
    } catch (e) {
      return e && (e.code === 22 || e.code === 1014 || e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") && !isNullish(storage) && storage.length !== 0 ? storage : void 0;
    }
  }
  create(numberOfAccounts) {
    for (let i = 0; i < numberOfAccounts; i += 1) {
      this.add(this._accountProvider.create());
    }
    return this;
  }
  add(account) {
    var _a16;
    if (typeof account === "string") {
      return this.add(this._accountProvider.privateKeyToAccount(account));
    }
    let index = this.length;
    const existAccount = this.get(account.address);
    if (existAccount) {
      console.warn(`Account ${account.address.toLowerCase()} already exists.`);
      index = (_a16 = this._addressMap.get(account.address.toLowerCase())) !== null && _a16 !== void 0 ? _a16 : index;
    }
    this._addressMap.set(account.address.toLowerCase(), index);
    this[index] = account;
    return this;
  }
  get(addressOrIndex) {
    if (typeof addressOrIndex === "string") {
      const index = this._addressMap.get(addressOrIndex.toLowerCase());
      if (!isNullish(index)) {
        return this[index];
      }
      return void 0;
    }
    return this[addressOrIndex];
  }
  remove(addressOrIndex) {
    if (typeof addressOrIndex === "string") {
      const index = this._addressMap.get(addressOrIndex.toLowerCase());
      if (isNullish(index)) {
        return false;
      }
      this._addressMap.delete(addressOrIndex.toLowerCase());
      this.splice(index, 1);
      return true;
    }
    if (this[addressOrIndex]) {
      this.splice(addressOrIndex, 1);
      return true;
    }
    return false;
  }
  clear() {
    this._addressMap.clear();
    this.length = 0;
    return this;
  }
  encrypt(password, options) {
    return __awaiter29(this, void 0, void 0, function* () {
      return Promise.all(this.map((account) => __awaiter29(this, void 0, void 0, function* () {
        return account.encrypt(password, options);
      })));
    });
  }
  decrypt(encryptedWallets, password, options) {
    return __awaiter29(this, void 0, void 0, function* () {
      const results = yield Promise.all(encryptedWallets.map((wallet) => __awaiter29(this, void 0, void 0, function* () {
        return this._accountProvider.decrypt(wallet, password, options);
      })));
      for (const res of results) {
        this.add(res);
      }
      return this;
    });
  }
  save(password, keyName) {
    return __awaiter29(this, void 0, void 0, function* () {
      const storage = Wallet.getStorage();
      if (!storage) {
        throw new Error("Local storage not available.");
      }
      storage.setItem(keyName !== null && keyName !== void 0 ? keyName : this._defaultKeyName, JSON.stringify(yield this.encrypt(password)));
      return true;
    });
  }
  load(password, keyName) {
    return __awaiter29(this, void 0, void 0, function* () {
      const storage = Wallet.getStorage();
      if (!storage) {
        throw new Error("Local storage not available.");
      }
      const keystore = storage.getItem(keyName !== null && keyName !== void 0 ? keyName : this._defaultKeyName);
      if (keystore) {
        yield this.decrypt(JSON.parse(keystore) || [], password);
      }
      return this;
    });
  }
};

// node_modules/web3-eth-accounts/lib/esm/account.js
init_shim();

// node_modules/web3-eth-accounts/node_modules/ethereum-cryptography/esm/aes.js
init_shim();
init_crypto();

// node_modules/web3-eth-accounts/node_modules/ethereum-cryptography/esm/utils.js
init_shim();
init_assert();
init_utils();
init_utils();
var assertBool4 = assert_default.bool;
var assertBytes4 = assert_default.bytes;
function equalsBytes(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function wrapHash4(hash) {
  return (msg) => {
    assert_default.bytes(msg);
    return hash(msg);
  };
}
var crypto5 = (() => {
  const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
  return {
    node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
    web: webCrypto
  };
})();

// node_modules/web3-eth-accounts/node_modules/ethereum-cryptography/esm/aes.js
var crypto6 = { web: crypto };
function validateOpt(key, iv, mode) {
  if (!mode.startsWith("aes-")) {
    throw new Error(`AES submodule doesn't support mode ${mode}`);
  }
  if (iv.length !== 16) {
    throw new Error("AES: wrong IV length");
  }
  if (mode.startsWith("aes-128") && key.length !== 16 || mode.startsWith("aes-256") && key.length !== 32) {
    throw new Error("AES: wrong key length");
  }
}
async function getBrowserKey(mode, key, iv) {
  if (!crypto6.web) {
    throw new Error("Browser crypto not available.");
  }
  let keyMode;
  if (["aes-128-cbc", "aes-256-cbc"].includes(mode)) {
    keyMode = "cbc";
  }
  if (["aes-128-ctr", "aes-256-ctr"].includes(mode)) {
    keyMode = "ctr";
  }
  if (!keyMode) {
    throw new Error("AES: unsupported mode");
  }
  const wKey = await crypto6.web.subtle.importKey("raw", key, { name: `AES-${keyMode.toUpperCase()}`, length: key.length * 8 }, true, ["encrypt", "decrypt"]);
  return [wKey, { name: `aes-${keyMode}`, iv, counter: iv, length: 128 }];
}
async function encrypt(msg, key, iv, mode = "aes-128-ctr", pkcs7PaddingEnabled = true) {
  validateOpt(key, iv, mode);
  if (crypto6.web) {
    const [wKey, wOpt] = await getBrowserKey(mode, key, iv);
    const cipher = await crypto6.web.subtle.encrypt(wOpt, wKey, msg);
    let res = new Uint8Array(cipher);
    if (!pkcs7PaddingEnabled && wOpt.name === "aes-cbc" && !(msg.length % 16)) {
      res = res.slice(0, -16);
    }
    return res;
  } else if (crypto6.node) {
    const cipher = crypto6.node.createCipheriv(mode, key, iv);
    cipher.setAutoPadding(pkcs7PaddingEnabled);
    return concatBytes(cipher.update(msg), cipher.final());
  } else {
    throw new Error("The environment doesn't have AES module");
  }
}
async function getPadding(cypherText, key, iv, mode) {
  const lastBlock = cypherText.slice(-16);
  for (let i = 0; i < 16; i++) {
    lastBlock[i] ^= iv[i] ^ 16;
  }
  const res = await encrypt(lastBlock, key, iv, mode);
  return res.slice(0, 16);
}
async function decrypt(cypherText, key, iv, mode = "aes-128-ctr", pkcs7PaddingEnabled = true) {
  validateOpt(key, iv, mode);
  if (crypto6.web) {
    const [wKey, wOpt] = await getBrowserKey(mode, key, iv);
    if (!pkcs7PaddingEnabled && wOpt.name === "aes-cbc") {
      const padding = await getPadding(cypherText, key, iv, mode);
      cypherText = concatBytes(cypherText, padding);
    }
    const msg = await crypto6.web.subtle.decrypt(wOpt, wKey, cypherText);
    const msgBytes = new Uint8Array(msg);
    if (wOpt.name === "aes-cbc") {
      const encrypted = await encrypt(msgBytes, key, iv, mode);
      if (!equalsBytes(encrypted, cypherText)) {
        throw new Error("AES: wrong padding");
      }
    }
    return msgBytes;
  } else if (crypto6.node) {
    const decipher = crypto6.node.createDecipheriv(mode, key, iv);
    decipher.setAutoPadding(pkcs7PaddingEnabled);
    return concatBytes(decipher.update(cypherText), decipher.final());
  } else {
    throw new Error("The environment doesn't have AES module");
  }
}

// node_modules/web3-eth-accounts/node_modules/ethereum-cryptography/esm/pbkdf2.js
init_shim();

// node_modules/@noble/hashes/esm/pbkdf2.js
init_shim();
init_assert();
init_hmac();
init_utils();
function pbkdf2Init(hash, _password, _salt, _opts) {
  assert_default.hash(hash);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  assert_default.number(c);
  assert_default.number(dkLen);
  assert_default.number(asyncTick);
  if (c < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes(_password);
  const salt = toBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u.fill(0);
  return DK;
}
function pbkdf2(hash, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1; ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}

// node_modules/web3-eth-accounts/node_modules/ethereum-cryptography/esm/pbkdf2.js
init_sha256();
init_sha512();
function pbkdf2Sync(password, salt, iterations, keylen, digest) {
  if (!["sha256", "sha512"].includes(digest)) {
    throw new Error("Only sha256 and sha512 are supported");
  }
  assertBytes4(password);
  assertBytes4(salt);
  return pbkdf2(digest === "sha256" ? sha256 : sha512, password, salt, {
    c: iterations,
    dkLen: keylen
  });
}

// node_modules/web3-eth-accounts/node_modules/ethereum-cryptography/esm/scrypt.js
init_shim();

// node_modules/@noble/hashes/esm/scrypt.js
init_shim();
init_assert();
init_sha256();
init_utils();
var rotl = (a, b) => a << b | a >>> 32 - b;
function XorAndSalsa(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0; i < 8; i += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix(input, ii, out, oi, r) {
  let head = oi + 0;
  let tail = oi + 16 * r;
  for (let i = 0; i < 16; i++)
    out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
  for (let i = 0; i < r; i++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii += 16, out, tail);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  assert_default.number(N);
  assert_default.number(r);
  assert_default.number(p);
  assert_default.number(dkLen);
  assert_default.number(asyncTick);
  assert_default.number(maxmem);
  if (onProgress !== void 0 && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r;
  const blockSize32 = blockSize / 4;
  if (N <= 1 || (N & N - 1) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N + p);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u32(B);
  const V = u32(new Uint8Array(blockSize * N));
  const tmp = u32(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V, tmp) {
  const res = pbkdf2(sha256, password, B, { c: 1, dkLen });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
}
function scrypt(password, salt, opts) {
  const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
  for (let pi = 0; pi < p; pi++) {
    const Pi = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V[i] = B32[Pi + i];
    for (let i = 0, pos = 0; i < N - 1; i++) {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    }
    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r);
    blockMixCb();
    for (let i = 0; i < N; i++) {
      const j = B32[Pi + blockSize32 - 16] % N;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi, r);
      blockMixCb();
    }
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}

// node_modules/web3-eth-accounts/node_modules/ethereum-cryptography/esm/scrypt.js
function scryptSync(password, salt, n, p, r, dkLen, onProgress) {
  assertBytes4(password);
  assertBytes4(salt);
  return scrypt(password, salt, { N: n, r, p, dkLen, onProgress });
}

// node_modules/web3-eth-accounts/node_modules/web3-utils/lib/esm/index.js
init_shim();

// node_modules/web3-eth-accounts/node_modules/web3-utils/lib/esm/converters.js
init_shim();

// node_modules/web3-eth-accounts/node_modules/ethereum-cryptography/esm/keccak.js
init_shim();
init_sha3();
var keccak2244 = wrapHash4(keccak_224);
var keccak2564 = (() => {
  const k = wrapHash4(keccak_256);
  k.create = keccak_256.create;
  return k;
})();
var keccak3844 = wrapHash4(keccak_384);
var keccak5124 = wrapHash4(keccak_512);

// node_modules/web3-eth-accounts/node_modules/web3-utils/lib/esm/converters.js
var ethUnitMap3 = {
  noether: BigInt(0),
  wei: BigInt(1),
  kwei: BigInt(1e3),
  Kwei: BigInt(1e3),
  babbage: BigInt(1e3),
  femtoether: BigInt(1e3),
  mwei: BigInt(1e6),
  Mwei: BigInt(1e6),
  lovelace: BigInt(1e6),
  picoether: BigInt(1e6),
  gwei: BigInt(1e9),
  Gwei: BigInt(1e9),
  shannon: BigInt(1e9),
  nanoether: BigInt(1e9),
  nano: BigInt(1e9),
  szabo: BigInt(1e12),
  microether: BigInt(1e12),
  micro: BigInt(1e12),
  finney: BigInt(1e15),
  milliether: BigInt(1e15),
  milli: BigInt(1e15),
  ether: BigInt("1000000000000000000"),
  kether: BigInt("1000000000000000000000"),
  grand: BigInt("1000000000000000000000"),
  mether: BigInt("1000000000000000000000000"),
  gether: BigInt("1000000000000000000000000000"),
  tether: BigInt("1000000000000000000000000000000")
};
var bytesToUint8Array3 = (data) => {
  validator.validate(["bytes"], [data]);
  if (data instanceof Uint8Array) {
    return data;
  }
  if (Array.isArray(data)) {
    return new Uint8Array(data);
  }
  if (typeof data === "string") {
    return utils_exports.hexToUint8Array(data);
  }
  throw new InvalidBytesError(data);
};
var { uint8ArrayToHexString: uint8ArrayToHexString4 } = utils_exports;
var bytesToHex4 = (bytes) => uint8ArrayToHexString4(bytesToUint8Array3(bytes));
var hexToBytes4 = (bytes) => {
  if (typeof bytes === "string" && bytes.slice(0, 2).toLowerCase() !== "0x") {
    return bytesToUint8Array3(`0x${bytes}`);
  }
  return bytesToUint8Array3(bytes);
};
var numberToHex4 = (value, hexstrict) => {
  if (typeof value !== "bigint")
    validator.validate(["int"], [value]);
  let updatedValue = utils_exports.numberToHex(value);
  if (hexstrict) {
    if (!updatedValue.startsWith("-") && updatedValue.length % 2 === 1) {
      updatedValue = "0x0".concat(updatedValue.slice(2));
    } else if (updatedValue.length % 2 === 0 && updatedValue.startsWith("-"))
      updatedValue = "-0x0".concat(updatedValue.slice(3));
  }
  return updatedValue;
};
var utf8ToHex3 = (str) => {
  validator.validate(["string"], [str]);
  let strWithoutNullCharacter = str.replace(/^(?:\u0000)/, "");
  strWithoutNullCharacter = strWithoutNullCharacter.replace(/(?:\u0000)$/, "");
  return bytesToHex4(new TextEncoder().encode(strWithoutNullCharacter));
};
var fromUtf83 = utf8ToHex3;
var utf8ToBytes4 = utf8ToBytes;
var toChecksumAddress3 = (address) => {
  if (!isAddress(address, false)) {
    throw new InvalidAddressError(address);
  }
  const lowerCaseAddress = address.toLowerCase().replace(/^0x/i, "");
  const hash = utils_exports.uint8ArrayToHexString(keccak2564(utf8ToBytes4(lowerCaseAddress)));
  if (isNullish(hash) || hash === "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470")
    return "";
  let checksumAddress = "0x";
  const addressHash = hash.replace(/^0x/i, "");
  for (let i = 0; i < lowerCaseAddress.length; i += 1) {
    if (parseInt(addressHash[i], 16) > 7) {
      checksumAddress += lowerCaseAddress[i].toUpperCase();
    } else {
      checksumAddress += lowerCaseAddress[i];
    }
  }
  return checksumAddress;
};

// node_modules/web3-eth-accounts/node_modules/web3-utils/lib/esm/event_emitter.js
init_shim();
var import_events5 = __toESM(require_events(), 1);
var __awaiter30 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var wrapFunction3 = (fn) => (params) => fn(params.detail);
var EventEmitterAtBrowser3 = class extends EventTarget {
  constructor() {
    super(...arguments);
    this._listeners = {};
    this.maxListeners = Number.MAX_SAFE_INTEGER;
  }
  on(eventName, fn) {
    this.addEventListener(eventName, fn);
    return this;
  }
  once(eventName, fn) {
    const onceCallback = (params) => __awaiter30(this, void 0, void 0, function* () {
      this.off(eventName, onceCallback);
      yield fn(params);
    });
    return this.on(eventName, onceCallback);
  }
  off(eventName, fn) {
    this.removeEventListener(eventName, fn);
    return this;
  }
  emit(eventName, params) {
    const event = new CustomEvent(eventName, { detail: params });
    return super.dispatchEvent(event);
  }
  listenerCount(eventName) {
    const eventListeners = this._listeners[eventName];
    return eventListeners ? eventListeners.length : 0;
  }
  listeners(eventName) {
    return this._listeners[eventName].map((value) => value[0]) || [];
  }
  eventNames() {
    return Object.keys(this._listeners);
  }
  removeAllListeners() {
    Object.keys(this._listeners).forEach((event) => {
      this._listeners[event].forEach((listener) => {
        super.removeEventListener(event, listener[1]);
      });
    });
    this._listeners = {};
    return this;
  }
  setMaxListeners(maxListeners) {
    this.maxListeners = maxListeners;
    return this;
  }
  getMaxListeners() {
    return this.maxListeners;
  }
  addEventListener(eventName, fn) {
    const wrappedFn = wrapFunction3(fn);
    super.addEventListener(eventName, wrappedFn);
    if (!this._listeners[eventName]) {
      this._listeners[eventName] = [];
    }
    this._listeners[eventName].push([fn, wrappedFn]);
  }
  removeEventListener(eventName, fn) {
    const eventListeners = this._listeners[eventName];
    if (eventListeners) {
      const index = eventListeners.findIndex((item) => item[0] === fn);
      if (index !== -1) {
        super.removeEventListener(eventName, eventListeners[index][1]);
        eventListeners.splice(index, 1);
      }
    }
  }
};
var EventEmitterType3;
if (typeof window === "undefined") {
  EventEmitterType3 = import_events5.EventEmitter;
} else {
  EventEmitterType3 = EventEmitterAtBrowser3;
}
var EventEmitter5 = class extends EventEmitterType3 {
};

// node_modules/web3-eth-accounts/node_modules/web3-utils/lib/esm/validation.js
init_shim();

// node_modules/web3-eth-accounts/node_modules/web3-utils/lib/esm/formatter.js
init_shim();

// node_modules/web3-eth-accounts/node_modules/web3-utils/lib/esm/objects.js
init_shim();

// node_modules/web3-eth-accounts/node_modules/web3-utils/lib/esm/string_manipulation.js
init_shim();

// node_modules/web3-eth-accounts/node_modules/web3-utils/lib/esm/uint8array.js
init_shim();
function uint8ArrayConcat3(...parts) {
  const length = parts.reduce((prev, part) => {
    const agg = prev + part.length;
    return agg;
  }, 0);
  const result = new Uint8Array(length);
  let offset = 0;
  for (const part of parts) {
    result.set(part, offset);
    offset += part.length;
  }
  return result;
}
function uint8ArrayEquals2(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i += 1) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/web3-eth-accounts/node_modules/web3-utils/lib/esm/formatter.js
var { parseBaseType: parseBaseType4 } = utils_exports;

// node_modules/web3-eth-accounts/node_modules/web3-utils/lib/esm/hash.js
init_shim();
var SHA3_EMPTY_BYTES3 = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
var sha33 = (data) => {
  let updatedData;
  if (typeof data === "string") {
    if (data.startsWith("0x") && isHexStrict(data)) {
      updatedData = hexToBytes4(data);
    } else {
      updatedData = utf8ToBytes(data);
    }
  } else {
    updatedData = data;
  }
  const hash = bytesToHex4(keccak2564(updatedData));
  return hash === SHA3_EMPTY_BYTES3 ? void 0 : hash;
};
var sha3Raw3 = (data) => {
  const hash = sha33(data);
  if (isNullish(hash)) {
    return SHA3_EMPTY_BYTES3;
  }
  return hash;
};

// node_modules/web3-eth-accounts/node_modules/web3-utils/lib/esm/random.js
init_shim();

// node_modules/web3-eth-accounts/node_modules/ethereum-cryptography/esm/random.js
init_shim();
init_utils();
function getRandomBytesSync3(bytes) {
  return randomBytes(bytes);
}

// node_modules/web3-eth-accounts/node_modules/web3-utils/lib/esm/random.js
var randomBytes4 = (size) => getRandomBytesSync3(size);

// node_modules/web3-eth-accounts/node_modules/web3-utils/lib/esm/promise_helpers.js
init_shim();

// node_modules/web3-eth-accounts/node_modules/web3-utils/lib/esm/json_rpc.js
var json_rpc_exports3 = {};
__export(json_rpc_exports3, {
  isBatchRequest: () => isBatchRequest3,
  isBatchResponse: () => isBatchResponse3,
  isResponseRpcError: () => isResponseRpcError3,
  isResponseWithError: () => isResponseWithError4,
  isResponseWithNotification: () => isResponseWithNotification3,
  isResponseWithResult: () => isResponseWithResult3,
  isSubscriptionResult: () => isSubscriptionResult3,
  isValidResponse: () => isValidResponse3,
  setRequestIdStart: () => setRequestIdStart3,
  toBatchPayload: () => toBatchPayload3,
  toPayload: () => toPayload3,
  validateResponse: () => validateResponse3
});
init_shim();

// node_modules/web3-eth-accounts/node_modules/web3-utils/lib/esm/uuid.js
init_shim();
var uuidV43 = () => {
  const bytes = randomBytes4(16);
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 63 | 128;
  const hexString = bytesToHex4(bytes);
  return [
    hexString.substring(2, 10),
    hexString.substring(10, 14),
    hexString.substring(14, 18),
    hexString.substring(18, 22),
    hexString.substring(22, 34)
  ].join("-");
};

// node_modules/web3-eth-accounts/node_modules/web3-utils/lib/esm/json_rpc.js
var isResponseRpcError3 = (rpcError) => {
  const errorCode = rpcError.error.code;
  return rpcErrorsMap.has(errorCode) || errorCode >= -32099 && errorCode <= -32e3;
};
var isResponseWithResult3 = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && "result" in response && isNullish(response.error) && (typeof response.id === "number" || typeof response.id === "string");
var isResponseWithError4 = (response) => !Array.isArray(response) && response.jsonrpc === "2.0" && !!response && isNullish(response.result) && "error" in response && (typeof response.id === "number" || typeof response.id === "string");
var isResponseWithNotification3 = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && !isNullish(response.params) && !isNullish(response.method);
var isSubscriptionResult3 = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && "id" in response && "result" in response;
var validateResponse3 = (response) => isResponseWithResult3(response) || isResponseWithError4(response);
var isValidResponse3 = (response) => Array.isArray(response) ? response.every(validateResponse3) : validateResponse3(response);
var isBatchResponse3 = (response) => Array.isArray(response) && response.length > 0 && isValidResponse3(response);
var requestIdSeed3;
var setRequestIdStart3 = (start) => {
  requestIdSeed3 = start;
};
var toPayload3 = (request) => {
  var _a16, _b, _c, _d;
  if (typeof requestIdSeed3 !== "undefined") {
    requestIdSeed3 += 1;
  }
  return {
    jsonrpc: (_a16 = request.jsonrpc) !== null && _a16 !== void 0 ? _a16 : "2.0",
    id: (_c = (_b = request.id) !== null && _b !== void 0 ? _b : requestIdSeed3) !== null && _c !== void 0 ? _c : uuidV43(),
    method: request.method,
    params: (_d = request.params) !== null && _d !== void 0 ? _d : void 0
  };
};
var toBatchPayload3 = (requests) => requests.map((request) => toPayload3(request));
var isBatchRequest3 = (request) => Array.isArray(request) && request.length > 0;

// node_modules/web3-eth-accounts/node_modules/web3-utils/lib/esm/web3_deferred_promise.js
init_shim();
var _a5;
_a5 = Symbol.toStringTag;

// node_modules/web3-eth-accounts/node_modules/web3-utils/lib/esm/chunk_response_parser.js
init_shim();

// node_modules/web3-eth-accounts/node_modules/web3-utils/lib/esm/web3_eip1193_provider.js
init_shim();
var import_events6 = __toESM(require_events(), 1);

// node_modules/web3-eth-accounts/node_modules/web3-utils/lib/esm/socket_provider.js
init_shim();

// node_modules/web3-eth-accounts/lib/esm/tx/constants.js
init_shim();

// node_modules/web3-eth-accounts/node_modules/ethereum-cryptography/esm/secp256k1.js
var secp256k1_exports = {};
__export(secp256k1_exports, {
  secp256k1: () => secp256k1
});
init_shim();
init_secp256k1();

// node_modules/web3-eth-accounts/lib/esm/tx/constants.js
var _a6;
var secp256k12 = (_a6 = secp256k1) !== null && _a6 !== void 0 ? _a6 : secp256k1_exports;
var MAX_UINT64 = BigInt("0xffffffffffffffff");
var MAX_INTEGER = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var SECP256K1_ORDER = secp256k12.CURVE.n;
var SECP256K1_ORDER_DIV_2 = SECP256K1_ORDER / BigInt(2);

// node_modules/web3-eth-accounts/lib/esm/schemas.js
init_shim();
var keyStoreSchema = {
  type: "object",
  required: ["crypto", "id", "version", "address"],
  properties: {
    crypto: {
      type: "object",
      required: ["cipher", "ciphertext", "cipherparams", "kdf", "kdfparams", "mac"],
      properties: {
        cipher: { type: "string" },
        ciphertext: { type: "string" },
        cipherparams: { type: "object" },
        kdf: { type: "string" },
        kdfparams: { type: "object" },
        salt: { type: "string" },
        mac: { type: "string" }
      }
    },
    id: { type: "string" },
    version: { type: "number" },
    address: { type: "string" }
  }
};

// node_modules/web3-eth-accounts/lib/esm/tx/transactionFactory.js
init_shim();

// node_modules/web3-eth-accounts/lib/esm/common/utils.js
init_shim();

// node_modules/web3-eth-accounts/lib/esm/common/enums.js
init_shim();
var Chain;
(function(Chain2) {
  Chain2[Chain2["Mainnet"] = 1] = "Mainnet";
  Chain2[Chain2["Goerli"] = 5] = "Goerli";
  Chain2[Chain2["Sepolia"] = 11155111] = "Sepolia";
})(Chain || (Chain = {}));
var Hardfork;
(function(Hardfork2) {
  Hardfork2["Chainstart"] = "chainstart";
  Hardfork2["Homestead"] = "homestead";
  Hardfork2["Dao"] = "dao";
  Hardfork2["TangerineWhistle"] = "tangerineWhistle";
  Hardfork2["SpuriousDragon"] = "spuriousDragon";
  Hardfork2["Byzantium"] = "byzantium";
  Hardfork2["Constantinople"] = "constantinople";
  Hardfork2["Petersburg"] = "petersburg";
  Hardfork2["Istanbul"] = "istanbul";
  Hardfork2["MuirGlacier"] = "muirGlacier";
  Hardfork2["Berlin"] = "berlin";
  Hardfork2["London"] = "london";
  Hardfork2["ArrowGlacier"] = "arrowGlacier";
  Hardfork2["GrayGlacier"] = "grayGlacier";
  Hardfork2["MergeForkIdTransition"] = "mergeForkIdTransition";
  Hardfork2["Merge"] = "merge";
  Hardfork2["Shanghai"] = "shanghai";
  Hardfork2["ShardingForkDev"] = "shardingFork";
})(Hardfork || (Hardfork = {}));
var ConsensusType;
(function(ConsensusType2) {
  ConsensusType2["ProofOfStake"] = "pos";
  ConsensusType2["ProofOfWork"] = "pow";
  ConsensusType2["ProofOfAuthority"] = "poa";
})(ConsensusType || (ConsensusType = {}));
var ConsensusAlgorithm;
(function(ConsensusAlgorithm2) {
  ConsensusAlgorithm2["Ethash"] = "ethash";
  ConsensusAlgorithm2["Clique"] = "clique";
  ConsensusAlgorithm2["Casper"] = "casper";
})(ConsensusAlgorithm || (ConsensusAlgorithm = {}));
var CustomChain;
(function(CustomChain2) {
  CustomChain2["PolygonMainnet"] = "polygon-mainnet";
  CustomChain2["PolygonMumbai"] = "polygon-mumbai";
  CustomChain2["ArbitrumRinkebyTestnet"] = "arbitrum-rinkeby-testnet";
  CustomChain2["ArbitrumOne"] = "arbitrum-one";
  CustomChain2["xDaiChain"] = "x-dai-chain";
  CustomChain2["OptimisticKovan"] = "optimistic-kovan";
  CustomChain2["OptimisticEthereum"] = "optimistic-ethereum";
})(CustomChain || (CustomChain = {}));

// node_modules/web3-eth-accounts/lib/esm/common/types.js
init_shim();
var TypeOutput;
(function(TypeOutput2) {
  TypeOutput2[TypeOutput2["Number"] = 0] = "Number";
  TypeOutput2[TypeOutput2["BigInt"] = 1] = "BigInt";
  TypeOutput2[TypeOutput2["Uint8Array"] = 2] = "Uint8Array";
  TypeOutput2[TypeOutput2["PrefixedHexString"] = 3] = "PrefixedHexString";
})(TypeOutput || (TypeOutput = {}));

// node_modules/web3-eth-accounts/lib/esm/common/utils.js
var stripHexPrefix = (str) => {
  if (typeof str !== "string")
    throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);
  return isHexPrefixed(str) ? str.slice(2) : str;
};
function formatNonce(nonce) {
  if (!nonce || nonce === "0x0") {
    return "0x0000000000000000";
  }
  if (isHexPrefixed(nonce)) {
    return `0x${stripHexPrefix(nonce).padStart(16, "0")}`;
  }
  return `0x${nonce.padStart(16, "0")}`;
}
var intToHex = function(i) {
  if (!Number.isSafeInteger(i) || i < 0) {
    throw new Error(`Received an invalid integer type: ${i}`);
  }
  return `0x${i.toString(16)}`;
};
function parseGethParams(json, mergeForkIdPostMerge = true) {
  var _a16, _b;
  const { name: name2, config, difficulty, mixHash, gasLimit, coinbase, baseFeePerGas } = json;
  let { extraData, timestamp, nonce } = json;
  const genesisTimestamp = Number(timestamp);
  const { chainId } = config;
  if (extraData === "") {
    extraData = "0x";
  }
  if (!isHexPrefixed(timestamp)) {
    timestamp = intToHex(parseInt(timestamp));
  }
  if (nonce.length !== 18) {
    nonce = formatNonce(nonce);
  }
  if (config.eip155Block !== config.eip158Block) {
    throw new Error("EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork");
  }
  const params = {
    name: name2,
    chainId,
    networkId: chainId,
    genesis: {
      timestamp,
      gasLimit: parseInt(gasLimit),
      difficulty: parseInt(difficulty),
      nonce,
      extraData,
      mixHash,
      coinbase,
      baseFeePerGas
    },
    hardfork: void 0,
    hardforks: [],
    bootstrapNodes: [],
    consensus: config.clique !== void 0 ? {
      type: "poa",
      algorithm: "clique",
      clique: {
        period: (_a16 = config.clique.period) !== null && _a16 !== void 0 ? _a16 : config.clique.blockperiodseconds,
        epoch: (_b = config.clique.epoch) !== null && _b !== void 0 ? _b : config.clique.epochlength
      }
    } : {
      type: "pow",
      algorithm: "ethash",
      ethash: {}
    }
  };
  const forkMap = {
    [Hardfork.Homestead]: { name: "homesteadBlock" },
    [Hardfork.Dao]: { name: "daoForkBlock" },
    [Hardfork.TangerineWhistle]: { name: "eip150Block" },
    [Hardfork.SpuriousDragon]: { name: "eip155Block" },
    [Hardfork.Byzantium]: { name: "byzantiumBlock" },
    [Hardfork.Constantinople]: { name: "constantinopleBlock" },
    [Hardfork.Petersburg]: { name: "petersburgBlock" },
    [Hardfork.Istanbul]: { name: "istanbulBlock" },
    [Hardfork.MuirGlacier]: { name: "muirGlacierBlock" },
    [Hardfork.Berlin]: { name: "berlinBlock" },
    [Hardfork.London]: { name: "londonBlock" },
    [Hardfork.MergeForkIdTransition]: {
      name: "mergeForkBlock",
      postMerge: mergeForkIdPostMerge
    },
    [Hardfork.Shanghai]: { name: "shanghaiTime", postMerge: true, isTimestamp: true },
    [Hardfork.ShardingForkDev]: {
      name: "shardingForkTime",
      postMerge: true,
      isTimestamp: true
    }
  };
  const forkMapRev = Object.keys(forkMap).reduce((acc, elem) => {
    acc[forkMap[elem].name] = elem;
    return acc;
  }, {});
  const configHardforkNames = Object.keys(config).filter(
    (key) => forkMapRev[key] !== void 0 && config[key] !== void 0 && config[key] !== null
  );
  params.hardforks = configHardforkNames.map((nameBlock) => ({
    name: forkMapRev[nameBlock],
    block: forkMap[forkMapRev[nameBlock]].isTimestamp === true || typeof config[nameBlock] !== "number" ? null : config[nameBlock],
    timestamp: forkMap[forkMapRev[nameBlock]].isTimestamp === true && typeof config[nameBlock] === "number" ? config[nameBlock] : void 0
  })).filter((fork) => fork.block !== null || fork.timestamp !== void 0);
  params.hardforks.sort((a, b) => {
    var _a17, _b2;
    return ((_a17 = a.block) !== null && _a17 !== void 0 ? _a17 : Infinity) - ((_b2 = b.block) !== null && _b2 !== void 0 ? _b2 : Infinity);
  });
  params.hardforks.sort((a, b) => {
    var _a17, _b2;
    return ((_a17 = a.timestamp) !== null && _a17 !== void 0 ? _a17 : genesisTimestamp) - ((_b2 = b.timestamp) !== null && _b2 !== void 0 ? _b2 : genesisTimestamp);
  });
  if (config.terminalTotalDifficulty !== void 0) {
    const mergeConfig = {
      name: Hardfork.Merge,
      ttd: config.terminalTotalDifficulty,
      block: null
    };
    const postMergeIndex = params.hardforks.findIndex(
      (hf) => {
        var _a17;
        return ((_a17 = forkMap[hf.name]) === null || _a17 === void 0 ? void 0 : _a17.postMerge) === true;
      }
    );
    if (postMergeIndex !== -1) {
      params.hardforks.splice(postMergeIndex, 0, mergeConfig);
    } else {
      params.hardforks.push(mergeConfig);
    }
  }
  const latestHardfork = params.hardforks.length > 0 ? params.hardforks.slice(-1)[0] : void 0;
  params.hardfork = latestHardfork === null || latestHardfork === void 0 ? void 0 : latestHardfork.name;
  params.hardforks.unshift({ name: Hardfork.Chainstart, block: 0 });
  return params;
}
function parseGethGenesis(json, name2, mergeForkIdPostMerge) {
  try {
    if (["config", "difficulty", "gasLimit", "alloc"].some((field) => !(field in json))) {
      throw new Error("Invalid format, expected geth genesis fields missing");
    }
    if (name2 !== void 0) {
      json.name = name2;
    }
    return parseGethParams(json, mergeForkIdPostMerge);
  } catch (e) {
    throw new Error(`Error parsing parameters file: ${e.message}`);
  }
}
function padToEven(value) {
  let a = value;
  if (typeof a !== "string") {
    throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);
  }
  if (a.length % 2)
    a = `0${a}`;
  return a;
}
var intToUint8Array = function(i) {
  const hex = intToHex(i);
  return hexToBytes4(`0x${padToEven(hex.slice(2))}`);
};
var toUint8Array = function(v) {
  if (v === null || v === void 0) {
    return new Uint8Array();
  }
  if (v instanceof Uint8Array) {
    return v;
  }
  if (Array.isArray(v)) {
    return Uint8Array.from(v);
  }
  if (typeof v === "string") {
    if (!isHexString(v)) {
      throw new Error(`Cannot convert string to Uint8Array. only supports 0x-prefixed hex strings and this string was given: ${v}`);
    }
    return hexToBytes4(padToEven(stripHexPrefix(v)));
  }
  if (typeof v === "number") {
    return toUint8Array(numberToHex4(v));
  }
  if (typeof v === "bigint") {
    if (v < BigInt(0)) {
      throw new Error(`Cannot convert negative bigint to Uint8Array. Given: ${v}`);
    }
    let n = v.toString(16);
    if (n.length % 2)
      n = `0${n}`;
    return toUint8Array(`0x${n}`);
  }
  if (v.toArray) {
    return Uint8Array.from(v.toArray());
  }
  throw new Error("invalid type");
};
function uint8ArrayToBigInt(buf) {
  const hex = bytesToHex4(buf);
  if (hex === "0x") {
    return BigInt(0);
  }
  return BigInt(hex);
}
function bigIntToUint8Array(num) {
  return toUint8Array(`0x${num.toString(16)}`);
}
var zeros = function(bytes) {
  return new Uint8Array(bytes).fill(0);
};
var setLength = function(msg, length, right) {
  const buf = zeros(length);
  if (right) {
    if (msg.length < length) {
      buf.set(msg);
      return buf;
    }
    return msg.subarray(0, length);
  }
  if (msg.length < length) {
    buf.set(msg, length - msg.length);
    return buf;
  }
  return msg.subarray(-length);
};
function assertIsUint8Array(input) {
  if (!(input instanceof Uint8Array)) {
    const msg = `This method only supports Uint8Array but input was: ${input}`;
    throw new Error(msg);
  }
}
var setLengthLeft = function(msg, length) {
  assertIsUint8Array(msg);
  return setLength(msg, length, false);
};
function stripZeros(a) {
  let first = a[0];
  while (a.length > 0 && first.toString() === "0") {
    a = a.slice(1);
    first = a[0];
  }
  return a;
}
var unpadUint8Array = function(a) {
  assertIsUint8Array(a);
  return stripZeros(a);
};
var bigIntToHex = (num) => `0x${num.toString(16)}`;
function bigIntToUnpaddedUint8Array(value) {
  return unpadUint8Array(bigIntToUint8Array(value));
}
function calculateSigRecovery(v, chainId) {
  if (v === BigInt(0) || v === BigInt(1))
    return v;
  if (chainId === void 0) {
    return v - BigInt(27);
  }
  return v - (chainId * BigInt(2) + BigInt(35));
}
function isValidSigRecovery(recovery) {
  return recovery === BigInt(0) || recovery === BigInt(1);
}
var ecrecover = function(msgHash, v, r, s, chainId) {
  const recovery = calculateSigRecovery(v, chainId);
  if (!isValidSigRecovery(recovery)) {
    throw new Error("Invalid signature v value");
  }
  const senderPubKey = new secp256k12.Signature(uint8ArrayToBigInt(r), uint8ArrayToBigInt(s)).addRecoveryBit(Number(recovery)).recoverPublicKey(msgHash).toRawBytes(false);
  return senderPubKey.slice(1);
};
function toType(input, outputType) {
  if (input === null) {
    return null;
  }
  if (input === void 0) {
    return void 0;
  }
  if (typeof input === "string" && !isHexString(input)) {
    throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);
  } else if (typeof input === "number" && !Number.isSafeInteger(input)) {
    throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
  }
  const output = toUint8Array(input);
  switch (outputType) {
    case TypeOutput.Uint8Array:
      return output;
    case TypeOutput.BigInt:
      return uint8ArrayToBigInt(output);
    case TypeOutput.Number: {
      const bigInt = uint8ArrayToBigInt(output);
      if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {
        throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
      }
      return Number(bigInt);
    }
    case TypeOutput.PrefixedHexString:
      return bytesToHex4(output);
    default:
      throw new Error("unknown outputType");
  }
}

// node_modules/web3-eth-accounts/lib/esm/tx/eip1559Transaction.js
init_shim();
var import_rlp = __toESM(require_dist(), 1);

// node_modules/web3-eth-accounts/lib/esm/tx/baseTransaction.js
init_shim();

// node_modules/web3-eth-accounts/lib/esm/common/common.js
init_shim();
var import_crc_32 = __toESM(require_crc32(), 1);

// node_modules/web3-eth-accounts/lib/esm/common/chains/goerli.js
init_shim();
var goerli_default = {
  "name": "goerli",
  "chainId": 5,
  "networkId": 5,
  "defaultHardfork": "merge",
  "consensus": {
    "type": "poa",
    "algorithm": "clique",
    "clique": {
      "period": 15,
      "epoch": 3e4
    }
  },
  "comment": "Cross-client PoA test network",
  "url": "https://github.com/goerli/testnet",
  "genesis": {
    "timestamp": "0x5c51a607",
    "gasLimit": 10485760,
    "difficulty": 1,
    "nonce": "0x0000000000000000",
    "extraData": "0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
  },
  "hardforks": [
    {
      "name": "chainstart",
      "block": 0,
      "forkHash": "0xa3f5ab08"
    },
    {
      "name": "homestead",
      "block": 0,
      "forkHash": "0xa3f5ab08"
    },
    {
      "name": "tangerineWhistle",
      "block": 0,
      "forkHash": "0xa3f5ab08"
    },
    {
      "name": "spuriousDragon",
      "block": 0,
      "forkHash": "0xa3f5ab08"
    },
    {
      "name": "byzantium",
      "block": 0,
      "forkHash": "0xa3f5ab08"
    },
    {
      "name": "constantinople",
      "block": 0,
      "forkHash": "0xa3f5ab08"
    },
    {
      "name": "petersburg",
      "block": 0,
      "forkHash": "0xa3f5ab08"
    },
    {
      "name": "istanbul",
      "block": 1561651,
      "forkHash": "0xc25efa5c"
    },
    {
      "name": "berlin",
      "block": 4460644,
      "forkHash": "0x757a1c47"
    },
    {
      "name": "london",
      "block": 5062605,
      "forkHash": "0xb8c6299d"
    },
    {
      "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818",
      "name": "merge",
      "ttd": "10790000",
      "block": 7382819,
      "forkHash": "0xb8c6299d"
    },
    {
      "name": "mergeForkIdTransition",
      "block": null,
      "forkHash": null
    },
    {
      "name": "shanghai",
      "block": null,
      "forkHash": null
    }
  ],
  "bootstrapNodes": [],
  "dnsNetworks": [
    "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net"
  ]
};

// node_modules/web3-eth-accounts/lib/esm/common/chains/mainnet.js
init_shim();
var mainnet_default = {
  "name": "mainnet",
  "chainId": 1,
  "networkId": 1,
  "defaultHardfork": "merge",
  "consensus": {
    "type": "pow",
    "algorithm": "ethash",
    "ethash": {}
  },
  "comment": "The Ethereum main chain",
  "url": "https://ethstats.net/",
  "genesis": {
    "gasLimit": 5e3,
    "difficulty": 17179869184,
    "nonce": "0x0000000000000042",
    "extraData": "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"
  },
  "hardforks": [
    {
      "name": "chainstart",
      "block": 0,
      "forkHash": "0xfc64ec04"
    },
    {
      "name": "homestead",
      "block": 115e4,
      "forkHash": "0x97c2c34c"
    },
    {
      "name": "dao",
      "block": 192e4,
      "forkHash": "0x91d1f948"
    },
    {
      "name": "tangerineWhistle",
      "block": 2463e3,
      "forkHash": "0x7a64da13"
    },
    {
      "name": "spuriousDragon",
      "block": 2675e3,
      "forkHash": "0x3edd5b10"
    },
    {
      "name": "byzantium",
      "block": 437e4,
      "forkHash": "0xa00bc324"
    },
    {
      "name": "constantinople",
      "block": 728e4,
      "forkHash": "0x668db0af"
    },
    {
      "name": "petersburg",
      "block": 728e4,
      "forkHash": "0x668db0af"
    },
    {
      "name": "istanbul",
      "block": 9069e3,
      "forkHash": "0x879d6e30"
    },
    {
      "name": "muirGlacier",
      "block": 92e5,
      "forkHash": "0xe029e991"
    },
    {
      "name": "berlin",
      "block": 12244e3,
      "forkHash": "0x0eb440f6"
    },
    {
      "name": "london",
      "block": 12965e3,
      "forkHash": "0xb715077d"
    },
    {
      "name": "arrowGlacier",
      "block": 13773e3,
      "forkHash": "0x20c327fc"
    },
    {
      "name": "grayGlacier",
      "block": 1505e4,
      "forkHash": "0xf0afd0e3"
    },
    {
      "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393",
      "name": "merge",
      "ttd": "58750000000000000000000",
      "block": 15537394,
      "forkHash": "0xf0afd0e3"
    },
    {
      "name": "mergeForkIdTransition",
      "block": null,
      "forkHash": null
    },
    {
      "name": "shanghai",
      "block": null,
      "forkHash": null
    }
  ],
  "bootstrapNodes": [],
  "dnsNetworks": [
    "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net"
  ]
};

// node_modules/web3-eth-accounts/lib/esm/common/chains/sepolia.js
init_shim();
var sepolia_default = {
  "name": "sepolia",
  "chainId": 11155111,
  "networkId": 11155111,
  "defaultHardfork": "merge",
  "consensus": {
    "type": "pow",
    "algorithm": "ethash",
    "ethash": {}
  },
  "comment": "PoW test network to replace Ropsten",
  "url": "https://github.com/ethereum/go-ethereum/pull/23730",
  "genesis": {
    "timestamp": "0x6159af19",
    "gasLimit": 3e7,
    "difficulty": 131072,
    "nonce": "0x0000000000000000",
    "extraData": "0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521"
  },
  "hardforks": [
    {
      "name": "chainstart",
      "block": 0,
      "forkHash": "0xfe3366e7"
    },
    {
      "name": "homestead",
      "block": 0,
      "forkHash": "0xfe3366e7"
    },
    {
      "name": "tangerineWhistle",
      "block": 0,
      "forkHash": "0xfe3366e7"
    },
    {
      "name": "spuriousDragon",
      "block": 0,
      "forkHash": "0xfe3366e7"
    },
    {
      "name": "byzantium",
      "block": 0,
      "forkHash": "0xfe3366e7"
    },
    {
      "name": "constantinople",
      "block": 0,
      "forkHash": "0xfe3366e7"
    },
    {
      "name": "petersburg",
      "block": 0,
      "forkHash": "0xfe3366e7"
    },
    {
      "name": "istanbul",
      "block": 0,
      "forkHash": "0xfe3366e7"
    },
    {
      "name": "muirGlacier",
      "block": 0,
      "forkHash": "0xfe3366e7"
    },
    {
      "name": "berlin",
      "block": 0,
      "forkHash": "0xfe3366e7"
    },
    {
      "name": "london",
      "block": 0,
      "forkHash": "0xfe3366e7"
    },
    {
      "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408",
      "name": "merge",
      "ttd": "17000000000000000",
      "block": 1450409,
      "forkHash": "0xfe3366e7"
    },
    {
      "name": "mergeForkIdTransition",
      "block": 1735371,
      "forkHash": "0xb96cbd13"
    },
    {
      "name": "shanghai",
      "block": null,
      "timestamp": "1677557088",
      "forkHash": "0xf7f9bc08"
    }
  ],
  "bootstrapNodes": [],
  "dnsNetworks": [
    "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net"
  ]
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/index.js
init_shim();

// node_modules/web3-eth-accounts/lib/esm/common/eips/1153.js
init_shim();
var __default = {
  "name": "EIP-1153",
  "number": 1153,
  "comment": "Transient Storage",
  "url": "https://eips.ethereum.org/EIPS/eip-1153",
  "status": "Review",
  "minimumHardfork": "chainstart",
  "requiredEIPs": [],
  "gasConfig": {},
  "gasPrices": {
    "tstore": {
      "v": 100,
      "d": "Base fee of the TSTORE opcode"
    },
    "tload": {
      "v": 100,
      "d": "Base fee of the TLOAD opcode"
    }
  },
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/1559.js
init_shim();
var __default2 = {
  "name": "EIP-1559",
  "number": 1559,
  "comment": "Fee market change for ETH 1.0 chain",
  "url": "https://eips.ethereum.org/EIPS/eip-1559",
  "status": "Final",
  "minimumHardfork": "berlin",
  "requiredEIPs": [2930],
  "gasConfig": {
    "baseFeeMaxChangeDenominator": {
      "v": 8,
      "d": "Maximum base fee change denominator"
    },
    "elasticityMultiplier": {
      "v": 2,
      "d": "Maximum block gas target elasticity"
    },
    "initialBaseFee": {
      "v": 1e9,
      "d": "Initial base fee on first EIP1559 block"
    }
  },
  "gasPrices": {},
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/2315.js
init_shim();
var __default3 = {
  "name": "EIP-2315",
  "number": 2315,
  "comment": "Simple subroutines for the EVM",
  "url": "https://eips.ethereum.org/EIPS/eip-2315",
  "status": "Draft",
  "minimumHardfork": "istanbul",
  "gasConfig": {},
  "gasPrices": {
    "beginsub": {
      "v": 2,
      "d": "Base fee of the BEGINSUB opcode"
    },
    "returnsub": {
      "v": 5,
      "d": "Base fee of the RETURNSUB opcode"
    },
    "jumpsub": {
      "v": 10,
      "d": "Base fee of the JUMPSUB opcode"
    }
  },
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/2537.js
init_shim();
var __default4 = {
  "name": "EIP-2537",
  "number": 2537,
  "comment": "BLS12-381 precompiles",
  "url": "https://eips.ethereum.org/EIPS/eip-2537",
  "status": "Draft",
  "minimumHardfork": "chainstart",
  "gasConfig": {},
  "gasPrices": {
    "Bls12381G1AddGas": {
      "v": 600,
      "d": "Gas cost of a single BLS12-381 G1 addition precompile-call"
    },
    "Bls12381G1MulGas": {
      "v": 12e3,
      "d": "Gas cost of a single BLS12-381 G1 multiplication precompile-call"
    },
    "Bls12381G2AddGas": {
      "v": 4500,
      "d": "Gas cost of a single BLS12-381 G2 addition precompile-call"
    },
    "Bls12381G2MulGas": {
      "v": 55e3,
      "d": "Gas cost of a single BLS12-381 G2 multiplication precompile-call"
    },
    "Bls12381PairingBaseGas": {
      "v": 115e3,
      "d": "Base gas cost of BLS12-381 pairing check"
    },
    "Bls12381PairingPerPairGas": {
      "v": 23e3,
      "d": "Per-pair gas cost of BLS12-381 pairing check"
    },
    "Bls12381MapG1Gas": {
      "v": 5500,
      "d": "Gas cost of BLS12-381 map field element to G1"
    },
    "Bls12381MapG2Gas": {
      "v": 11e4,
      "d": "Gas cost of BLS12-381 map field element to G2"
    },
    "Bls12381MultiExpGasDiscount": {
      "v": [
        [1, 1200],
        [2, 888],
        [3, 764],
        [4, 641],
        [5, 594],
        [6, 547],
        [7, 500],
        [8, 453],
        [9, 438],
        [10, 423],
        [11, 408],
        [12, 394],
        [13, 379],
        [14, 364],
        [15, 349],
        [16, 334],
        [17, 330],
        [18, 326],
        [19, 322],
        [20, 318],
        [21, 314],
        [22, 310],
        [23, 306],
        [24, 302],
        [25, 298],
        [26, 294],
        [27, 289],
        [28, 285],
        [29, 281],
        [30, 277],
        [31, 273],
        [32, 269],
        [33, 268],
        [34, 266],
        [35, 265],
        [36, 263],
        [37, 262],
        [38, 260],
        [39, 259],
        [40, 257],
        [41, 256],
        [42, 254],
        [43, 253],
        [44, 251],
        [45, 250],
        [46, 248],
        [47, 247],
        [48, 245],
        [49, 244],
        [50, 242],
        [51, 241],
        [52, 239],
        [53, 238],
        [54, 236],
        [55, 235],
        [56, 233],
        [57, 232],
        [58, 231],
        [59, 229],
        [60, 228],
        [61, 226],
        [62, 225],
        [63, 223],
        [64, 222],
        [65, 221],
        [66, 220],
        [67, 219],
        [68, 219],
        [69, 218],
        [70, 217],
        [71, 216],
        [72, 216],
        [73, 215],
        [74, 214],
        [75, 213],
        [76, 213],
        [77, 212],
        [78, 211],
        [79, 211],
        [80, 210],
        [81, 209],
        [82, 208],
        [83, 208],
        [84, 207],
        [85, 206],
        [86, 205],
        [87, 205],
        [88, 204],
        [89, 203],
        [90, 202],
        [91, 202],
        [92, 201],
        [93, 200],
        [94, 199],
        [95, 199],
        [96, 198],
        [97, 197],
        [98, 196],
        [99, 196],
        [100, 195],
        [101, 194],
        [102, 193],
        [103, 193],
        [104, 192],
        [105, 191],
        [106, 191],
        [107, 190],
        [108, 189],
        [109, 188],
        [110, 188],
        [111, 187],
        [112, 186],
        [113, 185],
        [114, 185],
        [115, 184],
        [116, 183],
        [117, 182],
        [118, 182],
        [119, 181],
        [120, 180],
        [121, 179],
        [122, 179],
        [123, 178],
        [124, 177],
        [125, 176],
        [126, 176],
        [127, 175],
        [128, 174]
      ],
      "d": "Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair"
    }
  },
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/2565.js
init_shim();
var __default5 = {
  "name": "EIP-2565",
  "number": 2565,
  "comment": "ModExp gas cost",
  "url": "https://eips.ethereum.org/EIPS/eip-2565",
  "status": "Final",
  "minimumHardfork": "byzantium",
  "gasConfig": {},
  "gasPrices": {
    "modexpGquaddivisor": {
      "v": 3,
      "d": "Gquaddivisor from modexp precompile for gas calculation"
    }
  },
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/2718.js
init_shim();
var __default6 = {
  "name": "EIP-2718",
  "comment": "Typed Transaction Envelope",
  "url": "https://eips.ethereum.org/EIPS/eip-2718",
  "status": "Final",
  "minimumHardfork": "chainstart",
  "gasConfig": {},
  "gasPrices": {},
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/2929.js
init_shim();
var __default7 = {
  "name": "EIP-2929",
  "comment": "Gas cost increases for state access opcodes",
  "url": "https://eips.ethereum.org/EIPS/eip-2929",
  "status": "Final",
  "minimumHardfork": "chainstart",
  "gasConfig": {},
  "gasPrices": {
    "coldsload": {
      "v": 2100,
      "d": "Gas cost of the first read of storage from a given location (per transaction)"
    },
    "coldaccountaccess": {
      "v": 2600,
      "d": "Gas cost of the first read of a given address (per transaction)"
    },
    "warmstorageread": {
      "v": 100,
      "d": "Gas cost of reading storage locations which have already loaded 'cold'"
    },
    "sstoreCleanGasEIP2200": {
      "v": 2900,
      "d": "Once per SSTORE operation from clean non-zero to something else"
    },
    "sstoreNoopGasEIP2200": {
      "v": 100,
      "d": "Once per SSTORE operation if the value doesn't change"
    },
    "sstoreDirtyGasEIP2200": {
      "v": 100,
      "d": "Once per SSTORE operation if a dirty value is changed"
    },
    "sstoreInitRefundEIP2200": {
      "v": 19900,
      "d": "Once per SSTORE operation for resetting to the original zero value"
    },
    "sstoreCleanRefundEIP2200": {
      "v": 4900,
      "d": "Once per SSTORE operation for resetting to the original non-zero value"
    },
    "call": {
      "v": 0,
      "d": "Base fee of the CALL opcode"
    },
    "callcode": {
      "v": 0,
      "d": "Base fee of the CALLCODE opcode"
    },
    "delegatecall": {
      "v": 0,
      "d": "Base fee of the DELEGATECALL opcode"
    },
    "staticcall": {
      "v": 0,
      "d": "Base fee of the STATICCALL opcode"
    },
    "balance": {
      "v": 0,
      "d": "Base fee of the BALANCE opcode"
    },
    "extcodesize": {
      "v": 0,
      "d": "Base fee of the EXTCODESIZE opcode"
    },
    "extcodecopy": {
      "v": 0,
      "d": "Base fee of the EXTCODECOPY opcode"
    },
    "extcodehash": {
      "v": 0,
      "d": "Base fee of the EXTCODEHASH opcode"
    },
    "sload": {
      "v": 0,
      "d": "Base fee of the SLOAD opcode"
    },
    "sstore": {
      "v": 0,
      "d": "Base fee of the SSTORE opcode"
    }
  },
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/2930.js
init_shim();
var __default8 = {
  "name": "EIP-2930",
  "comment": "Optional access lists",
  "url": "https://eips.ethereum.org/EIPS/eip-2930",
  "status": "Final",
  "minimumHardfork": "istanbul",
  "requiredEIPs": [2718, 2929],
  "gasConfig": {},
  "gasPrices": {
    "accessListStorageKeyCost": {
      "v": 1900,
      "d": "Gas cost per storage key in an Access List transaction"
    },
    "accessListAddressCost": {
      "v": 2400,
      "d": "Gas cost per storage key in an Access List transaction"
    }
  },
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3198.js
init_shim();
var __default9 = {
  "name": "EIP-3198",
  "number": 3198,
  "comment": "BASEFEE opcode",
  "url": "https://eips.ethereum.org/EIPS/eip-3198",
  "status": "Final",
  "minimumHardfork": "london",
  "gasConfig": {},
  "gasPrices": {
    "basefee": {
      "v": 2,
      "d": "Gas cost of the BASEFEE opcode"
    }
  },
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3529.js
init_shim();
var __default10 = {
  "name": "EIP-3529",
  "comment": "Reduction in refunds",
  "url": "https://eips.ethereum.org/EIPS/eip-3529",
  "status": "Final",
  "minimumHardfork": "berlin",
  "requiredEIPs": [2929],
  "gasConfig": {
    "maxRefundQuotient": {
      "v": 5,
      "d": "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
    }
  },
  "gasPrices": {
    "selfdestructRefund": {
      "v": 0,
      "d": "Refunded following a selfdestruct operation"
    },
    "sstoreClearRefundEIP2200": {
      "v": 4800,
      "d": "Once per SSTORE operation for clearing an originally existing storage slot"
    }
  },
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3540.js
init_shim();
var __default11 = {
  "name": "EIP-3540",
  "number": 3540,
  "comment": "EVM Object Format (EOF) v1",
  "url": "https://eips.ethereum.org/EIPS/eip-3540",
  "status": "Review",
  "minimumHardfork": "london",
  "requiredEIPs": [3541],
  "gasConfig": {},
  "gasPrices": {},
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3541.js
init_shim();
var __default12 = {
  "name": "EIP-3541",
  "comment": "Reject new contracts starting with the 0xEF byte",
  "url": "https://eips.ethereum.org/EIPS/eip-3541",
  "status": "Final",
  "minimumHardfork": "berlin",
  "requiredEIPs": [],
  "gasConfig": {},
  "gasPrices": {},
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3554.js
init_shim();
var __default13 = {
  "name": "EIP-3554",
  "comment": "Reduction in refunds",
  "url": "Difficulty Bomb Delay to December 1st 2021",
  "status": "Final",
  "minimumHardfork": "muirGlacier",
  "requiredEIPs": [],
  "gasConfig": {},
  "gasPrices": {},
  "vm": {},
  "pow": {
    "difficultyBombDelay": {
      "v": 95e5,
      "d": "the amount of blocks to delay the difficulty bomb with"
    }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3607.js
init_shim();
var __default14 = {
  "name": "EIP-3607",
  "number": 3607,
  "comment": "Reject transactions from senders with deployed code",
  "url": "https://eips.ethereum.org/EIPS/eip-3607",
  "status": "Final",
  "minimumHardfork": "chainstart",
  "requiredEIPs": [],
  "gasConfig": {},
  "gasPrices": {},
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3651.js
init_shim();
var __default15 = {
  "name": "EIP-3651",
  "number": 3198,
  "comment": "Warm COINBASE",
  "url": "https://eips.ethereum.org/EIPS/eip-3651",
  "status": "Review",
  "minimumHardfork": "london",
  "requiredEIPs": [2929],
  "gasConfig": {},
  "gasPrices": {},
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3670.js
init_shim();
var __default16 = {
  "name": "EIP-3670",
  "number": 3670,
  "comment": "EOF - Code Validation",
  "url": "https://eips.ethereum.org/EIPS/eip-3670",
  "status": "Review",
  "minimumHardfork": "london",
  "requiredEIPs": [3540],
  "gasConfig": {},
  "gasPrices": {},
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3675.js
init_shim();
var __default17 = {
  "name": "EIP-3675",
  "number": 3675,
  "comment": "Upgrade consensus to Proof-of-Stake",
  "url": "https://eips.ethereum.org/EIPS/eip-3675",
  "status": "Final",
  "minimumHardfork": "london",
  "requiredEIPs": [],
  "gasConfig": {},
  "gasPrices": {},
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3855.js
init_shim();
var __default18 = {
  "name": "EIP-3855",
  "number": 3855,
  "comment": "PUSH0 instruction",
  "url": "https://eips.ethereum.org/EIPS/eip-3855",
  "status": "Review",
  "minimumHardfork": "chainstart",
  "requiredEIPs": [],
  "gasConfig": {},
  "gasPrices": {
    "push0": {
      "v": 2,
      "d": "Base fee of the PUSH0 opcode"
    }
  },
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3860.js
init_shim();
var __default19 = {
  "name": "EIP-3860",
  "number": 3860,
  "comment": "Limit and meter initcode",
  "url": "https://eips.ethereum.org/EIPS/eip-3860",
  "status": "Review",
  "minimumHardfork": "spuriousDragon",
  "requiredEIPs": [],
  "gasConfig": {},
  "gasPrices": {
    "initCodeWordCost": {
      "v": 2,
      "d": "Gas to pay for each word (32 bytes) of initcode when creating a contract"
    }
  },
  "vm": {
    "maxInitCodeSize": {
      "v": 49152,
      "d": "Maximum length of initialization code when creating a contract"
    }
  },
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/4345.js
init_shim();
var __default20 = {
  "name": "EIP-4345",
  "number": 4345,
  "comment": "Difficulty Bomb Delay to June 2022",
  "url": "https://eips.ethereum.org/EIPS/eip-4345",
  "status": "Final",
  "minimumHardfork": "london",
  "gasConfig": {},
  "gasPrices": {},
  "vm": {},
  "pow": {
    "difficultyBombDelay": {
      "v": 107e5,
      "d": "the amount of blocks to delay the difficulty bomb with"
    }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/4399.js
init_shim();
var __default21 = {
  "name": "EIP-4399",
  "number": 4399,
  "comment": "Supplant DIFFICULTY opcode with PREVRANDAO",
  "url": "https://eips.ethereum.org/EIPS/eip-4399",
  "status": "Review",
  "minimumHardfork": "london",
  "requiredEIPs": [],
  "gasConfig": {},
  "gasPrices": {},
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/5133.js
init_shim();
var __default22 = {
  "name": "EIP-5133",
  "number": 5133,
  "comment": "Delaying Difficulty Bomb to mid-September 2022",
  "url": "https://eips.ethereum.org/EIPS/eip-5133",
  "status": "Draft",
  "minimumHardfork": "grayGlacier",
  "gasConfig": {},
  "gasPrices": {},
  "vm": {},
  "pow": {
    "difficultyBombDelay": {
      "v": 114e5,
      "d": "the amount of blocks to delay the difficulty bomb with"
    }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/index.js
var EIPs = {
  1153: __default,
  1559: __default2,
  2315: __default3,
  2537: __default4,
  2565: __default5,
  2718: __default6,
  2929: __default7,
  2930: __default8,
  3198: __default9,
  3529: __default10,
  3540: __default11,
  3541: __default12,
  3554: __default13,
  3607: __default14,
  3651: __default15,
  3670: __default16,
  3675: __default17,
  3855: __default18,
  3860: __default19,
  4345: __default20,
  4399: __default21,
  5133: __default22
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/index.js
init_shim();

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/chainstart.js
init_shim();
var chainstart_default = {
  "name": "chainstart",
  "comment": "Start of the Ethereum main chain",
  "url": "",
  "status": "",
  "gasConfig": {
    "minGasLimit": {
      "v": 5e3,
      "d": "Minimum the gas limit may ever be"
    },
    "gasLimitBoundDivisor": {
      "v": 1024,
      "d": "The bound divisor of the gas limit, used in update calculations"
    },
    "maxRefundQuotient": {
      "v": 2,
      "d": "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
    }
  },
  "gasPrices": {
    "base": {
      "v": 2,
      "d": "Gas base cost, used e.g. for ChainID opcode (Istanbul)"
    },
    "tierStep": {
      "v": [0, 2, 3, 5, 8, 10, 20],
      "d": "Once per operation, for a selection of them"
    },
    "exp": {
      "v": 10,
      "d": "Base fee of the EXP opcode"
    },
    "expByte": {
      "v": 10,
      "d": "Times ceil(log256(exponent)) for the EXP instruction"
    },
    "sha3": {
      "v": 30,
      "d": "Base fee of the SHA3 opcode"
    },
    "sha3Word": {
      "v": 6,
      "d": "Once per word of the SHA3 operation's data"
    },
    "sload": {
      "v": 50,
      "d": "Base fee of the SLOAD opcode"
    },
    "sstoreSet": {
      "v": 2e4,
      "d": "Once per SSTORE operation if the zeroness changes from zero"
    },
    "sstoreReset": {
      "v": 5e3,
      "d": "Once per SSTORE operation if the zeroness does not change from zero"
    },
    "sstoreRefund": {
      "v": 15e3,
      "d": "Once per SSTORE operation if the zeroness changes to zero"
    },
    "jumpdest": {
      "v": 1,
      "d": "Base fee of the JUMPDEST opcode"
    },
    "log": {
      "v": 375,
      "d": "Base fee of the LOG opcode"
    },
    "logData": {
      "v": 8,
      "d": "Per byte in a LOG* operation's data"
    },
    "logTopic": {
      "v": 375,
      "d": "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas"
    },
    "create": {
      "v": 32e3,
      "d": "Base fee of the CREATE opcode"
    },
    "call": {
      "v": 40,
      "d": "Base fee of the CALL opcode"
    },
    "callStipend": {
      "v": 2300,
      "d": "Free gas given at beginning of call"
    },
    "callValueTransfer": {
      "v": 9e3,
      "d": "Paid for CALL when the value transfor is non-zero"
    },
    "callNewAccount": {
      "v": 25e3,
      "d": "Paid for CALL when the destination address didn't exist prior"
    },
    "selfdestructRefund": {
      "v": 24e3,
      "d": "Refunded following a selfdestruct operation"
    },
    "memory": {
      "v": 3,
      "d": "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL"
    },
    "quadCoeffDiv": {
      "v": 512,
      "d": "Divisor for the quadratic particle of the memory cost equation"
    },
    "createData": {
      "v": 200,
      "d": ""
    },
    "tx": {
      "v": 21e3,
      "d": "Per transaction. NOTE: Not payable on data of calls between transactions"
    },
    "txCreation": {
      "v": 32e3,
      "d": "The cost of creating a contract via tx"
    },
    "txDataZero": {
      "v": 4,
      "d": "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions"
    },
    "txDataNonZero": {
      "v": 68,
      "d": "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
    },
    "copy": {
      "v": 3,
      "d": "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added"
    },
    "ecRecover": {
      "v": 3e3,
      "d": ""
    },
    "sha256": {
      "v": 60,
      "d": ""
    },
    "sha256Word": {
      "v": 12,
      "d": ""
    },
    "ripemd160": {
      "v": 600,
      "d": ""
    },
    "ripemd160Word": {
      "v": 120,
      "d": ""
    },
    "identity": {
      "v": 15,
      "d": ""
    },
    "identityWord": {
      "v": 3,
      "d": ""
    },
    "stop": {
      "v": 0,
      "d": "Base fee of the STOP opcode"
    },
    "add": {
      "v": 3,
      "d": "Base fee of the ADD opcode"
    },
    "mul": {
      "v": 5,
      "d": "Base fee of the MUL opcode"
    },
    "sub": {
      "v": 3,
      "d": "Base fee of the SUB opcode"
    },
    "div": {
      "v": 5,
      "d": "Base fee of the DIV opcode"
    },
    "sdiv": {
      "v": 5,
      "d": "Base fee of the SDIV opcode"
    },
    "mod": {
      "v": 5,
      "d": "Base fee of the MOD opcode"
    },
    "smod": {
      "v": 5,
      "d": "Base fee of the SMOD opcode"
    },
    "addmod": {
      "v": 8,
      "d": "Base fee of the ADDMOD opcode"
    },
    "mulmod": {
      "v": 8,
      "d": "Base fee of the MULMOD opcode"
    },
    "signextend": {
      "v": 5,
      "d": "Base fee of the SIGNEXTEND opcode"
    },
    "lt": {
      "v": 3,
      "d": "Base fee of the LT opcode"
    },
    "gt": {
      "v": 3,
      "d": "Base fee of the GT opcode"
    },
    "slt": {
      "v": 3,
      "d": "Base fee of the SLT opcode"
    },
    "sgt": {
      "v": 3,
      "d": "Base fee of the SGT opcode"
    },
    "eq": {
      "v": 3,
      "d": "Base fee of the EQ opcode"
    },
    "iszero": {
      "v": 3,
      "d": "Base fee of the ISZERO opcode"
    },
    "and": {
      "v": 3,
      "d": "Base fee of the AND opcode"
    },
    "or": {
      "v": 3,
      "d": "Base fee of the OR opcode"
    },
    "xor": {
      "v": 3,
      "d": "Base fee of the XOR opcode"
    },
    "not": {
      "v": 3,
      "d": "Base fee of the NOT opcode"
    },
    "byte": {
      "v": 3,
      "d": "Base fee of the BYTE opcode"
    },
    "address": {
      "v": 2,
      "d": "Base fee of the ADDRESS opcode"
    },
    "balance": {
      "v": 20,
      "d": "Base fee of the BALANCE opcode"
    },
    "origin": {
      "v": 2,
      "d": "Base fee of the ORIGIN opcode"
    },
    "caller": {
      "v": 2,
      "d": "Base fee of the CALLER opcode"
    },
    "callvalue": {
      "v": 2,
      "d": "Base fee of the CALLVALUE opcode"
    },
    "calldataload": {
      "v": 3,
      "d": "Base fee of the CALLDATALOAD opcode"
    },
    "calldatasize": {
      "v": 2,
      "d": "Base fee of the CALLDATASIZE opcode"
    },
    "calldatacopy": {
      "v": 3,
      "d": "Base fee of the CALLDATACOPY opcode"
    },
    "codesize": {
      "v": 2,
      "d": "Base fee of the CODESIZE opcode"
    },
    "codecopy": {
      "v": 3,
      "d": "Base fee of the CODECOPY opcode"
    },
    "gasprice": {
      "v": 2,
      "d": "Base fee of the GASPRICE opcode"
    },
    "extcodesize": {
      "v": 20,
      "d": "Base fee of the EXTCODESIZE opcode"
    },
    "extcodecopy": {
      "v": 20,
      "d": "Base fee of the EXTCODECOPY opcode"
    },
    "blockhash": {
      "v": 20,
      "d": "Base fee of the BLOCKHASH opcode"
    },
    "coinbase": {
      "v": 2,
      "d": "Base fee of the COINBASE opcode"
    },
    "timestamp": {
      "v": 2,
      "d": "Base fee of the TIMESTAMP opcode"
    },
    "number": {
      "v": 2,
      "d": "Base fee of the NUMBER opcode"
    },
    "difficulty": {
      "v": 2,
      "d": "Base fee of the DIFFICULTY opcode"
    },
    "gaslimit": {
      "v": 2,
      "d": "Base fee of the GASLIMIT opcode"
    },
    "pop": {
      "v": 2,
      "d": "Base fee of the POP opcode"
    },
    "mload": {
      "v": 3,
      "d": "Base fee of the MLOAD opcode"
    },
    "mstore": {
      "v": 3,
      "d": "Base fee of the MSTORE opcode"
    },
    "mstore8": {
      "v": 3,
      "d": "Base fee of the MSTORE8 opcode"
    },
    "sstore": {
      "v": 0,
      "d": "Base fee of the SSTORE opcode"
    },
    "jump": {
      "v": 8,
      "d": "Base fee of the JUMP opcode"
    },
    "jumpi": {
      "v": 10,
      "d": "Base fee of the JUMPI opcode"
    },
    "pc": {
      "v": 2,
      "d": "Base fee of the PC opcode"
    },
    "msize": {
      "v": 2,
      "d": "Base fee of the MSIZE opcode"
    },
    "gas": {
      "v": 2,
      "d": "Base fee of the GAS opcode"
    },
    "push": {
      "v": 3,
      "d": "Base fee of the PUSH opcode"
    },
    "dup": {
      "v": 3,
      "d": "Base fee of the DUP opcode"
    },
    "swap": {
      "v": 3,
      "d": "Base fee of the SWAP opcode"
    },
    "callcode": {
      "v": 40,
      "d": "Base fee of the CALLCODE opcode"
    },
    "return": {
      "v": 0,
      "d": "Base fee of the RETURN opcode"
    },
    "invalid": {
      "v": 0,
      "d": "Base fee of the INVALID opcode"
    },
    "selfdestruct": {
      "v": 0,
      "d": "Base fee of the SELFDESTRUCT opcode"
    }
  },
  "vm": {
    "stackLimit": {
      "v": 1024,
      "d": "Maximum size of VM stack allowed"
    },
    "callCreateDepth": {
      "v": 1024,
      "d": "Maximum depth of call/create stack"
    },
    "maxExtraDataSize": {
      "v": 32,
      "d": "Maximum size extra data may be after Genesis"
    }
  },
  "pow": {
    "minimumDifficulty": {
      "v": 131072,
      "d": "The minimum that the difficulty may ever be"
    },
    "difficultyBoundDivisor": {
      "v": 2048,
      "d": "The bound divisor of the difficulty, used in the update calculations"
    },
    "durationLimit": {
      "v": 13,
      "d": "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not"
    },
    "epochDuration": {
      "v": 3e4,
      "d": "Duration between proof-of-work epochs"
    },
    "timebombPeriod": {
      "v": 1e5,
      "d": "Exponential difficulty timebomb period"
    },
    "minerReward": {
      "v": "5000000000000000000",
      "d": "the amount a miner get rewarded for mining a block"
    },
    "difficultyBombDelay": {
      "v": 0,
      "d": "the amount of blocks to delay the difficulty bomb with"
    }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/dao.js
init_shim();
var dao_default = {
  "name": "dao",
  "comment": "DAO rescue hardfork",
  "url": "https://eips.ethereum.org/EIPS/eip-779",
  "status": "Final",
  "gasConfig": {},
  "gasPrices": {},
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/homestead.js
init_shim();
var homestead_default = {
  "name": "homestead",
  "comment": "Homestead hardfork with protocol and network changes",
  "url": "https://eips.ethereum.org/EIPS/eip-606",
  "status": "Final",
  "gasConfig": {},
  "gasPrices": {
    "delegatecall": {
      "v": 40,
      "d": "Base fee of the DELEGATECALL opcode"
    }
  },
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/tangerineWhistle.js
init_shim();
var tangerineWhistle_default = {
  "name": "tangerineWhistle",
  "comment": "Hardfork with gas cost changes for IO-heavy operations",
  "url": "https://eips.ethereum.org/EIPS/eip-608",
  "status": "Final",
  "gasConfig": {},
  "gasPrices": {
    "sload": {
      "v": 200,
      "d": "Once per SLOAD operation"
    },
    "call": {
      "v": 700,
      "d": "Once per CALL operation & message call transaction"
    },
    "extcodesize": {
      "v": 700,
      "d": "Base fee of the EXTCODESIZE opcode"
    },
    "extcodecopy": {
      "v": 700,
      "d": "Base fee of the EXTCODECOPY opcode"
    },
    "balance": {
      "v": 400,
      "d": "Base fee of the BALANCE opcode"
    },
    "delegatecall": {
      "v": 700,
      "d": "Base fee of the DELEGATECALL opcode"
    },
    "callcode": {
      "v": 700,
      "d": "Base fee of the CALLCODE opcode"
    },
    "selfdestruct": {
      "v": 5e3,
      "d": "Base fee of the SELFDESTRUCT opcode"
    }
  },
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/spuriousDragon.js
init_shim();
var spuriousDragon_default = {
  "name": "spuriousDragon",
  "comment": "HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit",
  "url": "https://eips.ethereum.org/EIPS/eip-607",
  "status": "Final",
  "gasConfig": {},
  "gasPrices": {
    "expByte": {
      "v": 50,
      "d": "Times ceil(log256(exponent)) for the EXP instruction"
    }
  },
  "vm": {
    "maxCodeSize": {
      "v": 24576,
      "d": "Maximum length of contract code"
    }
  },
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/byzantium.js
init_shim();
var byzantium_default = {
  "name": "byzantium",
  "comment": "Hardfork with new precompiles, instructions and other protocol changes",
  "url": "https://eips.ethereum.org/EIPS/eip-609",
  "status": "Final",
  "gasConfig": {},
  "gasPrices": {
    "modexpGquaddivisor": {
      "v": 20,
      "d": "Gquaddivisor from modexp precompile for gas calculation"
    },
    "ecAdd": {
      "v": 500,
      "d": "Gas costs for curve addition precompile"
    },
    "ecMul": {
      "v": 4e4,
      "d": "Gas costs for curve multiplication precompile"
    },
    "ecPairing": {
      "v": 1e5,
      "d": "Base gas costs for curve pairing precompile"
    },
    "ecPairingWord": {
      "v": 8e4,
      "d": "Gas costs regarding curve pairing precompile input length"
    },
    "revert": {
      "v": 0,
      "d": "Base fee of the REVERT opcode"
    },
    "staticcall": {
      "v": 700,
      "d": "Base fee of the STATICCALL opcode"
    },
    "returndatasize": {
      "v": 2,
      "d": "Base fee of the RETURNDATASIZE opcode"
    },
    "returndatacopy": {
      "v": 3,
      "d": "Base fee of the RETURNDATACOPY opcode"
    }
  },
  "vm": {},
  "pow": {
    "minerReward": {
      "v": "3000000000000000000",
      "d": "the amount a miner get rewarded for mining a block"
    },
    "difficultyBombDelay": {
      "v": 3e6,
      "d": "the amount of blocks to delay the difficulty bomb with"
    }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/constantinople.js
init_shim();
var constantinople_default = {
  "name": "constantinople",
  "comment": "Postponed hardfork including EIP-1283 (SSTORE gas metering changes)",
  "url": "https://eips.ethereum.org/EIPS/eip-1013",
  "status": "Final",
  "gasConfig": {},
  "gasPrices": {
    "netSstoreNoopGas": {
      "v": 200,
      "d": "Once per SSTORE operation if the value doesn't change"
    },
    "netSstoreInitGas": {
      "v": 2e4,
      "d": "Once per SSTORE operation from clean zero"
    },
    "netSstoreCleanGas": {
      "v": 5e3,
      "d": "Once per SSTORE operation from clean non-zero"
    },
    "netSstoreDirtyGas": {
      "v": 200,
      "d": "Once per SSTORE operation from dirty"
    },
    "netSstoreClearRefund": {
      "v": 15e3,
      "d": "Once per SSTORE operation for clearing an originally existing storage slot"
    },
    "netSstoreResetRefund": {
      "v": 4800,
      "d": "Once per SSTORE operation for resetting to the original non-zero value"
    },
    "netSstoreResetClearRefund": {
      "v": 19800,
      "d": "Once per SSTORE operation for resetting to the original zero value"
    },
    "shl": {
      "v": 3,
      "d": "Base fee of the SHL opcode"
    },
    "shr": {
      "v": 3,
      "d": "Base fee of the SHR opcode"
    },
    "sar": {
      "v": 3,
      "d": "Base fee of the SAR opcode"
    },
    "extcodehash": {
      "v": 400,
      "d": "Base fee of the EXTCODEHASH opcode"
    },
    "create2": {
      "v": 32e3,
      "d": "Base fee of the CREATE2 opcode"
    }
  },
  "vm": {},
  "pow": {
    "minerReward": {
      "v": "2000000000000000000",
      "d": "The amount a miner gets rewarded for mining a block"
    },
    "difficultyBombDelay": {
      "v": 5e6,
      "d": "the amount of blocks to delay the difficulty bomb with"
    }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/petersburg.js
init_shim();
var petersburg_default = {
  "name": "petersburg",
  "comment": "Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople",
  "url": "https://eips.ethereum.org/EIPS/eip-1716",
  "status": "Final",
  "gasConfig": {},
  "gasPrices": {
    "netSstoreNoopGas": {
      "v": null,
      "d": "Removed along EIP-1283"
    },
    "netSstoreInitGas": {
      "v": null,
      "d": "Removed along EIP-1283"
    },
    "netSstoreCleanGas": {
      "v": null,
      "d": "Removed along EIP-1283"
    },
    "netSstoreDirtyGas": {
      "v": null,
      "d": "Removed along EIP-1283"
    },
    "netSstoreClearRefund": {
      "v": null,
      "d": "Removed along EIP-1283"
    },
    "netSstoreResetRefund": {
      "v": null,
      "d": "Removed along EIP-1283"
    },
    "netSstoreResetClearRefund": {
      "v": null,
      "d": "Removed along EIP-1283"
    }
  },
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/istanbul.js
init_shim();
var istanbul_default = {
  "name": "istanbul",
  "comment": "HF targeted for December 2019 following the Constantinople/Petersburg HF",
  "url": "https://eips.ethereum.org/EIPS/eip-1679",
  "status": "Final",
  "gasConfig": {},
  "gasPrices": {
    "blake2Round": {
      "v": 1,
      "d": "Gas cost per round for the Blake2 F precompile"
    },
    "ecAdd": {
      "v": 150,
      "d": "Gas costs for curve addition precompile"
    },
    "ecMul": {
      "v": 6e3,
      "d": "Gas costs for curve multiplication precompile"
    },
    "ecPairing": {
      "v": 45e3,
      "d": "Base gas costs for curve pairing precompile"
    },
    "ecPairingWord": {
      "v": 34e3,
      "d": "Gas costs regarding curve pairing precompile input length"
    },
    "txDataNonZero": {
      "v": 16,
      "d": "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
    },
    "sstoreSentryGasEIP2200": {
      "v": 2300,
      "d": "Minimum gas required to be present for an SSTORE call, not consumed"
    },
    "sstoreNoopGasEIP2200": {
      "v": 800,
      "d": "Once per SSTORE operation if the value doesn't change"
    },
    "sstoreDirtyGasEIP2200": {
      "v": 800,
      "d": "Once per SSTORE operation if a dirty value is changed"
    },
    "sstoreInitGasEIP2200": {
      "v": 2e4,
      "d": "Once per SSTORE operation from clean zero to non-zero"
    },
    "sstoreInitRefundEIP2200": {
      "v": 19200,
      "d": "Once per SSTORE operation for resetting to the original zero value"
    },
    "sstoreCleanGasEIP2200": {
      "v": 5e3,
      "d": "Once per SSTORE operation from clean non-zero to something else"
    },
    "sstoreCleanRefundEIP2200": {
      "v": 4200,
      "d": "Once per SSTORE operation for resetting to the original non-zero value"
    },
    "sstoreClearRefundEIP2200": {
      "v": 15e3,
      "d": "Once per SSTORE operation for clearing an originally existing storage slot"
    },
    "balance": {
      "v": 700,
      "d": "Base fee of the BALANCE opcode"
    },
    "extcodehash": {
      "v": 700,
      "d": "Base fee of the EXTCODEHASH opcode"
    },
    "chainid": {
      "v": 2,
      "d": "Base fee of the CHAINID opcode"
    },
    "selfbalance": {
      "v": 5,
      "d": "Base fee of the SELFBALANCE opcode"
    },
    "sload": {
      "v": 800,
      "d": "Base fee of the SLOAD opcode"
    }
  },
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/muirGlacier.js
init_shim();
var muirGlacier_default = {
  "name": "muirGlacier",
  "comment": "HF to delay the difficulty bomb",
  "url": "https://eips.ethereum.org/EIPS/eip-2384",
  "status": "Final",
  "gasConfig": {},
  "gasPrices": {},
  "vm": {},
  "pow": {
    "difficultyBombDelay": {
      "v": 9e6,
      "d": "the amount of blocks to delay the difficulty bomb with"
    }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/berlin.js
init_shim();
var berlin_default = {
  "name": "berlin",
  "comment": "HF targeted for July 2020 following the Muir Glacier HF",
  "url": "https://eips.ethereum.org/EIPS/eip-2070",
  "status": "Final",
  "eips": [2565, 2929, 2718, 2930]
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/london.js
init_shim();
var london_default = {
  "name": "london",
  "comment": "HF targeted for July 2021 following the Berlin fork",
  "url": "https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md",
  "status": "Final",
  "eips": [1559, 3198, 3529, 3541]
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/shanghai.js
init_shim();
var shanghai_default = {
  "name": "shanghai",
  "comment": "Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode",
  "url": "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md",
  "status": "Final",
  "eips": [3651, 3855, 3860, 4895]
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/arrowGlacier.js
init_shim();
var arrowGlacier_default = {
  "name": "arrowGlacier",
  "comment": "HF to delay the difficulty bomb",
  "url": "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md",
  "status": "Final",
  "eips": [4345],
  "gasConfig": {},
  "gasPrices": {},
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/grayGlacier.js
init_shim();
var grayGlacier_default = {
  "name": "grayGlacier",
  "comment": "Delaying the difficulty bomb to Mid September 2022",
  "url": "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md",
  "status": "Draft",
  "eips": [5133],
  "gasConfig": {},
  "gasPrices": {},
  "vm": {},
  "pow": {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/mergeForkIdTransition.js
init_shim();
var mergeForkIdTransition_default = {
  "name": "mergeForkIdTransition",
  "comment": "Pre-merge hardfork to fork off non-upgraded clients",
  "url": "https://eips.ethereum.org/EIPS/eip-3675",
  "status": "Draft",
  "eips": []
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/merge.js
init_shim();
var merge_default = {
  "name": "merge",
  "comment": "Hardfork to upgrade the consensus mechanism to Proof-of-Stake",
  "url": "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md",
  "status": "Final",
  "consensus": {
    "type": "pos",
    "algorithm": "casper",
    "casper": {}
  },
  "eips": [3675, 4399]
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/index.js
var hardforks = {
  chainstart: chainstart_default,
  homestead: homestead_default,
  dao: dao_default,
  tangerineWhistle: tangerineWhistle_default,
  spuriousDragon: spuriousDragon_default,
  byzantium: byzantium_default,
  constantinople: constantinople_default,
  petersburg: petersburg_default,
  istanbul: istanbul_default,
  muirGlacier: muirGlacier_default,
  berlin: berlin_default,
  london: london_default,
  shanghai: shanghai_default,
  arrowGlacier: arrowGlacier_default,
  grayGlacier: grayGlacier_default,
  mergeForkIdTransition: mergeForkIdTransition_default,
  merge: merge_default
};

// node_modules/web3-eth-accounts/lib/esm/common/common.js
var { buf: crc32Uint8Array } = import_crc_32.default;
var Common = class extends EventEmitter5 {
  constructor(opts) {
    var _a16, _b;
    super();
    this._eips = [];
    this._customChains = (_a16 = opts.customChains) !== null && _a16 !== void 0 ? _a16 : [];
    this._chainParams = this.setChain(opts.chain);
    this.DEFAULT_HARDFORK = (_b = this._chainParams.defaultHardfork) !== null && _b !== void 0 ? _b : Hardfork.Merge;
    this.HARDFORK_CHANGES = this.hardforks().map((hf) => [
      hf.name,
      hardforks[hf.name]
    ]);
    this._hardfork = this.DEFAULT_HARDFORK;
    if (opts.hardfork !== void 0) {
      this.setHardfork(opts.hardfork);
    }
    if (opts.eips) {
      this.setEIPs(opts.eips);
    }
  }
  static custom(chainParamsOrName, opts = {}) {
    var _a16;
    const baseChain = (_a16 = opts.baseChain) !== null && _a16 !== void 0 ? _a16 : "mainnet";
    const standardChainParams = Object.assign({}, Common._getChainParams(baseChain));
    standardChainParams.name = "custom-chain";
    if (typeof chainParamsOrName !== "string") {
      return new Common(Object.assign({ chain: Object.assign(Object.assign({}, standardChainParams), chainParamsOrName) }, opts));
    }
    if (chainParamsOrName === CustomChain.PolygonMainnet) {
      return Common.custom({
        name: CustomChain.PolygonMainnet,
        chainId: 137,
        networkId: 137
      }, opts);
    }
    if (chainParamsOrName === CustomChain.PolygonMumbai) {
      return Common.custom({
        name: CustomChain.PolygonMumbai,
        chainId: 80001,
        networkId: 80001
      }, opts);
    }
    if (chainParamsOrName === CustomChain.ArbitrumRinkebyTestnet) {
      return Common.custom({
        name: CustomChain.ArbitrumRinkebyTestnet,
        chainId: 421611,
        networkId: 421611
      }, opts);
    }
    if (chainParamsOrName === CustomChain.ArbitrumOne) {
      return Common.custom({
        name: CustomChain.ArbitrumOne,
        chainId: 42161,
        networkId: 42161
      }, opts);
    }
    if (chainParamsOrName === CustomChain.xDaiChain) {
      return Common.custom({
        name: CustomChain.xDaiChain,
        chainId: 100,
        networkId: 100
      }, opts);
    }
    if (chainParamsOrName === CustomChain.OptimisticKovan) {
      return Common.custom({
        name: CustomChain.OptimisticKovan,
        chainId: 69,
        networkId: 69
      }, Object.assign({ hardfork: Hardfork.Berlin }, opts));
    }
    if (chainParamsOrName === CustomChain.OptimisticEthereum) {
      return Common.custom({
        name: CustomChain.OptimisticEthereum,
        chainId: 10,
        networkId: 10
      }, Object.assign({ hardfork: Hardfork.Berlin }, opts));
    }
    throw new Error(`Custom chain ${chainParamsOrName} not supported`);
  }
  static fromGethGenesis(genesisJson, { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge }) {
    var _a16;
    const genesisParams = parseGethGenesis(genesisJson, chain, mergeForkIdPostMerge);
    const common = new Common({
      chain: (_a16 = genesisParams.name) !== null && _a16 !== void 0 ? _a16 : "custom",
      customChains: [genesisParams],
      eips,
      hardfork: hardfork !== null && hardfork !== void 0 ? hardfork : genesisParams.hardfork
    });
    if (genesisHash !== void 0) {
      common.setForkHashes(genesisHash);
    }
    return common;
  }
  static isSupportedChainId(chainId) {
    const initializedChains = this._getInitializedChains();
    return Boolean(initializedChains.names[chainId.toString()]);
  }
  static _getChainParams(_chain, customChains) {
    let chain = _chain;
    const initializedChains = this._getInitializedChains(customChains);
    if (typeof chain === "number" || typeof chain === "bigint") {
      chain = chain.toString();
      if (initializedChains.names[chain]) {
        const name2 = initializedChains.names[chain];
        return initializedChains[name2];
      }
      throw new Error(`Chain with ID ${chain} not supported`);
    }
    if (initializedChains[chain] !== void 0) {
      return initializedChains[chain];
    }
    throw new Error(`Chain with name ${chain} not supported`);
  }
  setChain(chain) {
    if (typeof chain === "number" || typeof chain === "bigint" || typeof chain === "string") {
      this._chainParams = Common._getChainParams(chain, this._customChains);
    } else if (typeof chain === "object") {
      if (this._customChains.length > 0) {
        throw new Error("Chain must be a string, number, or bigint when initialized with customChains passed in");
      }
      const required = ["networkId", "genesis", "hardforks", "bootstrapNodes"];
      for (const param of required) {
        if (!(param in chain)) {
          throw new Error(`Missing required chain parameter: ${param}`);
        }
      }
      this._chainParams = chain;
    } else {
      throw new Error("Wrong input format");
    }
    for (const hf of this.hardforks()) {
      if (hf.block === void 0) {
        throw new Error(`Hardfork cannot have undefined block number`);
      }
    }
    return this._chainParams;
  }
  setHardfork(hardfork) {
    let existing = false;
    for (const hfChanges of this.HARDFORK_CHANGES) {
      if (hfChanges[0] === hardfork) {
        if (this._hardfork !== hardfork) {
          this._hardfork = hardfork;
          this.emit("hardforkChanged", hardfork);
        }
        existing = true;
      }
    }
    if (!existing) {
      throw new Error(`Hardfork with name ${hardfork} not supported`);
    }
  }
  getHardforkByBlockNumber(_blockNumber, _td, _timestamp) {
    const blockNumber = toType(_blockNumber, TypeOutput.BigInt);
    const td = toType(_td, TypeOutput.BigInt);
    const timestamp = toType(_timestamp, TypeOutput.Number);
    const hfs = this.hardforks().filter((hf) => hf.block !== null || hf.ttd !== null && hf.ttd !== void 0 || hf.timestamp !== void 0);
    const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== void 0);
    const doubleTTDHF = hfs.slice(mergeIndex + 1).findIndex((hf) => hf.ttd !== null && hf.ttd !== void 0);
    if (doubleTTDHF >= 0) {
      throw Error(`More than one merge hardforks found with ttd specified`);
    }
    let hfIndex = hfs.findIndex((hf) => hf.block !== null && hf.block > blockNumber || timestamp !== void 0 && Number(hf.timestamp) > timestamp);
    if (hfIndex === -1) {
      hfIndex = hfs.length;
    } else if (hfIndex === 0) {
      throw Error("Must have at least one hardfork at block 0");
    }
    if (timestamp === void 0) {
      const stepBack = hfs.slice(0, hfIndex).reverse().findIndex((hf) => hf.block !== null || hf.ttd !== void 0);
      hfIndex -= stepBack;
    }
    hfIndex -= 1;
    if (hfs[hfIndex].block === null && hfs[hfIndex].timestamp === void 0) {
      if (td === void 0 || td === null || BigInt(hfs[hfIndex].ttd) > td) {
        hfIndex -= 1;
      }
    } else if (mergeIndex >= 0 && td !== void 0 && td !== null) {
      if (hfIndex >= mergeIndex && BigInt(hfs[mergeIndex].ttd) > td) {
        throw Error("Maximum HF determined by total difficulty is lower than the block number HF");
      } else if (hfIndex < mergeIndex && BigInt(hfs[mergeIndex].ttd) <= td) {
        throw Error("HF determined by block number is lower than the minimum total difficulty HF");
      }
    }
    const hfStartIndex = hfIndex;
    for (; hfIndex < hfs.length - 1; hfIndex += 1) {
      if (hfs[hfIndex].block !== hfs[hfIndex + 1].block || hfs[hfIndex].timestamp !== hfs[hfIndex + 1].timestamp) {
        break;
      }
    }
    if (timestamp) {
      const minTimeStamp = hfs.slice(0, hfStartIndex).reduce((acc, hf) => {
        var _a16;
        return Math.max(Number((_a16 = hf.timestamp) !== null && _a16 !== void 0 ? _a16 : "0"), acc);
      }, 0);
      if (minTimeStamp > timestamp) {
        throw Error(`Maximum HF determined by timestamp is lower than the block number/ttd HF`);
      }
      const maxTimeStamp = hfs.slice(hfIndex + 1).reduce((acc, hf) => {
        var _a16;
        return Math.min(Number((_a16 = hf.timestamp) !== null && _a16 !== void 0 ? _a16 : timestamp), acc);
      }, timestamp);
      if (maxTimeStamp < timestamp) {
        throw Error(`Maximum HF determined by block number/ttd is lower than timestamp HF`);
      }
    }
    const hardfork = hfs[hfIndex];
    return hardfork.name;
  }
  setHardforkByBlockNumber(blockNumber, td, timestamp) {
    const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);
    this.setHardfork(hardfork);
    return hardfork;
  }
  _getHardfork(hardfork) {
    const hfs = this.hardforks();
    for (const hf of hfs) {
      if (hf.name === hardfork)
        return hf;
    }
    return null;
  }
  setEIPs(eips = []) {
    for (const eip of eips) {
      if (!(eip in EIPs)) {
        throw new Error(`${eip} not supported`);
      }
      const minHF = this.gteHardfork(EIPs[eip].minimumHardfork);
      if (!minHF) {
        throw new Error(
          `${eip} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${minHF}`
        );
      }
      if (EIPs[eip].requiredEIPs !== void 0) {
        for (const elem of EIPs[eip].requiredEIPs) {
          if (!(eips.includes(elem) || this.isActivatedEIP(elem))) {
            throw new Error(
              `${eip} requires EIP ${elem}, but is not included in the EIP list`
            );
          }
        }
      }
    }
    this._eips = eips;
  }
  param(topic, name2) {
    let value;
    for (const eip of this._eips) {
      value = this.paramByEIP(topic, name2, eip);
      if (value !== void 0)
        return value;
    }
    return this.paramByHardfork(topic, name2, this._hardfork);
  }
  paramByHardfork(topic, name2, hardfork) {
    let value = null;
    for (const hfChanges of this.HARDFORK_CHANGES) {
      if ("eips" in hfChanges[1]) {
        const hfEIPs = hfChanges[1].eips;
        for (const eip of hfEIPs) {
          const valueEIP = this.paramByEIP(topic, name2, eip);
          value = typeof valueEIP === "bigint" ? valueEIP : value;
        }
      } else {
        if (hfChanges[1][topic] === void 0) {
          throw new Error(`Topic ${topic} not defined`);
        }
        if (hfChanges[1][topic][name2] !== void 0) {
          value = hfChanges[1][topic][name2].v;
        }
      }
      if (hfChanges[0] === hardfork)
        break;
    }
    return BigInt(value !== null && value !== void 0 ? value : 0);
  }
  paramByEIP(topic, name2, eip) {
    if (!(eip in EIPs)) {
      throw new Error(`${eip} not supported`);
    }
    const eipParams = EIPs[eip];
    if (!(topic in eipParams)) {
      throw new Error(`Topic ${topic} not defined`);
    }
    if (eipParams[topic][name2] === void 0) {
      return void 0;
    }
    const value = eipParams[topic][name2].v;
    return BigInt(value);
  }
  paramByBlock(topic, name2, blockNumber, td, timestamp) {
    const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);
    return this.paramByHardfork(topic, name2, hardfork);
  }
  isActivatedEIP(eip) {
    if (this.eips().includes(eip)) {
      return true;
    }
    for (const hfChanges of this.HARDFORK_CHANGES) {
      const hf = hfChanges[1];
      if (this.gteHardfork(hf.name) && "eips" in hf) {
        if (hf.eips.includes(eip)) {
          return true;
        }
      }
    }
    return false;
  }
  hardforkIsActiveOnBlock(_hardfork, _blockNumber) {
    const blockNumber = toType(_blockNumber, TypeOutput.BigInt);
    const hardfork = _hardfork !== null && _hardfork !== void 0 ? _hardfork : this._hardfork;
    const hfBlock = this.hardforkBlock(hardfork);
    if (typeof hfBlock === "bigint" && hfBlock !== BigInt(0) && blockNumber >= hfBlock) {
      return true;
    }
    return false;
  }
  activeOnBlock(blockNumber) {
    return this.hardforkIsActiveOnBlock(null, blockNumber);
  }
  hardforkGteHardfork(_hardfork1, hardfork2) {
    const hardfork1 = _hardfork1 !== null && _hardfork1 !== void 0 ? _hardfork1 : this._hardfork;
    const hardforks2 = this.hardforks();
    let posHf1 = -1;
    let posHf2 = -1;
    let index = 0;
    for (const hf of hardforks2) {
      if (hf.name === hardfork1)
        posHf1 = index;
      if (hf.name === hardfork2)
        posHf2 = index;
      index += 1;
    }
    return posHf1 >= posHf2 && posHf2 !== -1;
  }
  gteHardfork(hardfork) {
    return this.hardforkGteHardfork(null, hardfork);
  }
  hardforkBlock(_hardfork) {
    var _a16;
    const hardfork = _hardfork !== null && _hardfork !== void 0 ? _hardfork : this._hardfork;
    const block = (_a16 = this._getHardfork(hardfork)) === null || _a16 === void 0 ? void 0 : _a16.block;
    if (block === void 0 || block === null) {
      return null;
    }
    return BigInt(block);
  }
  hardforkTimestamp(_hardfork) {
    var _a16;
    const hardfork = _hardfork !== null && _hardfork !== void 0 ? _hardfork : this._hardfork;
    const timestamp = (_a16 = this._getHardfork(hardfork)) === null || _a16 === void 0 ? void 0 : _a16.timestamp;
    if (timestamp === void 0 || timestamp === null) {
      return null;
    }
    return BigInt(timestamp);
  }
  eipBlock(eip) {
    for (const hfChanges of this.HARDFORK_CHANGES) {
      const hf = hfChanges[1];
      if ("eips" in hf) {
        if (hf.eips.includes(eip)) {
          return this.hardforkBlock(typeof hfChanges[0] === "number" ? String(hfChanges[0]) : hfChanges[0]);
        }
      }
    }
    return null;
  }
  hardforkTTD(_hardfork) {
    var _a16;
    const hardfork = _hardfork !== null && _hardfork !== void 0 ? _hardfork : this._hardfork;
    const ttd = (_a16 = this._getHardfork(hardfork)) === null || _a16 === void 0 ? void 0 : _a16.ttd;
    if (ttd === void 0 || ttd === null) {
      return null;
    }
    return BigInt(ttd);
  }
  isHardforkBlock(_blockNumber, _hardfork) {
    const blockNumber = toType(_blockNumber, TypeOutput.BigInt);
    const hardfork = _hardfork !== null && _hardfork !== void 0 ? _hardfork : this._hardfork;
    const block = this.hardforkBlock(hardfork);
    return typeof block === "bigint" && block !== BigInt(0) ? block === blockNumber : false;
  }
  nextHardforkBlockOrTimestamp(_hardfork) {
    var _a16, _b;
    const hardfork = _hardfork !== null && _hardfork !== void 0 ? _hardfork : this._hardfork;
    const hfs = this.hardforks();
    let hfIndex = hfs.findIndex((hf) => hf.name === hardfork);
    if (hardfork === Hardfork.Merge) {
      hfIndex -= 1;
    }
    if (hfIndex < 0) {
      return null;
    }
    let currHfTimeOrBlock = (_a16 = hfs[hfIndex].timestamp) !== null && _a16 !== void 0 ? _a16 : hfs[hfIndex].block;
    currHfTimeOrBlock = currHfTimeOrBlock !== null && currHfTimeOrBlock !== void 0 ? Number(currHfTimeOrBlock) : null;
    const nextHf = hfs.slice(hfIndex + 1).find((hf) => {
      var _a17;
      let hfTimeOrBlock = (_a17 = hf.timestamp) !== null && _a17 !== void 0 ? _a17 : hf.block;
      hfTimeOrBlock = hfTimeOrBlock !== null && hfTimeOrBlock !== void 0 ? Number(hfTimeOrBlock) : null;
      return hf.name !== Hardfork.Merge && hfTimeOrBlock !== null && hfTimeOrBlock !== void 0 && hfTimeOrBlock !== currHfTimeOrBlock;
    });
    if (nextHf === void 0) {
      return null;
    }
    const nextHfBlock = (_b = nextHf.timestamp) !== null && _b !== void 0 ? _b : nextHf.block;
    if (nextHfBlock === null || nextHfBlock === void 0) {
      return null;
    }
    return BigInt(nextHfBlock);
  }
  nextHardforkBlock(_hardfork) {
    const hardfork = _hardfork !== null && _hardfork !== void 0 ? _hardfork : this._hardfork;
    let hfBlock = this.hardforkBlock(hardfork);
    if (hfBlock === null && hardfork === Hardfork.Merge) {
      const hfs = this.hardforks();
      const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== void 0);
      if (mergeIndex < 0) {
        throw Error(`Merge hardfork should have been found`);
      }
      hfBlock = this.hardforkBlock(hfs[mergeIndex - 1].name);
    }
    if (hfBlock === null) {
      return null;
    }
    const nextHfBlock = this.hardforks().reduce((acc, hf) => {
      const block = BigInt(
        hf.block === null || hf.ttd !== void 0 && hf.ttd !== null ? 0 : hf.block
      );
      return block > hfBlock && acc === null ? block : acc;
    }, null);
    return nextHfBlock;
  }
  isNextHardforkBlock(_blockNumber, _hardfork) {
    const blockNumber = toType(_blockNumber, TypeOutput.BigInt);
    const hardfork = _hardfork !== null && _hardfork !== void 0 ? _hardfork : this._hardfork;
    const nextHardforkBlock = this.nextHardforkBlock(hardfork);
    return nextHardforkBlock === null ? false : nextHardforkBlock === blockNumber;
  }
  _calcForkHash(hardfork, genesisHash) {
    let hfUint8Array = new Uint8Array();
    let prevBlockOrTime = 0;
    for (const hf of this.hardforks()) {
      const { block, timestamp, name: name2 } = hf;
      let blockOrTime = timestamp !== null && timestamp !== void 0 ? timestamp : block;
      blockOrTime = blockOrTime !== null ? Number(blockOrTime) : null;
      if (typeof blockOrTime === "number" && blockOrTime !== 0 && blockOrTime !== prevBlockOrTime && name2 !== Hardfork.Merge) {
        const hfBlockUint8Array = hexToBytes4(blockOrTime.toString(16).padStart(16, "0"));
        hfUint8Array = uint8ArrayConcat3(hfUint8Array, hfBlockUint8Array);
        prevBlockOrTime = blockOrTime;
      }
      if (hf.name === hardfork)
        break;
    }
    const inputUint8Array = uint8ArrayConcat3(genesisHash, hfUint8Array);
    const forkhash = bytesToHex4(intToUint8Array(crc32Uint8Array(inputUint8Array) >>> 0));
    return forkhash;
  }
  forkHash(_hardfork, genesisHash) {
    const hardfork = _hardfork !== null && _hardfork !== void 0 ? _hardfork : this._hardfork;
    const data = this._getHardfork(hardfork);
    if (data === null || (data === null || data === void 0 ? void 0 : data.block) === null && (data === null || data === void 0 ? void 0 : data.timestamp) === void 0 && (data === null || data === void 0 ? void 0 : data.ttd) === void 0) {
      const msg = "No fork hash calculation possible for future hardfork";
      throw new Error(msg);
    }
    if ((data === null || data === void 0 ? void 0 : data.forkHash) !== null && (data === null || data === void 0 ? void 0 : data.forkHash) !== void 0) {
      return data.forkHash;
    }
    if (!genesisHash)
      throw new Error("genesisHash required for forkHash calculation");
    return this._calcForkHash(hardfork, genesisHash);
  }
  hardforkForForkHash(forkHash) {
    const resArray = this.hardforks().filter((hf) => hf.forkHash === forkHash);
    return resArray.length >= 1 ? resArray[resArray.length - 1] : null;
  }
  setForkHashes(genesisHash) {
    var _a16;
    for (const hf of this.hardforks()) {
      const blockOrTime = (_a16 = hf.timestamp) !== null && _a16 !== void 0 ? _a16 : hf.block;
      if ((hf.forkHash === null || hf.forkHash === void 0) && (blockOrTime !== null && blockOrTime !== void 0 || typeof hf.ttd !== "undefined")) {
        hf.forkHash = this.forkHash(hf.name, genesisHash);
      }
    }
  }
  genesis() {
    return this._chainParams.genesis;
  }
  hardforks() {
    return this._chainParams.hardforks;
  }
  bootstrapNodes() {
    return this._chainParams.bootstrapNodes;
  }
  dnsNetworks() {
    return this._chainParams.dnsNetworks;
  }
  hardfork() {
    return this._hardfork;
  }
  chainId() {
    return BigInt(this._chainParams.chainId);
  }
  chainName() {
    return this._chainParams.name;
  }
  networkId() {
    return BigInt(this._chainParams.networkId);
  }
  eips() {
    return this._eips;
  }
  consensusType() {
    const hardfork = this.hardfork();
    let value;
    for (const hfChanges of this.HARDFORK_CHANGES) {
      if ("consensus" in hfChanges[1]) {
        value = hfChanges[1].consensus.type;
      }
      if (hfChanges[0] === hardfork)
        break;
    }
    return value !== null && value !== void 0 ? value : this._chainParams.consensus.type;
  }
  consensusAlgorithm() {
    const hardfork = this.hardfork();
    let value;
    for (const hfChanges of this.HARDFORK_CHANGES) {
      if ("consensus" in hfChanges[1]) {
        value = hfChanges[1].consensus.algorithm;
      }
      if (hfChanges[0] === hardfork)
        break;
    }
    return value !== null && value !== void 0 ? value : this._chainParams.consensus.algorithm;
  }
  consensusConfig() {
    var _a16;
    const hardfork = this.hardfork();
    let value;
    for (const hfChanges of this.HARDFORK_CHANGES) {
      if ("consensus" in hfChanges[1]) {
        value = hfChanges[1].consensus[hfChanges[1].consensus.algorithm];
      }
      if (hfChanges[0] === hardfork)
        break;
    }
    return (_a16 = value !== null && value !== void 0 ? value : this._chainParams.consensus[this.consensusAlgorithm()]) !== null && _a16 !== void 0 ? _a16 : {};
  }
  copy() {
    const copy = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
    copy.removeAllListeners();
    return copy;
  }
  static _getInitializedChains(customChains) {
    const names = {};
    for (const [name2, id] of Object.entries(Chain)) {
      names[id] = name2.toLowerCase();
    }
    const chains = { mainnet: mainnet_default, goerli: goerli_default, sepolia: sepolia_default };
    if (customChains) {
      for (const chain of customChains) {
        const { name: name2 } = chain;
        names[chain.chainId.toString()] = name2;
        chains[name2] = chain;
      }
    }
    chains.names = names;
    return chains;
  }
};

// node_modules/web3-eth-accounts/lib/esm/tx/types.js
init_shim();
var Capability;
(function(Capability2) {
  Capability2[Capability2["EIP155ReplayProtection"] = 155] = "EIP155ReplayProtection";
  Capability2[Capability2["EIP1559FeeMarket"] = 1559] = "EIP1559FeeMarket";
  Capability2[Capability2["EIP2718TypedTransaction"] = 2718] = "EIP2718TypedTransaction";
  Capability2[Capability2["EIP2930AccessLists"] = 2930] = "EIP2930AccessLists";
})(Capability || (Capability = {}));
function isAccessListUint8Array(input) {
  if (input.length === 0) {
    return true;
  }
  const firstItem = input[0];
  if (Array.isArray(firstItem)) {
    return true;
  }
  return false;
}
function isAccessList(input) {
  return !isAccessListUint8Array(input);
}

// node_modules/web3-eth-accounts/lib/esm/tx/address.js
init_shim();
var Address = class {
  constructor(buf) {
    if (buf.length !== 20) {
      throw new Error("Invalid address length");
    }
    this.buf = buf;
  }
  static zero() {
    return new Address(zeros(20));
  }
  equals(address) {
    return uint8ArrayEquals2(this.buf, address.buf);
  }
  isZero() {
    return this.equals(Address.zero());
  }
  toString() {
    return bytesToHex4(this.buf);
  }
  toArray() {
    return this.buf;
  }
  static publicToAddress(_pubKey, sanitize = false) {
    let pubKey = _pubKey;
    assertIsUint8Array(pubKey);
    if (sanitize && pubKey.length !== 64) {
      pubKey = secp256k12.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1);
    }
    if (pubKey.length !== 64) {
      throw new Error("Expected pubKey to be of length 64");
    }
    return keccak2564(pubKey).slice(-20);
  }
};

// node_modules/web3-eth-accounts/lib/esm/tx/utils.js
var utils_exports2 = {};
__export(utils_exports2, {
  checkMaxInitCodeSize: () => checkMaxInitCodeSize,
  getAccessListData: () => getAccessListData,
  getAccessListJSON: () => getAccessListJSON,
  getDataFeeEIP2930: () => getDataFeeEIP2930,
  verifyAccessList: () => verifyAccessList
});
init_shim();
var checkMaxInitCodeSize = (common, length) => {
  const maxInitCodeSize = common.param("vm", "maxInitCodeSize");
  if (maxInitCodeSize && BigInt(length) > maxInitCodeSize) {
    throw new Error(`the initcode size of this transaction is too large: it is ${length} while the max is ${common.param("vm", "maxInitCodeSize")}`);
  }
};
var getAccessListData = (accessList) => {
  let AccessListJSON;
  let uint8arrayAccessList;
  if (isAccessList(accessList)) {
    AccessListJSON = accessList;
    const newAccessList = [];
    for (let i = 0; i < accessList.length; i += 1) {
      const item = accessList[i];
      const addressBytes = toUint8Array(item.address);
      const storageItems = [];
      for (let index = 0; index < item.storageKeys.length; index += 1) {
        storageItems.push(toUint8Array(item.storageKeys[index]));
      }
      newAccessList.push([addressBytes, storageItems]);
    }
    uint8arrayAccessList = newAccessList;
  } else {
    uint8arrayAccessList = accessList !== null && accessList !== void 0 ? accessList : [];
    const json = [];
    for (let i = 0; i < uint8arrayAccessList.length; i += 1) {
      const data = uint8arrayAccessList[i];
      const address = bytesToHex4(data[0]);
      const storageKeys = [];
      for (let item = 0; item < data[1].length; item += 1) {
        storageKeys.push(bytesToHex4(data[1][item]));
      }
      const jsonItem = {
        address,
        storageKeys
      };
      json.push(jsonItem);
    }
    AccessListJSON = json;
  }
  return {
    AccessListJSON,
    accessList: uint8arrayAccessList
  };
};
var verifyAccessList = (accessList) => {
  for (let key = 0; key < accessList.length; key += 1) {
    const accessListItem = accessList[key];
    const address = accessListItem[0];
    const storageSlots = accessListItem[1];
    if (accessListItem[2] !== void 0) {
      throw new Error("Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.");
    }
    if (address.length !== 20) {
      throw new Error("Invalid EIP-2930 transaction: address length should be 20 bytes");
    }
    for (let storageSlot = 0; storageSlot < storageSlots.length; storageSlot += 1) {
      if (storageSlots[storageSlot].length !== 32) {
        throw new Error("Invalid EIP-2930 transaction: storage slot length should be 32 bytes");
      }
    }
  }
};
var getAccessListJSON = (accessList) => {
  const accessListJSON = [];
  for (let index = 0; index < accessList.length; index += 1) {
    const item = accessList[index];
    const JSONItem = {
      address: bytesToHex4(setLengthLeft(item[0], 20)),
      storageKeys: []
    };
    const storageSlots = item && item[1];
    for (let slot = 0; slot < storageSlots.length; slot += 1) {
      const storageSlot = storageSlots[slot];
      JSONItem.storageKeys.push(bytesToHex4(setLengthLeft(storageSlot, 32)));
    }
    accessListJSON.push(JSONItem);
  }
  return accessListJSON;
};
var getDataFeeEIP2930 = (accessList, common) => {
  const accessListStorageKeyCost = common.param("gasPrices", "accessListStorageKeyCost");
  const accessListAddressCost = common.param("gasPrices", "accessListAddressCost");
  let slots = 0;
  for (let index = 0; index < accessList.length; index += 1) {
    const item = accessList[index];
    const storageSlots = item[1];
    slots += storageSlots.length;
  }
  const addresses = accessList.length;
  return addresses * Number(accessListAddressCost) + slots * Number(accessListStorageKeyCost);
};

// node_modules/web3-eth-accounts/lib/esm/tx/baseTransaction.js
var BaseTransaction = class {
  constructor(txData, opts) {
    var _a16, _b;
    this.cache = {
      hash: void 0,
      dataFee: void 0
    };
    this.activeCapabilities = [];
    this.DEFAULT_CHAIN = Chain.Mainnet;
    this.DEFAULT_HARDFORK = Hardfork.Merge;
    const { nonce, gasLimit, to, value, data, v, r, s, type } = txData;
    this._type = Number(uint8ArrayToBigInt(toUint8Array(type)));
    this.txOptions = opts;
    const toB = toUint8Array(to === "" ? "0x" : to);
    const vB = toUint8Array(v === "" ? "0x" : v);
    const rB = toUint8Array(r === "" ? "0x" : r);
    const sB = toUint8Array(s === "" ? "0x" : s);
    this.nonce = uint8ArrayToBigInt(toUint8Array(nonce === "" ? "0x" : nonce));
    this.gasLimit = uint8ArrayToBigInt(toUint8Array(gasLimit === "" ? "0x" : gasLimit));
    this.to = toB.length > 0 ? new Address(toB) : void 0;
    this.value = uint8ArrayToBigInt(toUint8Array(value === "" ? "0x" : value));
    this.data = toUint8Array(data === "" ? "0x" : data);
    this.v = vB.length > 0 ? uint8ArrayToBigInt(vB) : void 0;
    this.r = rB.length > 0 ? uint8ArrayToBigInt(rB) : void 0;
    this.s = sB.length > 0 ? uint8ArrayToBigInt(sB) : void 0;
    this._validateCannotExceedMaxInteger({ value: this.value, r: this.r, s: this.s });
    this._validateCannotExceedMaxInteger({ gasLimit: this.gasLimit }, 64);
    this._validateCannotExceedMaxInteger({ nonce: this.nonce }, 64, true);
    const createContract = this.to === void 0 || this.to === null;
    const allowUnlimitedInitCodeSize = (_a16 = opts.allowUnlimitedInitCodeSize) !== null && _a16 !== void 0 ? _a16 : false;
    const common = (_b = opts.common) !== null && _b !== void 0 ? _b : this._getCommon();
    if (createContract && common.isActivatedEIP(3860) && !allowUnlimitedInitCodeSize) {
      checkMaxInitCodeSize(common, this.data.length);
    }
  }
  get type() {
    return this._type;
  }
  supports(capability) {
    return this.activeCapabilities.includes(capability);
  }
  validate(stringError = false) {
    const errors = [];
    if (this.getBaseFee() > this.gasLimit) {
      errors.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`);
    }
    if (this.isSigned() && !this.verifySignature()) {
      errors.push("Invalid Signature");
    }
    return stringError ? errors : errors.length === 0;
  }
  _validateYParity() {
    const { v } = this;
    if (v !== void 0 && v !== BigInt(0) && v !== BigInt(1)) {
      const msg = this._errorMsg("The y-parity of the transaction should either be 0 or 1");
      throw new Error(msg);
    }
  }
  _validateHighS() {
    const { s } = this;
    if (this.common.gteHardfork("homestead") && s !== void 0 && s > SECP256K1_ORDER_DIV_2) {
      const msg = this._errorMsg("Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");
      throw new Error(msg);
    }
  }
  getBaseFee() {
    const txFee = this.common.param("gasPrices", "tx");
    let fee = this.getDataFee();
    if (txFee)
      fee += txFee;
    if (this.common.gteHardfork("homestead") && this.toCreationAddress()) {
      const txCreationFee = this.common.param("gasPrices", "txCreation");
      if (txCreationFee)
        fee += txCreationFee;
    }
    return fee;
  }
  getDataFee() {
    const txDataZero = this.common.param("gasPrices", "txDataZero");
    const txDataNonZero = this.common.param("gasPrices", "txDataNonZero");
    let cost = BigInt(0);
    for (let i = 0; i < this.data.length; i += 1) {
      this.data[i] === 0 ? cost += txDataZero : cost += txDataNonZero;
    }
    if ((this.to === void 0 || this.to === null) && this.common.isActivatedEIP(3860)) {
      const dataLength = BigInt(Math.ceil(this.data.length / 32));
      const initCodeCost = this.common.param("gasPrices", "initCodeWordCost") * dataLength;
      cost += initCodeCost;
    }
    return cost;
  }
  toCreationAddress() {
    return this.to === void 0 || this.to.buf.length === 0;
  }
  isSigned() {
    const { v, r, s } = this;
    if (v === void 0 || r === void 0 || s === void 0) {
      return false;
    }
    return true;
  }
  verifySignature() {
    try {
      const publicKey = this.getSenderPublicKey();
      return unpadUint8Array(publicKey).length !== 0;
    } catch (e) {
      return false;
    }
  }
  getSenderAddress() {
    return new Address(Address.publicToAddress(this.getSenderPublicKey()));
  }
  sign(privateKey) {
    if (privateKey.length !== 32) {
      const msg = this._errorMsg("Private key must be 32 bytes in length.");
      throw new Error(msg);
    }
    let hackApplied = false;
    if (this.type === 0 && this.common.gteHardfork("spuriousDragon") && !this.supports(Capability.EIP155ReplayProtection)) {
      this.activeCapabilities.push(Capability.EIP155ReplayProtection);
      hackApplied = true;
    }
    const msgHash = this.getMessageToSign(true);
    const { v, r, s } = this._ecsign(msgHash, privateKey);
    const tx = this._processSignature(v, r, s);
    if (hackApplied) {
      const index = this.activeCapabilities.indexOf(Capability.EIP155ReplayProtection);
      if (index > -1) {
        this.activeCapabilities.splice(index, 1);
      }
    }
    return tx;
  }
  _getCommon(common, chainId) {
    var _a16;
    if (chainId !== void 0) {
      const chainIdBigInt = uint8ArrayToBigInt(toUint8Array(chainId));
      if (common) {
        if (common.chainId() !== chainIdBigInt) {
          const msg = this._errorMsg("The chain ID does not match the chain ID of Common");
          throw new Error(msg);
        }
        return common.copy();
      }
      if (Common.isSupportedChainId(chainIdBigInt)) {
        return new Common({ chain: chainIdBigInt, hardfork: this.DEFAULT_HARDFORK });
      }
      return Common.custom({
        name: "custom-chain",
        networkId: chainIdBigInt,
        chainId: chainIdBigInt
      }, { baseChain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK });
    }
    return (_a16 = common === null || common === void 0 ? void 0 : common.copy()) !== null && _a16 !== void 0 ? _a16 : new Common({ chain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK });
  }
  _validateCannotExceedMaxInteger(values, bits = 256, cannotEqual = false) {
    for (const [key, value] of Object.entries(values)) {
      switch (bits) {
        case 64:
          if (cannotEqual) {
            if (value !== void 0 && value >= MAX_UINT64) {
              const msg = this._errorMsg(`${key} cannot equal or exceed MAX_UINT64 (2^64-1), given ${value}`);
              throw new Error(msg);
            }
          } else if (value !== void 0 && value > MAX_UINT64) {
            const msg = this._errorMsg(`${key} cannot exceed MAX_UINT64 (2^64-1), given ${value}`);
            throw new Error(msg);
          }
          break;
        case 256:
          if (cannotEqual) {
            if (value !== void 0 && value >= MAX_INTEGER) {
              const msg = this._errorMsg(`${key} cannot equal or exceed MAX_INTEGER (2^256-1), given ${value}`);
              throw new Error(msg);
            }
          } else if (value !== void 0 && value > MAX_INTEGER) {
            const msg = this._errorMsg(`${key} cannot exceed MAX_INTEGER (2^256-1), given ${value}`);
            throw new Error(msg);
          }
          break;
        default: {
          const msg = this._errorMsg("unimplemented bits value");
          throw new Error(msg);
        }
      }
    }
  }
  static _validateNotArray(values) {
    const txDataKeys = [
      "nonce",
      "gasPrice",
      "gasLimit",
      "to",
      "value",
      "data",
      "v",
      "r",
      "s",
      "type",
      "baseFee",
      "maxFeePerGas",
      "chainId"
    ];
    for (const [key, value] of Object.entries(values)) {
      if (txDataKeys.includes(key)) {
        if (Array.isArray(value)) {
          throw new Error(`${key} cannot be an array`);
        }
      }
    }
  }
  _getSharedErrorPostfix() {
    let hash = "";
    try {
      hash = this.isSigned() ? bytesToHex4(this.hash()) : "not available (unsigned)";
    } catch (e) {
      hash = "error";
    }
    let isSigned = "";
    try {
      isSigned = this.isSigned().toString();
    } catch (e) {
      hash = "error";
    }
    let hf = "";
    try {
      hf = this.common.hardfork();
    } catch (e) {
      hf = "error";
    }
    let postfix = `tx type=${this.type} hash=${hash} nonce=${this.nonce} value=${this.value} `;
    postfix += `signed=${isSigned} hf=${hf}`;
    return postfix;
  }
  _ecsign(msgHash, privateKey, chainId) {
    const signature = secp256k12.sign(msgHash, privateKey);
    const signatureBytes = signature.toCompactRawBytes();
    const r = signatureBytes.subarray(0, 32);
    const s = signatureBytes.subarray(32, 64);
    const v = chainId === void 0 ? BigInt(signature.recovery + 27) : BigInt(signature.recovery + 35) + BigInt(chainId) * BigInt(2);
    return { r, s, v };
  }
  static fromSerializedTx(serialized, opts = {}) {
  }
  static fromTxData(txData, opts = {}) {
  }
};

// node_modules/web3-eth-accounts/lib/esm/tx/eip1559Transaction.js
var TRANSACTION_TYPE = 2;
var TRANSACTION_TYPE_UINT8ARRAY = hexToBytes4(TRANSACTION_TYPE.toString(16).padStart(2, "0"));
var FeeMarketEIP1559Transaction = class extends BaseTransaction {
  constructor(txData, opts = {}) {
    var _a16;
    super(Object.assign(Object.assign({}, txData), { type: TRANSACTION_TYPE }), opts);
    this.DEFAULT_HARDFORK = "london";
    const { chainId, accessList, maxFeePerGas, maxPriorityFeePerGas } = txData;
    this.common = this._getCommon(opts.common, chainId);
    this.chainId = this.common.chainId();
    if (!this.common.isActivatedEIP(1559)) {
      throw new Error("EIP-1559 not enabled on Common");
    }
    this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930]);
    const accessListData = getAccessListData(accessList !== null && accessList !== void 0 ? accessList : []);
    this.accessList = accessListData.accessList;
    this.AccessListJSON = accessListData.AccessListJSON;
    verifyAccessList(this.accessList);
    this.maxFeePerGas = uint8ArrayToBigInt(toUint8Array(maxFeePerGas === "" ? "0x" : maxFeePerGas));
    this.maxPriorityFeePerGas = uint8ArrayToBigInt(toUint8Array(maxPriorityFeePerGas === "" ? "0x" : maxPriorityFeePerGas));
    this._validateCannotExceedMaxInteger({
      maxFeePerGas: this.maxFeePerGas,
      maxPriorityFeePerGas: this.maxPriorityFeePerGas
    });
    BaseTransaction._validateNotArray(txData);
    if (this.gasLimit * this.maxFeePerGas > MAX_INTEGER) {
      const msg = this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");
      throw new Error(msg);
    }
    if (this.maxFeePerGas < this.maxPriorityFeePerGas) {
      const msg = this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");
      throw new Error(msg);
    }
    this._validateYParity();
    this._validateHighS();
    const freeze = (_a16 = opts === null || opts === void 0 ? void 0 : opts.freeze) !== null && _a16 !== void 0 ? _a16 : true;
    if (freeze) {
      Object.freeze(this);
    }
  }
  static fromTxData(txData, opts = {}) {
    return new FeeMarketEIP1559Transaction(txData, opts);
  }
  static fromSerializedTx(serialized, opts = {}) {
    if (!uint8ArrayEquals2(serialized.subarray(0, 1), TRANSACTION_TYPE_UINT8ARRAY)) {
      throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${TRANSACTION_TYPE}, received: ${bytesToHex4(serialized.subarray(0, 1))}`);
    }
    const values = import_rlp.RLP.decode(serialized.subarray(1));
    if (!Array.isArray(values)) {
      throw new Error("Invalid serialized tx input: must be array");
    }
    return FeeMarketEIP1559Transaction.fromValuesArray(values, opts);
  }
  static fromValuesArray(values, opts = {}) {
    if (values.length !== 9 && values.length !== 12) {
      throw new Error("Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).");
    }
    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data, accessList, v, r, s] = values;
    this._validateNotArray({ chainId, v });
    validateNoLeadingZeroes({
      nonce,
      maxPriorityFeePerGas,
      maxFeePerGas,
      gasLimit,
      value,
      v,
      r,
      s
    });
    return new FeeMarketEIP1559Transaction({
      chainId: uint8ArrayToBigInt(chainId),
      nonce,
      maxPriorityFeePerGas,
      maxFeePerGas,
      gasLimit,
      to,
      value,
      data,
      accessList: accessList !== null && accessList !== void 0 ? accessList : [],
      v: v !== void 0 ? uint8ArrayToBigInt(v) : void 0,
      r,
      s
    }, opts);
  }
  getDataFee() {
    if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
      return this.cache.dataFee.value;
    }
    let cost = super.getDataFee();
    cost += BigInt(getDataFeeEIP2930(this.accessList, this.common));
    if (Object.isFrozen(this)) {
      this.cache.dataFee = {
        value: cost,
        hardfork: this.common.hardfork()
      };
    }
    return cost;
  }
  getUpfrontCost(baseFee = BigInt(0)) {
    const prio = this.maxPriorityFeePerGas;
    const maxBase = this.maxFeePerGas - baseFee;
    const inclusionFeePerGas = prio < maxBase ? prio : maxBase;
    const gasPrice = inclusionFeePerGas + baseFee;
    return this.gasLimit * gasPrice + this.value;
  }
  raw() {
    return [
      bigIntToUnpaddedUint8Array(this.chainId),
      bigIntToUnpaddedUint8Array(this.nonce),
      bigIntToUnpaddedUint8Array(this.maxPriorityFeePerGas),
      bigIntToUnpaddedUint8Array(this.maxFeePerGas),
      bigIntToUnpaddedUint8Array(this.gasLimit),
      this.to !== void 0 ? this.to.buf : Uint8Array.from([]),
      bigIntToUnpaddedUint8Array(this.value),
      this.data,
      this.accessList,
      this.v !== void 0 ? bigIntToUnpaddedUint8Array(this.v) : Uint8Array.from([]),
      this.r !== void 0 ? bigIntToUnpaddedUint8Array(this.r) : Uint8Array.from([]),
      this.s !== void 0 ? bigIntToUnpaddedUint8Array(this.s) : Uint8Array.from([])
    ];
  }
  serialize() {
    const base2 = this.raw();
    return uint8ArrayConcat3(TRANSACTION_TYPE_UINT8ARRAY, import_rlp.RLP.encode(base2));
  }
  getMessageToSign(hashMessage2 = true) {
    const base2 = this.raw().slice(0, 9);
    const message = uint8ArrayConcat3(TRANSACTION_TYPE_UINT8ARRAY, import_rlp.RLP.encode(base2));
    if (hashMessage2) {
      return keccak2564(message);
    }
    return message;
  }
  hash() {
    if (!this.isSigned()) {
      const msg = this._errorMsg("Cannot call hash method if transaction is not signed");
      throw new Error(msg);
    }
    if (Object.isFrozen(this)) {
      if (!this.cache.hash) {
        this.cache.hash = keccak2564(this.serialize());
      }
      return this.cache.hash;
    }
    return keccak2564(this.serialize());
  }
  getMessageToVerifySignature() {
    return this.getMessageToSign();
  }
  getSenderPublicKey() {
    if (!this.isSigned()) {
      const msg = this._errorMsg("Cannot call this method if transaction is not signed");
      throw new Error(msg);
    }
    const msgHash = this.getMessageToVerifySignature();
    const { v, r, s } = this;
    this._validateHighS();
    try {
      return ecrecover(
        msgHash,
        v + BigInt(27),
        bigIntToUnpaddedUint8Array(r),
        bigIntToUnpaddedUint8Array(s)
      );
    } catch (e) {
      const msg = this._errorMsg("Invalid Signature");
      throw new Error(msg);
    }
  }
  _processSignature(v, r, s) {
    const opts = Object.assign(Object.assign({}, this.txOptions), { common: this.common });
    return FeeMarketEIP1559Transaction.fromTxData({
      chainId: this.chainId,
      nonce: this.nonce,
      maxPriorityFeePerGas: this.maxPriorityFeePerGas,
      maxFeePerGas: this.maxFeePerGas,
      gasLimit: this.gasLimit,
      to: this.to,
      value: this.value,
      data: this.data,
      accessList: this.accessList,
      v: v - BigInt(27),
      r: uint8ArrayToBigInt(r),
      s: uint8ArrayToBigInt(s)
    }, opts);
  }
  toJSON() {
    const accessListJSON = getAccessListJSON(this.accessList);
    return {
      chainId: bigIntToHex(this.chainId),
      nonce: bigIntToHex(this.nonce),
      maxPriorityFeePerGas: bigIntToHex(this.maxPriorityFeePerGas),
      maxFeePerGas: bigIntToHex(this.maxFeePerGas),
      gasLimit: bigIntToHex(this.gasLimit),
      to: this.to !== void 0 ? this.to.toString() : void 0,
      value: bigIntToHex(this.value),
      data: bytesToHex4(this.data),
      accessList: accessListJSON,
      v: this.v !== void 0 ? bigIntToHex(this.v) : void 0,
      r: this.r !== void 0 ? bigIntToHex(this.r) : void 0,
      s: this.s !== void 0 ? bigIntToHex(this.s) : void 0
    };
  }
  errorStr() {
    let errorStr = this._getSharedErrorPostfix();
    errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`;
    return errorStr;
  }
  _errorMsg(msg) {
    return `${msg} (${this.errorStr()})`;
  }
};

// node_modules/web3-eth-accounts/lib/esm/tx/eip2930Transaction.js
init_shim();
var import_rlp2 = __toESM(require_dist(), 1);
var TRANSACTION_TYPE2 = 1;
var TRANSACTION_TYPE_UINT8ARRAY2 = hexToBytes4(TRANSACTION_TYPE2.toString(16).padStart(2, "0"));
var AccessListEIP2930Transaction = class extends BaseTransaction {
  constructor(txData, opts = {}) {
    var _a16;
    super(Object.assign(Object.assign({}, txData), { type: TRANSACTION_TYPE2 }), opts);
    this.DEFAULT_HARDFORK = "berlin";
    const { chainId, accessList, gasPrice } = txData;
    this.common = this._getCommon(opts.common, chainId);
    this.chainId = this.common.chainId();
    if (!this.common.isActivatedEIP(2930)) {
      throw new Error("EIP-2930 not enabled on Common");
    }
    this.activeCapabilities = this.activeCapabilities.concat([2718, 2930]);
    const accessListData = getAccessListData(accessList !== null && accessList !== void 0 ? accessList : []);
    this.accessList = accessListData.accessList;
    this.AccessListJSON = accessListData.AccessListJSON;
    verifyAccessList(this.accessList);
    this.gasPrice = uint8ArrayToBigInt(toUint8Array(gasPrice === "" ? "0x" : gasPrice));
    this._validateCannotExceedMaxInteger({
      gasPrice: this.gasPrice
    });
    BaseTransaction._validateNotArray(txData);
    if (this.gasPrice * this.gasLimit > MAX_INTEGER) {
      const msg = this._errorMsg("gasLimit * gasPrice cannot exceed MAX_INTEGER");
      throw new Error(msg);
    }
    this._validateYParity();
    this._validateHighS();
    const freeze = (_a16 = opts === null || opts === void 0 ? void 0 : opts.freeze) !== null && _a16 !== void 0 ? _a16 : true;
    if (freeze) {
      Object.freeze(this);
    }
  }
  static fromTxData(txData, opts = {}) {
    return new AccessListEIP2930Transaction(txData, opts);
  }
  static fromSerializedTx(serialized, opts = {}) {
    if (!uint8ArrayEquals2(serialized.subarray(0, 1), TRANSACTION_TYPE_UINT8ARRAY2)) {
      throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${TRANSACTION_TYPE2}, received: ${bytesToHex4(serialized.subarray(0, 1))}`);
    }
    const values = import_rlp2.RLP.decode(Uint8Array.from(serialized.subarray(1)));
    if (!Array.isArray(values)) {
      throw new Error("Invalid serialized tx input: must be array");
    }
    return AccessListEIP2930Transaction.fromValuesArray(values, opts);
  }
  static fromValuesArray(values, opts = {}) {
    if (values.length !== 8 && values.length !== 11) {
      throw new Error("Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).");
    }
    const [chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, v, r, s] = values;
    this._validateNotArray({ chainId, v });
    validateNoLeadingZeroes({ nonce, gasPrice, gasLimit, value, v, r, s });
    const emptyAccessList = [];
    return new AccessListEIP2930Transaction({
      chainId: uint8ArrayToBigInt(chainId),
      nonce,
      gasPrice,
      gasLimit,
      to,
      value,
      data,
      accessList: accessList !== null && accessList !== void 0 ? accessList : emptyAccessList,
      v: v !== void 0 ? uint8ArrayToBigInt(v) : void 0,
      r,
      s
    }, opts);
  }
  getDataFee() {
    if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
      return this.cache.dataFee.value;
    }
    let cost = super.getDataFee();
    cost += BigInt(getDataFeeEIP2930(this.accessList, this.common));
    if (Object.isFrozen(this)) {
      this.cache.dataFee = {
        value: cost,
        hardfork: this.common.hardfork()
      };
    }
    return cost;
  }
  getUpfrontCost() {
    return this.gasLimit * this.gasPrice + this.value;
  }
  raw() {
    return [
      bigIntToUnpaddedUint8Array(this.chainId),
      bigIntToUnpaddedUint8Array(this.nonce),
      bigIntToUnpaddedUint8Array(this.gasPrice),
      bigIntToUnpaddedUint8Array(this.gasLimit),
      this.to !== void 0 ? this.to.buf : Uint8Array.from([]),
      bigIntToUnpaddedUint8Array(this.value),
      this.data,
      this.accessList,
      this.v !== void 0 ? bigIntToUnpaddedUint8Array(this.v) : Uint8Array.from([]),
      this.r !== void 0 ? bigIntToUnpaddedUint8Array(this.r) : Uint8Array.from([]),
      this.s !== void 0 ? bigIntToUnpaddedUint8Array(this.s) : Uint8Array.from([])
    ];
  }
  serialize() {
    const base2 = this.raw();
    return uint8ArrayConcat3(TRANSACTION_TYPE_UINT8ARRAY2, import_rlp2.RLP.encode(base2));
  }
  getMessageToSign(hashMessage2 = true) {
    const base2 = this.raw().slice(0, 8);
    const message = uint8ArrayConcat3(TRANSACTION_TYPE_UINT8ARRAY2, import_rlp2.RLP.encode(base2));
    if (hashMessage2) {
      return keccak2564(message);
    }
    return message;
  }
  hash() {
    if (!this.isSigned()) {
      const msg = this._errorMsg("Cannot call hash method if transaction is not signed");
      throw new Error(msg);
    }
    if (Object.isFrozen(this)) {
      if (!this.cache.hash) {
        this.cache.hash = keccak2564(this.serialize());
      }
      return this.cache.hash;
    }
    return keccak2564(this.serialize());
  }
  getMessageToVerifySignature() {
    return this.getMessageToSign();
  }
  getSenderPublicKey() {
    if (!this.isSigned()) {
      const msg = this._errorMsg("Cannot call this method if transaction is not signed");
      throw new Error(msg);
    }
    const msgHash = this.getMessageToVerifySignature();
    const { v, r, s } = this;
    this._validateHighS();
    try {
      return ecrecover(
        msgHash,
        v + BigInt(27),
        bigIntToUnpaddedUint8Array(r),
        bigIntToUnpaddedUint8Array(s)
      );
    } catch (e) {
      const msg = this._errorMsg("Invalid Signature");
      throw new Error(msg);
    }
  }
  _processSignature(v, r, s) {
    const opts = Object.assign(Object.assign({}, this.txOptions), { common: this.common });
    return AccessListEIP2930Transaction.fromTxData({
      chainId: this.chainId,
      nonce: this.nonce,
      gasPrice: this.gasPrice,
      gasLimit: this.gasLimit,
      to: this.to,
      value: this.value,
      data: this.data,
      accessList: this.accessList,
      v: v - BigInt(27),
      r: uint8ArrayToBigInt(r),
      s: uint8ArrayToBigInt(s)
    }, opts);
  }
  toJSON() {
    const accessListJSON = getAccessListJSON(this.accessList);
    return {
      chainId: bigIntToHex(this.chainId),
      nonce: bigIntToHex(this.nonce),
      gasPrice: bigIntToHex(this.gasPrice),
      gasLimit: bigIntToHex(this.gasLimit),
      to: this.to !== void 0 ? this.to.toString() : void 0,
      value: bigIntToHex(this.value),
      data: bytesToHex4(this.data),
      accessList: accessListJSON,
      v: this.v !== void 0 ? bigIntToHex(this.v) : void 0,
      r: this.r !== void 0 ? bigIntToHex(this.r) : void 0,
      s: this.s !== void 0 ? bigIntToHex(this.s) : void 0
    };
  }
  errorStr() {
    var _a16, _b;
    let errorStr = this._getSharedErrorPostfix();
    errorStr += ` gasPrice=${this.gasPrice} accessListCount=${(_b = (_a16 = this.accessList) === null || _a16 === void 0 ? void 0 : _a16.length) !== null && _b !== void 0 ? _b : 0}`;
    return errorStr;
  }
  _errorMsg(msg) {
    return `${msg} (${this.errorStr()})`;
  }
};

// node_modules/web3-eth-accounts/lib/esm/tx/legacyTransaction.js
init_shim();
var import_rlp3 = __toESM(require_dist(), 1);
var TRANSACTION_TYPE3 = 0;
function meetsEIP155(_v, chainId) {
  const v = Number(_v);
  const chainIdDoubled = Number(chainId) * 2;
  return v === chainIdDoubled + 35 || v === chainIdDoubled + 36;
}
var Transaction = class extends BaseTransaction {
  constructor(txData, opts = {}) {
    var _a16;
    super(Object.assign(Object.assign({}, txData), { type: TRANSACTION_TYPE3 }), opts);
    this.common = this._validateTxV(this.v, opts.common);
    this.gasPrice = uint8ArrayToBigInt(toUint8Array(txData.gasPrice === "" ? "0x" : txData.gasPrice));
    if (this.gasPrice * this.gasLimit > MAX_INTEGER) {
      const msg = this._errorMsg("gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)");
      throw new Error(msg);
    }
    this._validateCannotExceedMaxInteger({ gasPrice: this.gasPrice });
    BaseTransaction._validateNotArray(txData);
    if (this.common.gteHardfork("spuriousDragon")) {
      if (!this.isSigned()) {
        this.activeCapabilities.push(Capability.EIP155ReplayProtection);
      } else {
        if (meetsEIP155(this.v, this.common.chainId())) {
          this.activeCapabilities.push(Capability.EIP155ReplayProtection);
        }
      }
    }
    const freeze = (_a16 = opts === null || opts === void 0 ? void 0 : opts.freeze) !== null && _a16 !== void 0 ? _a16 : true;
    if (freeze) {
      Object.freeze(this);
    }
  }
  static fromTxData(txData, opts = {}) {
    return new Transaction(txData, opts);
  }
  static fromSerializedTx(serialized, opts = {}) {
    const values = import_rlp3.RLP.decode(serialized);
    if (!Array.isArray(values)) {
      throw new Error("Invalid serialized tx input. Must be array");
    }
    return this.fromValuesArray(values, opts);
  }
  static fromValuesArray(values, opts = {}) {
    if (values.length !== 6 && values.length !== 9) {
      throw new Error("Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).");
    }
    const [nonce, gasPrice, gasLimit, to, value, data, v, r, s] = values;
    validateNoLeadingZeroes({ nonce, gasPrice, gasLimit, value, v, r, s });
    return new Transaction({
      nonce,
      gasPrice,
      gasLimit,
      to,
      value,
      data,
      v,
      r,
      s
    }, opts);
  }
  raw() {
    return [
      bigIntToUnpaddedUint8Array(this.nonce),
      bigIntToUnpaddedUint8Array(this.gasPrice),
      bigIntToUnpaddedUint8Array(this.gasLimit),
      this.to !== void 0 ? this.to.buf : Uint8Array.from([]),
      bigIntToUnpaddedUint8Array(this.value),
      this.data,
      this.v !== void 0 ? bigIntToUnpaddedUint8Array(this.v) : Uint8Array.from([]),
      this.r !== void 0 ? bigIntToUnpaddedUint8Array(this.r) : Uint8Array.from([]),
      this.s !== void 0 ? bigIntToUnpaddedUint8Array(this.s) : Uint8Array.from([])
    ];
  }
  serialize() {
    return import_rlp3.RLP.encode(this.raw());
  }
  _getMessageToSign() {
    const values = [
      bigIntToUnpaddedUint8Array(this.nonce),
      bigIntToUnpaddedUint8Array(this.gasPrice),
      bigIntToUnpaddedUint8Array(this.gasLimit),
      this.to !== void 0 ? this.to.buf : Uint8Array.from([]),
      bigIntToUnpaddedUint8Array(this.value),
      this.data
    ];
    if (this.supports(Capability.EIP155ReplayProtection)) {
      values.push(toUint8Array(this.common.chainId()));
      values.push(unpadUint8Array(toUint8Array(0)));
      values.push(unpadUint8Array(toUint8Array(0)));
    }
    return values;
  }
  getMessageToSign(hashMessage2 = true) {
    const message = this._getMessageToSign();
    if (hashMessage2) {
      return keccak2564(import_rlp3.RLP.encode(message));
    }
    return message;
  }
  getDataFee() {
    if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
      return this.cache.dataFee.value;
    }
    if (Object.isFrozen(this)) {
      this.cache.dataFee = {
        value: super.getDataFee(),
        hardfork: this.common.hardfork()
      };
    }
    return super.getDataFee();
  }
  getUpfrontCost() {
    return this.gasLimit * this.gasPrice + this.value;
  }
  hash() {
    if (!this.isSigned()) {
      const msg = this._errorMsg("Cannot call hash method if transaction is not signed");
      throw new Error(msg);
    }
    if (Object.isFrozen(this)) {
      if (!this.cache.hash) {
        this.cache.hash = keccak2564(import_rlp3.RLP.encode(this.raw()));
      }
      return this.cache.hash;
    }
    return keccak2564(import_rlp3.RLP.encode(this.raw()));
  }
  getMessageToVerifySignature() {
    if (!this.isSigned()) {
      const msg = this._errorMsg("This transaction is not signed");
      throw new Error(msg);
    }
    const message = this._getMessageToSign();
    return keccak2564(import_rlp3.RLP.encode(message));
  }
  getSenderPublicKey() {
    const msgHash = this.getMessageToVerifySignature();
    const { v, r, s } = this;
    this._validateHighS();
    try {
      return ecrecover(msgHash, v, bigIntToUnpaddedUint8Array(r), bigIntToUnpaddedUint8Array(s), this.supports(Capability.EIP155ReplayProtection) ? this.common.chainId() : void 0);
    } catch (e) {
      const msg = this._errorMsg("Invalid Signature");
      throw new Error(msg);
    }
  }
  _processSignature(_v, r, s) {
    let v = _v;
    if (this.supports(Capability.EIP155ReplayProtection)) {
      v += this.common.chainId() * BigInt(2) + BigInt(8);
    }
    const opts = Object.assign(Object.assign({}, this.txOptions), { common: this.common });
    return Transaction.fromTxData({
      nonce: this.nonce,
      gasPrice: this.gasPrice,
      gasLimit: this.gasLimit,
      to: this.to,
      value: this.value,
      data: this.data,
      v,
      r: uint8ArrayToBigInt(r),
      s: uint8ArrayToBigInt(s)
    }, opts);
  }
  toJSON() {
    return {
      nonce: bigIntToHex(this.nonce),
      gasPrice: bigIntToHex(this.gasPrice),
      gasLimit: bigIntToHex(this.gasLimit),
      to: this.to !== void 0 ? this.to.toString() : void 0,
      value: bigIntToHex(this.value),
      data: bytesToHex4(this.data),
      v: this.v !== void 0 ? bigIntToHex(this.v) : void 0,
      r: this.r !== void 0 ? bigIntToHex(this.r) : void 0,
      s: this.s !== void 0 ? bigIntToHex(this.s) : void 0
    };
  }
  _validateTxV(_v, common) {
    let chainIdBigInt;
    const v = _v !== void 0 ? Number(_v) : void 0;
    if (v !== void 0) {
      if (v < 37 && v !== 27 && v !== 28) {
        throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${v}`);
      }
    }
    if (v !== void 0 && v !== 0 && (!common || common.gteHardfork("spuriousDragon")) && v !== 27 && v !== 28) {
      if (common) {
        if (!meetsEIP155(BigInt(v), common.chainId())) {
          throw new Error(`Incompatible EIP155-based V ${v} and chain id ${common.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`);
        }
      } else {
        let numSub;
        if ((v - 35) % 2 === 0) {
          numSub = 35;
        } else {
          numSub = 36;
        }
        chainIdBigInt = BigInt(v - numSub) / BigInt(2);
      }
    }
    return this._getCommon(common, chainIdBigInt);
  }
  errorStr() {
    let errorStr = this._getSharedErrorPostfix();
    errorStr += ` gasPrice=${this.gasPrice}`;
    return errorStr;
  }
  _errorMsg(msg) {
    return `${msg} (${this.errorStr()})`;
  }
};

// node_modules/web3-eth-accounts/lib/esm/tx/transactionFactory.js
var extraTxTypes = /* @__PURE__ */ new Map();
var TransactionFactory = class {
  constructor() {
  }
  static typeToInt(txType) {
    return Number(uint8ArrayToBigInt(toUint8Array(txType)));
  }
  static registerTransactionType(type, txClass) {
    const txType = TransactionFactory.typeToInt(type);
    extraTxTypes.set(txType, txClass);
  }
  static fromTxData(txData, txOptions = {}) {
    if (!("type" in txData) || txData.type === void 0) {
      return Transaction.fromTxData(txData, txOptions);
    }
    const txType = TransactionFactory.typeToInt(txData.type);
    if (txType === 0) {
      return Transaction.fromTxData(txData, txOptions);
    }
    if (txType === 1) {
      return AccessListEIP2930Transaction.fromTxData(
        txData,
        txOptions
      );
    }
    if (txType === 2) {
      return FeeMarketEIP1559Transaction.fromTxData(
        txData,
        txOptions
      );
    }
    const ExtraTransaction = extraTxTypes.get(txType);
    if (ExtraTransaction === null || ExtraTransaction === void 0 ? void 0 : ExtraTransaction.fromTxData) {
      return ExtraTransaction.fromTxData(txData, txOptions);
    }
    throw new Error(`Tx instantiation with type ${txType} not supported`);
  }
  static fromSerializedData(data, txOptions = {}) {
    if (data[0] <= 127) {
      switch (data[0]) {
        case 1:
          return AccessListEIP2930Transaction.fromSerializedTx(data, txOptions);
        case 2:
          return FeeMarketEIP1559Transaction.fromSerializedTx(data, txOptions);
        default: {
          const ExtraTransaction = extraTxTypes.get(Number(data[0]));
          if (ExtraTransaction === null || ExtraTransaction === void 0 ? void 0 : ExtraTransaction.fromSerializedTx) {
            return ExtraTransaction.fromSerializedTx(data, txOptions);
          }
          throw new Error(`TypedTransaction with ID ${data[0]} unknown`);
        }
      }
    } else {
      return Transaction.fromSerializedTx(data, txOptions);
    }
  }
  static fromBlockBodyData(data, txOptions = {}) {
    if (data instanceof Uint8Array) {
      return this.fromSerializedData(data, txOptions);
    }
    if (Array.isArray(data)) {
      return Transaction.fromValuesArray(data, txOptions);
    }
    throw new Error("Cannot decode transaction: unknown type input");
  }
};

// node_modules/web3-eth-accounts/lib/esm/account.js
var __awaiter31 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var parseAndValidatePrivateKey = (data, ignoreLength) => {
  let privateKeyUint8Array;
  if (!ignoreLength && typeof data === "string" && isHexStrict(data) && data.length !== 66) {
    throw new PrivateKeyLengthError();
  }
  try {
    privateKeyUint8Array = data instanceof Uint8Array ? data : bytesToUint8Array3(data);
  } catch (_a16) {
    throw new InvalidPrivateKeyError();
  }
  if (!ignoreLength && privateKeyUint8Array.byteLength !== 32) {
    throw new PrivateKeyLengthError();
  }
  return privateKeyUint8Array;
};
var hashMessage = (message) => {
  const messageHex = isHexStrict(message) ? message : utf8ToHex3(message);
  const messageBytes = hexToBytes4(messageHex);
  const preamble = hexToBytes4(fromUtf83(`Ethereum Signed Message:
${messageBytes.byteLength}`));
  const ethMessage = uint8ArrayConcat3(preamble, messageBytes);
  return sha3Raw3(ethMessage);
};
var sign3 = (data, privateKey) => {
  const privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);
  const hash = hashMessage(data);
  const signature = secp256k12.sign(hash.substring(2), privateKeyUint8Array);
  const signatureBytes = signature.toCompactRawBytes();
  const r = signature.r.toString(16).padStart(64, "0");
  const s = signature.s.toString(16).padStart(64, "0");
  const v = signature.recovery + 27;
  return {
    message: data,
    messageHash: hash,
    v: numberToHex4(v),
    r: `0x${r}`,
    s: `0x${s}`,
    signature: `${bytesToHex4(signatureBytes)}${v.toString(16)}`
  };
};
var signTransaction3 = (transaction, privateKey) => __awaiter31(void 0, void 0, void 0, function* () {
  const signedTx = transaction.sign(hexToBytes4(privateKey));
  if (isNullish(signedTx.v) || isNullish(signedTx.r) || isNullish(signedTx.s))
    throw new TransactionSigningError("Signer Error");
  const validationErrors = signedTx.validate(true);
  if (validationErrors.length > 0) {
    let errorString = "Signer Error ";
    for (const validationError of validationErrors) {
      errorString += `${errorString} ${validationError}.`;
    }
    throw new TransactionSigningError(errorString);
  }
  const rawTx = bytesToHex4(signedTx.serialize());
  const txHash = sha3Raw3(rawTx);
  return {
    messageHash: bytesToHex4(signedTx.getMessageToSign(true)),
    v: `0x${signedTx.v.toString(16)}`,
    r: `0x${signedTx.r.toString(16).padStart(64, "0")}`,
    s: `0x${signedTx.s.toString(16).padStart(64, "0")}`,
    rawTransaction: rawTx,
    transactionHash: bytesToHex4(txHash)
  };
});
var recoverTransaction = (rawTransaction) => {
  if (isNullish(rawTransaction))
    throw new UndefinedRawTransactionError();
  const tx = TransactionFactory.fromSerializedData(hexToBytes4(rawTransaction));
  return toChecksumAddress3(tx.getSenderAddress().toString());
};
var recover = (data, signatureOrV, prefixedOrR, s, prefixed) => {
  if (typeof data === "object") {
    const signatureStr = `${data.r}${data.s.slice(2)}${data.v.slice(2)}`;
    return recover(data.messageHash, signatureStr, prefixedOrR);
  }
  if (typeof signatureOrV === "string" && typeof prefixedOrR === "string" && !isNullish(s)) {
    const signatureStr = `${prefixedOrR}${s.slice(2)}${signatureOrV.slice(2)}`;
    return recover(data, signatureStr, prefixed);
  }
  if (isNullish(signatureOrV))
    throw new InvalidSignatureError("signature string undefined");
  const V_INDEX = 130;
  const hashedMessage = prefixedOrR ? data : hashMessage(data);
  let v = parseInt(signatureOrV.substring(V_INDEX), 16);
  if (v > 26) {
    v -= 27;
  }
  const ecPublicKey = secp256k12.Signature.fromCompact(signatureOrV.slice(2, V_INDEX)).addRecoveryBit(v).recoverPublicKey(hashedMessage.replace("0x", "")).toRawBytes(false);
  const publicHash = sha3Raw3(ecPublicKey.subarray(1));
  const address = toChecksumAddress3(`0x${publicHash.slice(-40)}`);
  return address;
};
var privateKeyToAddress = (privateKey) => {
  const privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);
  const publicKey = secp256k12.getPublicKey(privateKeyUint8Array, false);
  const publicKeyHash = sha3Raw3(publicKey.slice(1));
  const address = publicKeyHash.slice(-40);
  return toChecksumAddress3(`0x${address}`);
};
var privateKeyToPublicKey = (privateKey, isCompressed) => {
  const privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);
  return `0x${bytesToHex4(secp256k12.getPublicKey(privateKeyUint8Array, isCompressed)).slice(4)}`;
};
var encrypt2 = (privateKey, password, options) => __awaiter31(void 0, void 0, void 0, function* () {
  var _a16, _b, _c, _d, _e, _f, _g;
  const privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);
  let salt;
  if (options === null || options === void 0 ? void 0 : options.salt) {
    salt = typeof options.salt === "string" ? hexToBytes4(options.salt) : options.salt;
  } else {
    salt = randomBytes4(32);
  }
  if (!(isString(password) || password instanceof Uint8Array)) {
    throw new InvalidPasswordError();
  }
  const uint8ArrayPassword = typeof password === "string" ? hexToBytes4(utf8ToHex3(password)) : password;
  let initializationVector;
  if (options === null || options === void 0 ? void 0 : options.iv) {
    initializationVector = typeof options.iv === "string" ? hexToBytes4(options.iv) : options.iv;
    if (initializationVector.length !== 16) {
      throw new IVLengthError();
    }
  } else {
    initializationVector = randomBytes4(16);
  }
  const kdf = (_a16 = options === null || options === void 0 ? void 0 : options.kdf) !== null && _a16 !== void 0 ? _a16 : "scrypt";
  let derivedKey;
  let kdfparams;
  if (kdf === "pbkdf2") {
    kdfparams = {
      dklen: (_b = options === null || options === void 0 ? void 0 : options.dklen) !== null && _b !== void 0 ? _b : 32,
      salt: bytesToHex4(salt).replace("0x", ""),
      c: (_c = options === null || options === void 0 ? void 0 : options.c) !== null && _c !== void 0 ? _c : 262144,
      prf: "hmac-sha256"
    };
    if (kdfparams.c < 1e3) {
      throw new PBKDF2IterationsError();
    }
    derivedKey = pbkdf2Sync(uint8ArrayPassword, salt, kdfparams.c, kdfparams.dklen, "sha256");
  } else if (kdf === "scrypt") {
    kdfparams = {
      n: (_d = options === null || options === void 0 ? void 0 : options.n) !== null && _d !== void 0 ? _d : 8192,
      r: (_e = options === null || options === void 0 ? void 0 : options.r) !== null && _e !== void 0 ? _e : 8,
      p: (_f = options === null || options === void 0 ? void 0 : options.p) !== null && _f !== void 0 ? _f : 1,
      dklen: (_g = options === null || options === void 0 ? void 0 : options.dklen) !== null && _g !== void 0 ? _g : 32,
      salt: bytesToHex4(salt).replace("0x", "")
    };
    derivedKey = scryptSync(uint8ArrayPassword, salt, kdfparams.n, kdfparams.p, kdfparams.r, kdfparams.dklen);
  } else {
    throw new InvalidKdfError();
  }
  const cipher = yield encrypt(privateKeyUint8Array, derivedKey.slice(0, 16), initializationVector, "aes-128-ctr");
  const ciphertext = bytesToHex4(cipher).slice(2);
  const mac = sha3Raw3(uint8ArrayConcat3(derivedKey.slice(16, 32), cipher)).replace("0x", "");
  return {
    version: 3,
    id: uuidV43(),
    address: privateKeyToAddress(privateKeyUint8Array).toLowerCase().replace("0x", ""),
    crypto: {
      ciphertext,
      cipherparams: {
        iv: bytesToHex4(initializationVector).replace("0x", "")
      },
      cipher: "aes-128-ctr",
      kdf,
      kdfparams,
      mac
    }
  };
});
var privateKeyToAccount = (privateKey, ignoreLength) => {
  const privateKeyUint8Array = parseAndValidatePrivateKey(privateKey, ignoreLength);
  return {
    address: privateKeyToAddress(privateKeyUint8Array),
    privateKey: bytesToHex4(privateKeyUint8Array),
    signTransaction: (_tx) => {
      throw new TransactionSigningError("Do not have network access to sign the transaction");
    },
    sign: (data) => sign3(typeof data === "string" ? data : JSON.stringify(data), privateKeyUint8Array),
    encrypt: (password, options) => __awaiter31(void 0, void 0, void 0, function* () {
      return encrypt2(privateKeyUint8Array, password, options);
    })
  };
};
var create = () => {
  const privateKey = secp256k12.utils.randomPrivateKey();
  return privateKeyToAccount(`${bytesToHex4(privateKey)}`);
};
var decrypt2 = (keystore, password, nonStrict) => __awaiter31(void 0, void 0, void 0, function* () {
  const json = typeof keystore === "object" ? keystore : JSON.parse(nonStrict ? keystore.toLowerCase() : keystore);
  validator.validateJSONSchema(keyStoreSchema, json);
  if (json.version !== 3)
    throw new KeyStoreVersionError();
  const uint8ArrayPassword = typeof password === "string" ? hexToBytes4(utf8ToHex3(password)) : password;
  validator.validate(["bytes"], [uint8ArrayPassword]);
  let derivedKey;
  if (json.crypto.kdf === "scrypt") {
    const kdfparams = json.crypto.kdfparams;
    const uint8ArraySalt = typeof kdfparams.salt === "string" ? hexToBytes4(kdfparams.salt) : kdfparams.salt;
    derivedKey = scryptSync(uint8ArrayPassword, uint8ArraySalt, kdfparams.n, kdfparams.p, kdfparams.r, kdfparams.dklen);
  } else if (json.crypto.kdf === "pbkdf2") {
    const kdfparams = json.crypto.kdfparams;
    const uint8ArraySalt = typeof kdfparams.salt === "string" ? hexToBytes4(kdfparams.salt) : kdfparams.salt;
    derivedKey = pbkdf2Sync(uint8ArrayPassword, uint8ArraySalt, kdfparams.c, kdfparams.dklen, "sha256");
  } else {
    throw new InvalidKdfError();
  }
  const ciphertext = hexToBytes4(json.crypto.ciphertext);
  const mac = sha3Raw3(uint8ArrayConcat3(derivedKey.slice(16, 32), ciphertext)).replace("0x", "");
  if (mac !== json.crypto.mac) {
    throw new KeyDerivationError();
  }
  const seed = yield decrypt(hexToBytes4(json.crypto.ciphertext), derivedKey.slice(0, 16), hexToBytes4(json.crypto.cipherparams.iv));
  return privateKeyToAccount(seed);
});

// node_modules/web3-eth-accounts/lib/esm/types.js
init_shim();

// node_modules/web3-eth-accounts/lib/esm/common/index.js
init_shim();

// node_modules/web3-eth-accounts/lib/esm/tx/index.js
init_shim();

// node_modules/web3-eth/lib/esm/utils/decode_signed_transaction.js
init_shim();

// node_modules/web3-eth/lib/esm/utils/detect_transaction_type.js
init_shim();
var transactionType0x0Schema = {
  type: "object",
  properties: {
    accessList: {
      type: "null"
    },
    maxFeePerGas: {
      type: "null"
    },
    maxPriorityFeePerGas: {
      type: "null"
    }
  }
};
var transactionType0x1Schema = {
  type: "object",
  properties: {
    maxFeePerGas: {
      type: "null"
    },
    maxPriorityFeePerGas: {
      type: "null"
    }
  }
};
var transactionType0x2Schema = {
  type: "object",
  properties: {
    gasPrice: {
      type: "null"
    }
  }
};
var validateTxTypeAndHandleErrors = (txSchema, tx, txType) => {
  try {
    validator.validateJSONSchema(txSchema, tx);
  } catch (error) {
    if (error instanceof Web3ValidatorError)
      throw new InvalidPropertiesForTransactionTypeError(error.errors, txType);
    throw error;
  }
};
var defaultTransactionTypeParser = (transaction) => {
  var _a16, _b;
  const tx = transaction;
  if (!isNullish(tx.type)) {
    let txSchema;
    switch (tx.type) {
      case "0x0":
        txSchema = transactionType0x0Schema;
        break;
      case "0x1":
        txSchema = transactionType0x1Schema;
        break;
      case "0x2":
        txSchema = transactionType0x2Schema;
        break;
      default:
        return format2({ format: "uint" }, tx.type, ETH_DATA_FORMAT);
    }
    validateTxTypeAndHandleErrors(txSchema, tx, tx.type);
    return format2({ format: "uint" }, tx.type, ETH_DATA_FORMAT);
  }
  if (!isNullish(tx.maxFeePerGas) || !isNullish(tx.maxPriorityFeePerGas)) {
    validateTxTypeAndHandleErrors(transactionType0x2Schema, tx, "0x2");
    return "0x2";
  }
  if (!isNullish(tx.accessList)) {
    validateTxTypeAndHandleErrors(transactionType0x1Schema, tx, "0x1");
    return "0x1";
  }
  const givenHardfork = (_a16 = tx.hardfork) !== null && _a16 !== void 0 ? _a16 : (_b = tx.common) === null || _b === void 0 ? void 0 : _b.hardfork;
  if (!isNullish(givenHardfork)) {
    const hardforkIndex = Object.keys(HardforksOrdered).indexOf(givenHardfork);
    if (hardforkIndex >= Object.keys(HardforksOrdered).indexOf("london"))
      return !isNullish(tx.gasPrice) ? "0x0" : "0x2";
    if (hardforkIndex === Object.keys(HardforksOrdered).indexOf("berlin"))
      return "0x0";
  }
  if (!isNullish(tx.gasPrice)) {
    validateTxTypeAndHandleErrors(transactionType0x0Schema, tx, "0x0");
    return "0x0";
  }
  return void 0;
};
var detectTransactionType = (transaction, web3Context) => {
  var _a16;
  return ((_a16 = web3Context === null || web3Context === void 0 ? void 0 : web3Context.transactionTypeParser) !== null && _a16 !== void 0 ? _a16 : defaultTransactionTypeParser)(transaction);
};
var detectRawTransactionType = (transaction) => transaction[0] > 127 ? "0x0" : toHex2(transaction[0]);

// node_modules/web3-eth/lib/esm/utils/format_transaction.js
init_shim();

// node_modules/web3-eth/lib/esm/schemas.js
init_shim();
var accessListItemSchema = {
  type: "object",
  properties: {
    address: {
      format: "address"
    },
    storageKeys: {
      type: "array",
      items: {
        format: "bytes32"
      }
    }
  }
};
var accessListSchema = {
  type: "array",
  items: Object.assign({}, accessListItemSchema)
};
var accessListResultSchema = {
  type: "object",
  properties: {
    accessList: Object.assign({}, accessListSchema),
    gasUsed: {
      type: "string"
    }
  }
};
var chainSchema = {
  type: "string",
  enum: ["goerli", "kovan", "mainnet", "rinkeby", "ropsten", "sepolia"]
};
var hardforkSchema = {
  type: "string",
  enum: [
    "arrowGlacier",
    "berlin",
    "byzantium",
    "chainstart",
    "constantinople",
    "dao",
    "homestead",
    "istanbul",
    "london",
    "merge",
    "muirGlacier",
    "petersburg",
    "shanghai",
    "spuriousDragon",
    "tangerineWhistle"
  ]
};
var customChainSchema = {
  type: "object",
  properties: {
    name: {
      format: "string"
    },
    networkId: {
      format: "uint"
    },
    chainId: {
      format: "uint"
    }
  }
};
var transactionSchema = {
  type: "object",
  properties: {
    from: {
      format: "address"
    },
    to: {
      oneOf: [{ format: "address" }, { type: "null" }]
    },
    value: {
      format: "uint"
    },
    gas: {
      format: "uint"
    },
    gasPrice: {
      format: "uint"
    },
    effectiveGasPrice: {
      format: "uint"
    },
    type: {
      format: "uint"
    },
    maxFeePerGas: {
      format: "uint"
    },
    maxPriorityFeePerGas: {
      format: "uint"
    },
    accessList: Object.assign({}, accessListSchema),
    data: {
      format: "bytes"
    },
    input: {
      format: "bytes"
    },
    nonce: {
      format: "uint"
    },
    chain: Object.assign({}, chainSchema),
    hardfork: Object.assign({}, hardforkSchema),
    chainId: {
      format: "uint"
    },
    networkId: {
      format: "uint"
    },
    common: {
      type: "object",
      properties: {
        customChain: Object.assign({}, customChainSchema),
        baseChain: Object.assign({}, chainSchema),
        hardfork: Object.assign({}, hardforkSchema)
      }
    },
    gasLimit: {
      format: "uint"
    },
    v: {
      format: "uint"
    },
    r: {
      format: "bytes32"
    },
    s: {
      format: "bytes32"
    }
  }
};
var transactionInfoSchema = {
  type: "object",
  properties: Object.assign(Object.assign({}, transactionSchema.properties), { blockHash: {
    format: "bytes32"
  }, blockNumber: {
    format: "uint"
  }, hash: {
    format: "bytes32"
  }, transactionIndex: {
    format: "uint"
  }, from: {
    format: "address"
  }, to: {
    oneOf: [{ format: "address" }, { type: "null" }]
  }, value: {
    format: "uint"
  }, gas: {
    format: "uint"
  }, gasPrice: {
    format: "uint"
  }, effectiveGasPrice: {
    format: "uint"
  }, type: {
    format: "uint"
  }, maxFeePerGas: {
    format: "uint"
  }, maxPriorityFeePerGas: {
    format: "uint"
  }, accessList: Object.assign({}, accessListSchema), data: {
    format: "bytes"
  }, input: {
    format: "bytes"
  }, nonce: {
    format: "uint"
  }, gasLimit: {
    format: "uint"
  }, v: {
    format: "uint"
  }, r: {
    format: "bytes32"
  }, s: {
    format: "bytes32"
  } })
};
var blockSchema = {
  type: "object",
  properties: {
    parentHash: {
      format: "bytes32"
    },
    sha3Uncles: {
      format: "bytes32"
    },
    miner: {
      format: "bytes"
    },
    stateRoot: {
      format: "bytes32"
    },
    transactionsRoot: {
      format: "bytes32"
    },
    receiptsRoot: {
      format: "bytes32"
    },
    logsBloom: {
      format: "bytes256"
    },
    difficulty: {
      format: "uint"
    },
    number: {
      format: "uint"
    },
    gasLimit: {
      format: "uint"
    },
    gasUsed: {
      format: "uint"
    },
    timestamp: {
      format: "uint"
    },
    extraData: {
      format: "bytes"
    },
    mixHash: {
      format: "bytes32"
    },
    nonce: {
      format: "uint"
    },
    totalDifficulty: {
      format: "uint"
    },
    baseFeePerGas: {
      format: "uint"
    },
    size: {
      format: "uint"
    },
    transactions: {
      oneOf: [
        {
          type: "array",
          items: Object.assign({}, transactionInfoSchema)
        },
        {
          type: "array",
          items: {
            format: "bytes32"
          }
        }
      ]
    },
    uncles: {
      type: "array",
      items: {
        format: "bytes32"
      }
    },
    hash: {
      format: "bytes32"
    }
  }
};
var withdrawalsSchema = {
  type: "object",
  properties: {
    index: {
      format: "uint"
    },
    validatorIndex: {
      format: "uint"
    },
    address: {
      format: "address"
    },
    amount: {
      format: "uint"
    }
  }
};
var blockHeaderSchema = {
  type: "object",
  properties: {
    author: {
      format: "bytes32"
    },
    hash: {
      format: "bytes32"
    },
    parentHash: {
      format: "bytes32"
    },
    receiptsRoot: {
      format: "bytes32"
    },
    miner: {
      format: "bytes"
    },
    stateRoot: {
      format: "bytes32"
    },
    transactionsRoot: {
      format: "bytes32"
    },
    withdrawalsRoot: {
      format: "bytes32"
    },
    logsBloom: {
      format: "bytes256"
    },
    difficulty: {
      format: "uint"
    },
    totalDifficulty: {
      format: "uint"
    },
    number: {
      format: "uint"
    },
    gasLimit: {
      format: "uint"
    },
    gasUsed: {
      format: "uint"
    },
    timestamp: {
      format: "uint"
    },
    extraData: {
      format: "bytes"
    },
    nonce: {
      format: "uint"
    },
    sha3Uncles: {
      format: "bytes32"
    },
    size: {
      format: "uint"
    },
    baseFeePerGas: {
      format: "uint"
    },
    excessDataGas: {
      format: "uint"
    },
    mixHash: {
      format: "bytes32"
    },
    transactions: {
      type: "array",
      items: {
        format: "bytes32"
      }
    },
    uncles: {
      type: "array",
      items: {
        format: "bytes32"
      }
    },
    withdrawals: {
      type: "array",
      items: Object.assign({}, withdrawalsSchema)
    }
  }
};
var logSchema = {
  type: "object",
  properties: {
    removed: {
      format: "bool"
    },
    logIndex: {
      format: "uint"
    },
    transactionIndex: {
      format: "uint"
    },
    transactionHash: {
      format: "bytes32"
    },
    blockHash: {
      format: "bytes32"
    },
    blockNumber: {
      format: "uint"
    },
    address: {
      format: "address"
    },
    data: {
      format: "bytes"
    },
    topics: {
      type: "array",
      items: {
        format: "bytes32"
      }
    }
  }
};
var syncSchema = {
  type: "object",
  properties: {
    startingBlock: {
      format: "string"
    },
    currentBlock: {
      format: "string"
    },
    highestBlock: {
      format: "string"
    },
    knownStates: {
      format: "string"
    },
    pulledStates: {
      format: "string"
    }
  }
};
var transactionReceiptSchema = {
  type: "object",
  properties: {
    transactionHash: {
      format: "bytes32"
    },
    transactionIndex: {
      format: "uint"
    },
    blockHash: {
      format: "bytes32"
    },
    blockNumber: {
      format: "uint"
    },
    from: {
      format: "address"
    },
    to: {
      format: "address"
    },
    cumulativeGasUsed: {
      format: "uint"
    },
    gasUsed: {
      format: "uint"
    },
    effectiveGasPrice: {
      format: "uint"
    },
    contractAddress: {
      format: "address"
    },
    logs: {
      type: "array",
      items: Object.assign({}, logSchema)
    },
    logsBloom: {
      format: "bytes"
    },
    root: {
      format: "bytes"
    },
    status: {
      format: "uint"
    },
    type: {
      format: "uint"
    }
  }
};
var SignatureObjectSchema = {
  type: "object",
  properties: {
    messageHash: {
      format: "bytes"
    },
    r: {
      format: "bytes32"
    },
    s: {
      format: "bytes32"
    },
    v: {
      format: "bytes"
    },
    message: {
      format: "bytes"
    },
    signature: {
      format: "bytes"
    }
  }
};
var feeHistorySchema = {
  type: "object",
  properties: {
    oldestBlock: {
      format: "uint"
    },
    baseFeePerGas: {
      type: "array",
      items: {
        format: "uint"
      }
    },
    reward: {
      type: "array",
      items: {
        type: "array",
        items: {
          format: "uint"
        }
      }
    },
    gasUsedRatio: {
      type: "array",
      items: {
        type: "number"
      }
    }
  }
};
var storageProofSchema = {
  type: "object",
  properties: {
    key: {
      format: "bytes32"
    },
    value: {
      format: "uint"
    },
    proof: {
      type: "array",
      items: {
        format: "bytes32"
      }
    }
  }
};
var accountSchema = {
  type: "object",
  properties: {
    balance: {
      format: "uint"
    },
    codeHash: {
      format: "bytes32"
    },
    nonce: {
      format: "uint"
    },
    storageHash: {
      format: "bytes32"
    },
    accountProof: {
      type: "array",
      items: {
        format: "bytes32"
      }
    },
    storageProof: {
      type: "array",
      items: Object.assign({}, storageProofSchema)
    }
  }
};

// node_modules/web3-eth/lib/esm/utils/format_transaction.js
function formatTransaction(transaction, returnFormat = DEFAULT_RETURN_FORMAT, options = {
  transactionSchema: transactionInfoSchema,
  fillInputAndData: false
}) {
  var _a16, _b;
  let formattedTransaction = mergeDeep2({}, transaction);
  if (!isNullish(transaction === null || transaction === void 0 ? void 0 : transaction.common)) {
    formattedTransaction.common = Object.assign({}, transaction.common);
    if (!isNullish((_a16 = transaction.common) === null || _a16 === void 0 ? void 0 : _a16.customChain))
      formattedTransaction.common.customChain = Object.assign({}, transaction.common.customChain);
  }
  formattedTransaction = format2((_b = options.transactionSchema) !== null && _b !== void 0 ? _b : transactionInfoSchema, formattedTransaction, returnFormat);
  if (!isNullish(formattedTransaction.data) && !isNullish(formattedTransaction.input) && toHex2(formattedTransaction.data) !== toHex2(formattedTransaction.input))
    throw new TransactionDataAndInputError({
      data: bytesToHex3(formattedTransaction.data),
      input: bytesToHex3(formattedTransaction.input)
    });
  if (options.fillInputAndData) {
    if (!isNullish(formattedTransaction.data)) {
      formattedTransaction.input = formattedTransaction.data;
    } else if (!isNullish(formattedTransaction.input)) {
      formattedTransaction.data = formattedTransaction.input;
    }
  }
  if (!isNullish(formattedTransaction.gasLimit)) {
    formattedTransaction.gas = formattedTransaction.gasLimit;
    delete formattedTransaction.gasLimit;
  }
  return formattedTransaction;
}

// node_modules/web3-eth/lib/esm/utils/decode_signed_transaction.js
function decodeSignedTransaction(encodedSignedTransaction, returnFormat, options = { fillInputAndData: false }) {
  return {
    raw: format2({ format: "bytes" }, encodedSignedTransaction, returnFormat),
    tx: formatTransaction(Object.assign(Object.assign({}, TransactionFactory.fromSerializedData(hexToBytes3(encodedSignedTransaction)).toJSON()), { hash: bytesToHex3(keccak256Wrapper2(hexToBytes3(encodedSignedTransaction))), type: detectRawTransactionType(hexToBytes3(encodedSignedTransaction)) }), returnFormat, { fillInputAndData: options.fillInputAndData })
  };
}

// node_modules/web3-eth/lib/esm/utils/transaction_builder.js
init_shim();

// node_modules/web3-net/lib/esm/index.js
var esm_exports11 = {};
__export(esm_exports11, {
  Net: () => Net,
  default: () => esm_default2,
  getId: () => getId2,
  getPeerCount: () => getPeerCount2,
  isListening: () => isListening2
});
init_shim();

// node_modules/web3-net/lib/esm/net.js
init_shim();

// node_modules/web3-net/node_modules/web3-core/lib/esm/index.js
init_shim();

// node_modules/web3-net/node_modules/web3-core/lib/esm/web3_config.js
init_shim();

// node_modules/web3-net/node_modules/web3-utils/lib/esm/index.js
init_shim();

// node_modules/web3-net/node_modules/web3-utils/lib/esm/converters.js
init_shim();

// node_modules/web3-net/node_modules/ethereum-cryptography/esm/keccak.js
init_shim();
init_sha3();

// node_modules/web3-net/node_modules/ethereum-cryptography/esm/utils.js
init_shim();
init_assert();
init_utils();
init_utils();
var assertBool5 = assert_default.bool;
var assertBytes5 = assert_default.bytes;
function bytesToUtf84(data) {
  if (!(data instanceof Uint8Array)) {
    throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
  }
  return new TextDecoder().decode(data);
}
function wrapHash5(hash) {
  return (msg) => {
    assert_default.bytes(msg);
    return hash(msg);
  };
}
var crypto7 = (() => {
  const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
  return {
    node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
    web: webCrypto
  };
})();

// node_modules/web3-net/node_modules/ethereum-cryptography/esm/keccak.js
var keccak2245 = wrapHash5(keccak_224);
var keccak2565 = (() => {
  const k = wrapHash5(keccak_256);
  k.create = keccak_256.create;
  return k;
})();
var keccak3845 = wrapHash5(keccak_384);
var keccak5125 = wrapHash5(keccak_512);

// node_modules/web3-net/node_modules/web3-utils/lib/esm/converters.js
var ethUnitMap4 = {
  noether: BigInt(0),
  wei: BigInt(1),
  kwei: BigInt(1e3),
  Kwei: BigInt(1e3),
  babbage: BigInt(1e3),
  femtoether: BigInt(1e3),
  mwei: BigInt(1e6),
  Mwei: BigInt(1e6),
  lovelace: BigInt(1e6),
  picoether: BigInt(1e6),
  gwei: BigInt(1e9),
  Gwei: BigInt(1e9),
  shannon: BigInt(1e9),
  nanoether: BigInt(1e9),
  nano: BigInt(1e9),
  szabo: BigInt(1e12),
  microether: BigInt(1e12),
  micro: BigInt(1e12),
  finney: BigInt(1e15),
  milliether: BigInt(1e15),
  milli: BigInt(1e15),
  ether: BigInt("1000000000000000000"),
  kether: BigInt("1000000000000000000000"),
  grand: BigInt("1000000000000000000000"),
  mether: BigInt("1000000000000000000000000"),
  gether: BigInt("1000000000000000000000000000"),
  tether: BigInt("1000000000000000000000000000000")
};
var bytesToUint8Array4 = (data) => {
  validator.validate(["bytes"], [data]);
  if (data instanceof Uint8Array) {
    return data;
  }
  if (Array.isArray(data)) {
    return new Uint8Array(data);
  }
  if (typeof data === "string") {
    return utils_exports.hexToUint8Array(data);
  }
  throw new InvalidBytesError(data);
};
var { uint8ArrayToHexString: uint8ArrayToHexString5 } = utils_exports;
var bytesToHex5 = (bytes) => uint8ArrayToHexString5(bytesToUint8Array4(bytes));
var hexToBytes5 = (bytes) => {
  if (typeof bytes === "string" && bytes.slice(0, 2).toLowerCase() !== "0x") {
    return bytesToUint8Array4(`0x${bytes}`);
  }
  return bytesToUint8Array4(bytes);
};
var hexToNumber4 = (value) => {
  validator.validate(["hex"], [value]);
  return utils_exports.hexToNumber(value);
};
var numberToHex5 = (value, hexstrict) => {
  if (typeof value !== "bigint")
    validator.validate(["int"], [value]);
  let updatedValue = utils_exports.numberToHex(value);
  if (hexstrict) {
    if (!updatedValue.startsWith("-") && updatedValue.length % 2 === 1) {
      updatedValue = "0x0".concat(updatedValue.slice(2));
    } else if (updatedValue.length % 2 === 0 && updatedValue.startsWith("-"))
      updatedValue = "-0x0".concat(updatedValue.slice(3));
  }
  return updatedValue;
};
var hexToNumberString3 = (data) => hexToNumber4(data).toString();
var utf8ToHex4 = (str) => {
  validator.validate(["string"], [str]);
  let strWithoutNullCharacter = str.replace(/^(?:\u0000)/, "");
  strWithoutNullCharacter = strWithoutNullCharacter.replace(/(?:\u0000)$/, "");
  return bytesToHex5(new TextEncoder().encode(strWithoutNullCharacter));
};
var fromUtf84 = utf8ToHex4;
var hexToUtf83 = (str) => bytesToUtf84(hexToBytes5(str));
var toUtf83 = (input) => {
  if (typeof input === "string") {
    return hexToUtf83(input);
  }
  validator.validate(["bytes"], [input]);
  return bytesToUtf84(input);
};
var utf8ToBytes5 = utf8ToBytes;
var toHex4 = (value, returnType) => {
  if (typeof value === "string" && isAddress(value)) {
    return returnType ? "address" : `0x${value.toLowerCase().replace(/^0x/i, "")}`;
  }
  if (typeof value === "boolean") {
    return returnType ? "bool" : value ? "0x01" : "0x00";
  }
  if (typeof value === "number") {
    return returnType ? value < 0 ? "int256" : "uint256" : numberToHex5(value);
  }
  if (typeof value === "bigint") {
    return returnType ? "bigint" : numberToHex5(value);
  }
  if (typeof value === "object" && !!value) {
    return returnType ? "string" : utf8ToHex4(JSON.stringify(value));
  }
  if (typeof value === "string") {
    if (value.startsWith("-0x") || value.startsWith("-0X")) {
      return returnType ? "int256" : numberToHex5(value);
    }
    if (isHexStrict(value)) {
      return returnType ? "bytes" : value;
    }
    if (isHex(value) && !isInt(value)) {
      return returnType ? "bytes" : `0x${value}`;
    }
    if (!Number.isFinite(value)) {
      return returnType ? "string" : utf8ToHex4(value);
    }
  }
  throw new HexProcessingError(value);
};
var toNumber4 = (value) => {
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "bigint") {
    return value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER ? Number(value) : value;
  }
  if (typeof value === "string" && isHexStrict(value)) {
    return hexToNumber4(value);
  }
  try {
    return toNumber4(BigInt(value));
  } catch (_a16) {
    throw new InvalidNumberError(value);
  }
};
var toBigInt4 = (value) => {
  if (typeof value === "number") {
    return BigInt(value);
  }
  if (typeof value === "bigint") {
    return value;
  }
  if (typeof value === "string" && isHex(value)) {
    if (value.startsWith("-")) {
      return -BigInt(value.substring(1));
    }
    return BigInt(value);
  }
  throw new InvalidNumberError(value);
};
var toChecksumAddress4 = (address) => {
  if (!isAddress(address, false)) {
    throw new InvalidAddressError(address);
  }
  const lowerCaseAddress = address.toLowerCase().replace(/^0x/i, "");
  const hash = utils_exports.uint8ArrayToHexString(keccak2565(utf8ToBytes5(lowerCaseAddress)));
  if (isNullish(hash) || hash === "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470")
    return "";
  let checksumAddress = "0x";
  const addressHash = hash.replace(/^0x/i, "");
  for (let i = 0; i < lowerCaseAddress.length; i += 1) {
    if (parseInt(addressHash[i], 16) > 7) {
      checksumAddress += lowerCaseAddress[i].toUpperCase();
    } else {
      checksumAddress += lowerCaseAddress[i];
    }
  }
  return checksumAddress;
};

// node_modules/web3-net/node_modules/web3-utils/lib/esm/event_emitter.js
init_shim();
var import_events7 = __toESM(require_events(), 1);
var __awaiter32 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var wrapFunction4 = (fn) => (params) => fn(params.detail);
var EventEmitterAtBrowser4 = class extends EventTarget {
  constructor() {
    super(...arguments);
    this._listeners = {};
    this.maxListeners = Number.MAX_SAFE_INTEGER;
  }
  on(eventName, fn) {
    this.addEventListener(eventName, fn);
    return this;
  }
  once(eventName, fn) {
    const onceCallback = (params) => __awaiter32(this, void 0, void 0, function* () {
      this.off(eventName, onceCallback);
      yield fn(params);
    });
    return this.on(eventName, onceCallback);
  }
  off(eventName, fn) {
    this.removeEventListener(eventName, fn);
    return this;
  }
  emit(eventName, params) {
    const event = new CustomEvent(eventName, { detail: params });
    return super.dispatchEvent(event);
  }
  listenerCount(eventName) {
    const eventListeners = this._listeners[eventName];
    return eventListeners ? eventListeners.length : 0;
  }
  listeners(eventName) {
    return this._listeners[eventName].map((value) => value[0]) || [];
  }
  eventNames() {
    return Object.keys(this._listeners);
  }
  removeAllListeners() {
    Object.keys(this._listeners).forEach((event) => {
      this._listeners[event].forEach((listener) => {
        super.removeEventListener(event, listener[1]);
      });
    });
    this._listeners = {};
    return this;
  }
  setMaxListeners(maxListeners) {
    this.maxListeners = maxListeners;
    return this;
  }
  getMaxListeners() {
    return this.maxListeners;
  }
  addEventListener(eventName, fn) {
    const wrappedFn = wrapFunction4(fn);
    super.addEventListener(eventName, wrappedFn);
    if (!this._listeners[eventName]) {
      this._listeners[eventName] = [];
    }
    this._listeners[eventName].push([fn, wrappedFn]);
  }
  removeEventListener(eventName, fn) {
    const eventListeners = this._listeners[eventName];
    if (eventListeners) {
      const index = eventListeners.findIndex((item) => item[0] === fn);
      if (index !== -1) {
        super.removeEventListener(eventName, eventListeners[index][1]);
        eventListeners.splice(index, 1);
      }
    }
  }
};
var EventEmitterType4;
if (typeof window === "undefined") {
  EventEmitterType4 = import_events7.EventEmitter;
} else {
  EventEmitterType4 = EventEmitterAtBrowser4;
}
var EventEmitter7 = class extends EventEmitterType4 {
};

// node_modules/web3-net/node_modules/web3-utils/lib/esm/validation.js
init_shim();
var isHexStrict4 = isHexStrict;
var isAddress4 = isAddress;
var isNullish5 = isNullish;

// node_modules/web3-net/node_modules/web3-utils/lib/esm/formatter.js
init_shim();

// node_modules/web3-net/node_modules/web3-utils/lib/esm/objects.js
init_shim();
var isIterable3 = (item) => typeof item === "object" && !isNullish(item) && !Array.isArray(item) && !(item instanceof TypedArray);
var mergeDeep4 = (destination, ...sources) => {
  const result = destination;
  if (!isIterable3(result)) {
    return result;
  }
  for (const src of sources) {
    for (const key in src) {
      if (isIterable3(src[key])) {
        if (!result[key]) {
          result[key] = {};
        }
        mergeDeep4(result[key], src[key]);
      } else if (!isNullish(src[key]) && Object.hasOwnProperty.call(src, key)) {
        if (Array.isArray(src[key]) || src[key] instanceof TypedArray) {
          result[key] = src[key].slice(0);
        } else {
          result[key] = src[key];
        }
      }
    }
  }
  return result;
};

// node_modules/web3-net/node_modules/web3-utils/lib/esm/string_manipulation.js
init_shim();
var padLeft5 = (value, characterAmount, sign6 = "0") => {
  if (typeof value === "string") {
    if (!isHexStrict(value)) {
      return value.padStart(characterAmount, sign6);
    }
    return utils_exports.padLeft(value, characterAmount, sign6);
  }
  validator.validate(["int"], [value]);
  return utils_exports.padLeft(value, characterAmount, sign6);
};
var leftPad4 = padLeft5;

// node_modules/web3-net/node_modules/web3-utils/lib/esm/uint8array.js
init_shim();
function uint8ArrayConcat4(...parts) {
  const length = parts.reduce((prev, part) => {
    const agg = prev + part.length;
    return agg;
  }, 0);
  const result = new Uint8Array(length);
  let offset = 0;
  for (const part of parts) {
    result.set(part, offset);
    offset += part.length;
  }
  return result;
}

// node_modules/web3-net/node_modules/web3-utils/lib/esm/formatter.js
var { parseBaseType: parseBaseType5 } = utils_exports;
var findSchemaByDataPath3 = (schema, dataPath, oneOfPath = []) => {
  let result = Object.assign({}, schema);
  let previousDataPath;
  for (const dataPart of dataPath) {
    if (result.oneOf && previousDataPath) {
      const path = oneOfPath.find(function(element) {
        return this === element[0];
      }, previousDataPath !== null && previousDataPath !== void 0 ? previousDataPath : "");
      if (path && path[0] === previousDataPath) {
        result = result.oneOf[path[1]];
      }
    }
    if (!result.properties && !result.items) {
      return void 0;
    }
    if (result.properties) {
      result = result.properties[dataPart];
    } else if (result.items && result.items.properties) {
      const node = result.items.properties;
      if (!node) {
        return void 0;
      }
      result = node[dataPart];
    } else if (result.items && isObject(result.items)) {
      result = result.items;
    } else if (result.items && Array.isArray(result.items)) {
      result = result.items[parseInt(dataPart, 10)];
    }
    if (result && dataPart)
      previousDataPath = dataPart;
  }
  return result;
};
var convertScalarValue3 = (value, ethType, format5) => {
  try {
    const { baseType, baseTypeSize } = parseBaseType5(ethType);
    if (baseType === "int" || baseType === "uint") {
      switch (format5.number) {
        case FMT_NUMBER.NUMBER:
          return Number(toBigInt4(value));
        case FMT_NUMBER.HEX:
          return numberToHex5(toBigInt4(value));
        case FMT_NUMBER.STR:
          return toBigInt4(value).toString();
        case FMT_NUMBER.BIGINT:
          return toBigInt4(value);
        default:
          throw new FormatterError(`Invalid format: ${String(format5.number)}`);
      }
    }
    if (baseType === "bytes") {
      let paddedValue;
      if (baseTypeSize) {
        if (typeof value === "string")
          paddedValue = padLeft5(value, baseTypeSize * 2);
        else if (value instanceof Uint8Array) {
          paddedValue = uint8ArrayConcat4(new Uint8Array(baseTypeSize - value.length), value);
        }
      } else {
        paddedValue = value;
      }
      switch (format5.bytes) {
        case FMT_BYTES.HEX:
          return bytesToHex5(bytesToUint8Array4(paddedValue));
        case FMT_BYTES.UINT8ARRAY:
          return bytesToUint8Array4(paddedValue);
        default:
          throw new FormatterError(`Invalid format: ${String(format5.bytes)}`);
      }
    }
  } catch (error) {
    return value;
  }
  return value;
};
var convert3 = (data, schema, dataPath, format5, oneOfPath = []) => {
  var _a16, _b;
  if (!isObject(data) && !Array.isArray(data)) {
    return convertScalarValue3(data, schema === null || schema === void 0 ? void 0 : schema.format, format5);
  }
  const object = data;
  for (const [key, value] of Object.entries(object)) {
    dataPath.push(key);
    const schemaProp = findSchemaByDataPath3(schema, dataPath, oneOfPath);
    if (isNullish(schemaProp)) {
      delete object[key];
      dataPath.pop();
      continue;
    }
    if (isObject(value)) {
      convert3(value, schema, dataPath, format5);
      dataPath.pop();
      continue;
    }
    if (Array.isArray(value)) {
      let _schemaProp = schemaProp;
      if ((schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.oneOf) !== void 0) {
        schemaProp.oneOf.forEach((oneOfSchemaProp, index) => {
          var _a17, _b2;
          if (!Array.isArray(schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.items) && (typeof value[0] === "object" && ((_a17 = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _a17 === void 0 ? void 0 : _a17.type) === "object" || typeof value[0] === "string" && ((_b2 = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _b2 === void 0 ? void 0 : _b2.type) !== "object")) {
            _schemaProp = oneOfSchemaProp;
            oneOfPath.push([key, index]);
          }
        });
      }
      if (isNullish(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {
        delete object[key];
        dataPath.pop();
        continue;
      }
      if (isObject(_schemaProp.items) && !isNullish(_schemaProp.items.format)) {
        for (let i = 0; i < value.length; i += 1) {
          object[key][i] = convertScalarValue3(
            value[i],
            (_a16 = _schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) === null || _a16 === void 0 ? void 0 : _a16.format,
            format5
          );
        }
        dataPath.pop();
        continue;
      }
      if (!Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) && ((_b = _schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) === null || _b === void 0 ? void 0 : _b.type) === "object") {
        for (const arrObject of value) {
          convert3(arrObject, schema, dataPath, format5, oneOfPath);
        }
        dataPath.pop();
        continue;
      }
      if (Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {
        for (let i = 0; i < value.length; i += 1) {
          object[key][i] = convertScalarValue3(value[i], _schemaProp.items[i].format, format5);
        }
        dataPath.pop();
        continue;
      }
    }
    object[key] = convertScalarValue3(value, schemaProp.format, format5);
    dataPath.pop();
  }
  return object;
};
var format3 = (schema, data, returnFormat) => {
  let dataToParse;
  if (isObject(data)) {
    dataToParse = mergeDeep4({}, data);
  } else if (Array.isArray(data)) {
    dataToParse = [...data];
  } else {
    dataToParse = data;
  }
  const jsonSchema = isObject(schema) ? schema : utils_exports.ethAbiToJsonSchema(schema);
  if (!jsonSchema.properties && !jsonSchema.items && !jsonSchema.format) {
    throw new FormatterError("Invalid json schema for formatting");
  }
  return convert3(dataToParse, jsonSchema, [], returnFormat);
};

// node_modules/web3-net/node_modules/web3-utils/lib/esm/hash.js
init_shim();
var SHA3_EMPTY_BYTES4 = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
var sha34 = (data) => {
  let updatedData;
  if (typeof data === "string") {
    if (data.startsWith("0x") && isHexStrict(data)) {
      updatedData = hexToBytes5(data);
    } else {
      updatedData = utf8ToBytes(data);
    }
  } else {
    updatedData = data;
  }
  const hash = bytesToHex5(keccak2565(updatedData));
  return hash === SHA3_EMPTY_BYTES4 ? void 0 : hash;
};
var sha3Raw4 = (data) => {
  const hash = sha34(data);
  if (isNullish(hash)) {
    return SHA3_EMPTY_BYTES4;
  }
  return hash;
};

// node_modules/web3-net/node_modules/web3-utils/lib/esm/random.js
init_shim();

// node_modules/web3-net/node_modules/ethereum-cryptography/esm/random.js
init_shim();
init_utils();
function getRandomBytesSync4(bytes) {
  return randomBytes(bytes);
}

// node_modules/web3-net/node_modules/web3-utils/lib/esm/random.js
var randomBytes5 = (size) => getRandomBytesSync4(size);

// node_modules/web3-net/node_modules/web3-utils/lib/esm/promise_helpers.js
init_shim();
function isPromise3(object) {
  return (typeof object === "object" || typeof object === "function") && typeof object.then === "function";
}

// node_modules/web3-net/node_modules/web3-utils/lib/esm/json_rpc.js
var json_rpc_exports4 = {};
__export(json_rpc_exports4, {
  isBatchRequest: () => isBatchRequest4,
  isBatchResponse: () => isBatchResponse4,
  isResponseRpcError: () => isResponseRpcError4,
  isResponseWithError: () => isResponseWithError5,
  isResponseWithNotification: () => isResponseWithNotification4,
  isResponseWithResult: () => isResponseWithResult4,
  isSubscriptionResult: () => isSubscriptionResult4,
  isValidResponse: () => isValidResponse4,
  setRequestIdStart: () => setRequestIdStart4,
  toBatchPayload: () => toBatchPayload4,
  toPayload: () => toPayload4,
  validateResponse: () => validateResponse4
});
init_shim();

// node_modules/web3-net/node_modules/web3-utils/lib/esm/uuid.js
init_shim();
var uuidV44 = () => {
  const bytes = randomBytes5(16);
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 63 | 128;
  const hexString = bytesToHex5(bytes);
  return [
    hexString.substring(2, 10),
    hexString.substring(10, 14),
    hexString.substring(14, 18),
    hexString.substring(18, 22),
    hexString.substring(22, 34)
  ].join("-");
};

// node_modules/web3-net/node_modules/web3-utils/lib/esm/json_rpc.js
var isResponseRpcError4 = (rpcError) => {
  const errorCode = rpcError.error.code;
  return rpcErrorsMap.has(errorCode) || errorCode >= -32099 && errorCode <= -32e3;
};
var isResponseWithResult4 = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && "result" in response && isNullish(response.error) && (typeof response.id === "number" || typeof response.id === "string");
var isResponseWithError5 = (response) => !Array.isArray(response) && response.jsonrpc === "2.0" && !!response && isNullish(response.result) && "error" in response && (typeof response.id === "number" || typeof response.id === "string");
var isResponseWithNotification4 = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && !isNullish(response.params) && !isNullish(response.method);
var isSubscriptionResult4 = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && "id" in response && "result" in response;
var validateResponse4 = (response) => isResponseWithResult4(response) || isResponseWithError5(response);
var isValidResponse4 = (response) => Array.isArray(response) ? response.every(validateResponse4) : validateResponse4(response);
var isBatchResponse4 = (response) => Array.isArray(response) && response.length > 0 && isValidResponse4(response);
var requestIdSeed4;
var setRequestIdStart4 = (start) => {
  requestIdSeed4 = start;
};
var toPayload4 = (request) => {
  var _a16, _b, _c, _d;
  if (typeof requestIdSeed4 !== "undefined") {
    requestIdSeed4 += 1;
  }
  return {
    jsonrpc: (_a16 = request.jsonrpc) !== null && _a16 !== void 0 ? _a16 : "2.0",
    id: (_c = (_b = request.id) !== null && _b !== void 0 ? _b : requestIdSeed4) !== null && _c !== void 0 ? _c : uuidV44(),
    method: request.method,
    params: (_d = request.params) !== null && _d !== void 0 ? _d : void 0
  };
};
var toBatchPayload4 = (requests) => requests.map((request) => toPayload4(request));
var isBatchRequest4 = (request) => Array.isArray(request) && request.length > 0;

// node_modules/web3-net/node_modules/web3-utils/lib/esm/web3_deferred_promise.js
init_shim();
var __awaiter33 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a7;
var Web3DeferredPromise4 = class {
  constructor({ timeout, eagerStart, timeoutMessage } = {
    timeout: 0,
    eagerStart: false,
    timeoutMessage: "DeferredPromise timed out"
  }) {
    this[_a7] = "Promise";
    this._state = "pending";
    this._promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
    this._timeoutMessage = timeoutMessage;
    this._timeoutInterval = timeout;
    if (eagerStart) {
      this.startTimer();
    }
  }
  get state() {
    return this._state;
  }
  then(onfulfilled, onrejected) {
    return __awaiter33(this, void 0, void 0, function* () {
      return this._promise.then(onfulfilled, onrejected);
    });
  }
  catch(onrejected) {
    return __awaiter33(this, void 0, void 0, function* () {
      return this._promise.catch(onrejected);
    });
  }
  finally(onfinally) {
    return __awaiter33(this, void 0, void 0, function* () {
      return this._promise.finally(onfinally);
    });
  }
  resolve(value) {
    this._resolve(value);
    this._state = "fulfilled";
    this._clearTimeout();
  }
  reject(reason) {
    this._reject(reason);
    this._state = "rejected";
    this._clearTimeout();
  }
  startTimer() {
    if (this._timeoutInterval && this._timeoutInterval > 0) {
      this._timeoutId = setTimeout(this._checkTimeout.bind(this), this._timeoutInterval);
    }
  }
  _checkTimeout() {
    if (this._state === "pending" && this._timeoutId) {
      this.reject(new OperationTimeoutError(this._timeoutMessage));
    }
  }
  _clearTimeout() {
    if (this._timeoutId) {
      clearTimeout(this._timeoutId);
    }
  }
};
_a7 = Symbol.toStringTag;

// node_modules/web3-net/node_modules/web3-utils/lib/esm/chunk_response_parser.js
init_shim();
var ChunkResponseParser4 = class {
  constructor(eventEmitter, autoReconnect) {
    this.eventEmitter = eventEmitter;
    this.autoReconnect = autoReconnect;
  }
  clearQueues() {
    if (typeof this._clearQueues === "function") {
      this._clearQueues();
    }
  }
  onError(clearQueues) {
    this._clearQueues = clearQueues;
  }
  parseResponse(data) {
    const returnValues = [];
    const dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
    dechunkedData.forEach((_chunkData) => {
      let chunkData = _chunkData;
      if (this.lastChunk) {
        chunkData = this.lastChunk + chunkData;
      }
      let result;
      try {
        result = JSON.parse(chunkData);
      } catch (e) {
        this.lastChunk = chunkData;
        if (this.lastChunkTimeout) {
          clearTimeout(this.lastChunkTimeout);
        }
        this.lastChunkTimeout = setTimeout(() => {
          if (this.autoReconnect)
            return;
          this.clearQueues();
          this.eventEmitter.emit("error", new InvalidResponseError({
            id: 1,
            jsonrpc: "2.0",
            error: { code: 2, message: "Chunk timeout" }
          }));
        }, 1e3 * 15);
        return;
      }
      clearTimeout(this.lastChunkTimeout);
      this.lastChunk = void 0;
      if (result)
        returnValues.push(result);
    });
    return returnValues;
  }
};

// node_modules/web3-net/node_modules/web3-utils/lib/esm/web3_eip1193_provider.js
init_shim();
var import_events8 = __toESM(require_events(), 1);
var __awaiter34 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Eip1193Provider4 = class extends Web3BaseProvider {
  constructor() {
    super(...arguments);
    this._eventEmitter = new import_events8.EventEmitter();
    this._chainId = "";
    this._accounts = [];
  }
  _getChainId() {
    var _a16;
    return __awaiter34(this, void 0, void 0, function* () {
      const data = yield this.request(toPayload4({
        method: "eth_chainId",
        params: []
      }));
      return (_a16 = data === null || data === void 0 ? void 0 : data.result) !== null && _a16 !== void 0 ? _a16 : "";
    });
  }
  _getAccounts() {
    var _a16;
    return __awaiter34(this, void 0, void 0, function* () {
      const data = yield this.request(toPayload4({
        method: "eth_accounts",
        params: []
      }));
      return (_a16 = data === null || data === void 0 ? void 0 : data.result) !== null && _a16 !== void 0 ? _a16 : [];
    });
  }
  _onConnect() {
    Promise.all([
      this._getChainId().then((chainId) => {
        if (chainId !== this._chainId) {
          this._chainId = chainId;
          this._eventEmitter.emit("chainChanged", this._chainId);
        }
      }).catch((err) => {
        console.error(err);
      }),
      this._getAccounts().then((accounts) => {
        if (!(this._accounts.length === accounts.length && accounts.every((v) => accounts.includes(v)))) {
          this._accounts = accounts;
          this._onAccountsChanged();
        }
      }).catch((err) => {
        console.error(err);
      })
    ]).then(() => this._eventEmitter.emit("connect", {
      chainId: this._chainId
    })).catch((err) => {
      console.error(err);
    });
  }
  _onDisconnect(code, data) {
    this._eventEmitter.emit("disconnect", new EIP1193ProviderRpcError(code, data));
  }
  _onAccountsChanged() {
    this._eventEmitter.emit("accountsChanged", this._accounts);
  }
};

// node_modules/web3-net/node_modules/web3-utils/lib/esm/socket_provider.js
init_shim();
var __awaiter35 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_RECONNECTION_OPTIONS3 = {
  autoReconnect: true,
  delay: 5e3,
  maxAttempts: 5
};
var NORMAL_CLOSE_CODE3 = 1e3;
var SocketProvider3 = class extends Eip1193Provider4 {
  constructor(socketPath, socketOptions, reconnectOptions) {
    super();
    this._connectionStatus = "connecting";
    this._onMessageHandler = this._onMessage.bind(this);
    this._onOpenHandler = this._onConnect.bind(this);
    this._onCloseHandler = this._onCloseEvent.bind(this);
    this._onErrorHandler = this._onError.bind(this);
    if (!this._validateProviderPath(socketPath))
      throw new InvalidClientError(socketPath);
    this._socketPath = socketPath;
    this._socketOptions = socketOptions;
    this._reconnectOptions = Object.assign(Object.assign({}, DEFAULT_RECONNECTION_OPTIONS3), reconnectOptions !== null && reconnectOptions !== void 0 ? reconnectOptions : {});
    this._pendingRequestsQueue = /* @__PURE__ */ new Map();
    this._sentRequestsQueue = /* @__PURE__ */ new Map();
    this._init();
    this.connect();
    this.chunkResponseParser = new ChunkResponseParser4(this._eventEmitter, this._reconnectOptions.autoReconnect);
    this.chunkResponseParser.onError(() => {
      this._clearQueues();
    });
    this.isReconnecting = false;
  }
  get SocketConnection() {
    return this._socketConnection;
  }
  _init() {
    this._reconnectAttempts = 0;
  }
  connect() {
    try {
      this._openSocketConnection();
      this._connectionStatus = "connecting";
      this._addSocketListeners();
    } catch (e) {
      if (!this.isReconnecting) {
        this._connectionStatus = "disconnected";
        if (e && e.message) {
          throw new ConnectionError(`Error while connecting to ${this._socketPath}. Reason: ${e.message}`);
        } else {
          throw new InvalidClientError(this._socketPath);
        }
      } else {
        setImmediate(() => {
          this._reconnect();
        });
      }
    }
  }
  _validateProviderPath(path) {
    return !!path;
  }
  supportsSubscriptions() {
    return true;
  }
  on(type, listener) {
    this._eventEmitter.on(type, listener);
  }
  once(type, listener) {
    this._eventEmitter.once(type, listener);
  }
  removeListener(type, listener) {
    this._eventEmitter.removeListener(type, listener);
  }
  _onDisconnect(code, data) {
    this._connectionStatus = "disconnected";
    super._onDisconnect(code, data);
  }
  disconnect(code, data) {
    const disconnectCode = code !== null && code !== void 0 ? code : NORMAL_CLOSE_CODE3;
    this._removeSocketListeners();
    if (this.getStatus() !== "disconnected") {
      this._closeSocketConnection(disconnectCode, data);
    }
    this._onDisconnect(disconnectCode, data);
  }
  removeAllListeners(type) {
    this._eventEmitter.removeAllListeners(type);
  }
  _onError(event) {
    if (this.isReconnecting) {
      this._reconnect();
    } else {
      this._eventEmitter.emit("error", event);
    }
  }
  reset() {
    this._sentRequestsQueue.clear();
    this._pendingRequestsQueue.clear();
    this._init();
    this._removeSocketListeners();
    this._addSocketListeners();
  }
  _reconnect() {
    if (this.isReconnecting) {
      return;
    }
    this.isReconnecting = true;
    if (this._sentRequestsQueue.size > 0) {
      this._sentRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new PendingRequestsOnReconnectingError());
        this._sentRequestsQueue.delete(key);
      });
    }
    if (this._reconnectAttempts < this._reconnectOptions.maxAttempts) {
      this._reconnectAttempts += 1;
      setTimeout(() => {
        this._removeSocketListeners();
        this.connect();
        this.isReconnecting = false;
      }, this._reconnectOptions.delay);
    } else {
      this.isReconnecting = false;
      this._clearQueues();
      this._removeSocketListeners();
      this._eventEmitter.emit("error", new MaxAttemptsReachedOnReconnectingError(this._reconnectOptions.maxAttempts));
    }
  }
  request(request) {
    return __awaiter35(this, void 0, void 0, function* () {
      if (isNullish5(this._socketConnection)) {
        throw new Error("Connection is undefined");
      }
      if (this.getStatus() === "disconnected") {
        this.connect();
      }
      const requestId = isBatchRequest4(request) ? request[0].id : request.id;
      if (!requestId) {
        throw new Web3WSProviderError("Request Id not defined");
      }
      if (this._sentRequestsQueue.has(requestId)) {
        throw new RequestAlreadySentError(requestId);
      }
      const deferredPromise = new Web3DeferredPromise4();
      deferredPromise.catch((error) => {
        this._eventEmitter.emit("error", error);
      });
      const reqItem = {
        payload: request,
        deferredPromise
      };
      if (this.getStatus() === "connecting") {
        this._pendingRequestsQueue.set(requestId, reqItem);
        return reqItem.deferredPromise;
      }
      this._sentRequestsQueue.set(requestId, reqItem);
      try {
        this._sendToSocket(reqItem.payload);
      } catch (error) {
        this._sentRequestsQueue.delete(requestId);
        this._eventEmitter.emit("error", error);
      }
      return deferredPromise;
    });
  }
  _onConnect() {
    this._connectionStatus = "connected";
    this._reconnectAttempts = 0;
    super._onConnect();
    this._sendPendingRequests();
  }
  _sendPendingRequests() {
    for (const [id, value] of this._pendingRequestsQueue.entries()) {
      this._sendToSocket(value.payload);
      this._pendingRequestsQueue.delete(id);
      this._sentRequestsQueue.set(id, value);
    }
  }
  _onMessage(event) {
    const responses = this._parseResponses(event);
    if (isNullish5(responses) || responses.length === 0) {
      return;
    }
    for (const response of responses) {
      if (isResponseWithNotification4(response) && response.method.endsWith("_subscription")) {
        this._eventEmitter.emit("message", response);
        return;
      }
      const requestId = isBatchResponse4(response) ? response[0].id : response.id;
      const requestItem = this._sentRequestsQueue.get(requestId);
      if (!requestItem) {
        return;
      }
      if (isBatchResponse4(response) || isResponseWithResult4(response) || isResponseWithError5(response)) {
        this._eventEmitter.emit("message", response);
        requestItem.deferredPromise.resolve(response);
      }
      this._sentRequestsQueue.delete(requestId);
    }
  }
  _clearQueues(event) {
    if (this._pendingRequestsQueue.size > 0) {
      this._pendingRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new ConnectionNotOpenError(event));
        this._pendingRequestsQueue.delete(key);
      });
    }
    if (this._sentRequestsQueue.size > 0) {
      this._sentRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new ConnectionNotOpenError(event));
        this._sentRequestsQueue.delete(key);
      });
    }
    this._removeSocketListeners();
  }
};

// node_modules/web3-net/node_modules/web3-core/lib/esm/web3_event_emitter.js
init_shim();
var Web3EventEmitter3 = class {
  constructor() {
    this._emitter = new EventEmitter7();
  }
  on(eventName, fn) {
    this._emitter.on(eventName, fn);
  }
  once(eventName, fn) {
    this._emitter.once(eventName, fn);
  }
  off(eventName, fn) {
    this._emitter.off(eventName, fn);
  }
  emit(eventName, params) {
    this._emitter.emit(eventName, params);
  }
  listenerCount(eventName) {
    return this._emitter.listenerCount(eventName);
  }
  listeners(eventName) {
    return this._emitter.listeners(eventName);
  }
  eventNames() {
    return this._emitter.eventNames();
  }
  removeAllListeners() {
    return this._emitter.removeAllListeners();
  }
  setMaxListenerWarningThreshold(maxListenersWarningThreshold) {
    this._emitter.setMaxListeners(maxListenersWarningThreshold);
  }
  getMaxListeners() {
    return this._emitter.getMaxListeners();
  }
};

// node_modules/web3-net/node_modules/web3-core/lib/esm/web3_config.js
var Web3ConfigEvent3;
(function(Web3ConfigEvent7) {
  Web3ConfigEvent7["CONFIG_CHANGE"] = "CONFIG_CHANGE";
})(Web3ConfigEvent3 || (Web3ConfigEvent3 = {}));
var Web3Config3 = class extends Web3EventEmitter3 {
  constructor(options) {
    super();
    this.config = {
      handleRevert: false,
      defaultAccount: void 0,
      defaultBlock: "latest",
      transactionBlockTimeout: 50,
      transactionConfirmationBlocks: 24,
      transactionPollingInterval: 1e3,
      transactionPollingTimeout: 750 * 1e3,
      transactionReceiptPollingInterval: void 0,
      transactionSendTimeout: 750 * 1e3,
      transactionConfirmationPollingInterval: void 0,
      blockHeaderTimeout: 10,
      maxListenersWarningThreshold: 100,
      contractDataInputFill: "input",
      defaultNetworkId: void 0,
      defaultChain: "mainnet",
      defaultHardfork: "london",
      defaultCommon: void 0,
      defaultTransactionType: "0x2",
      defaultMaxPriorityFeePerGas: toHex4(25e8),
      enableExperimentalFeatures: {
        useSubscriptionWhenCheckingBlockTimeout: false,
        useRpcCallSpecification: false
      },
      transactionBuilder: void 0,
      transactionTypeParser: void 0
    };
    this.setConfig(options !== null && options !== void 0 ? options : {});
  }
  setConfig(options) {
    Object.assign(this.config, options);
  }
  get handleRevert() {
    return this.config.handleRevert;
  }
  set handleRevert(val) {
    this._triggerConfigChange("handleRevert", val);
    this.config.handleRevert = val;
  }
  get contractDataInputFill() {
    return this.config.contractDataInputFill;
  }
  set contractDataInputFill(val) {
    this._triggerConfigChange("contractDataInputFill", val);
    this.config.contractDataInputFill = val;
  }
  get defaultAccount() {
    return this.config.defaultAccount;
  }
  set defaultAccount(val) {
    this._triggerConfigChange("defaultAccount", val);
    this.config.defaultAccount = val;
  }
  get defaultBlock() {
    return this.config.defaultBlock;
  }
  set defaultBlock(val) {
    this._triggerConfigChange("defaultBlock", val);
    this.config.defaultBlock = val;
  }
  get transactionSendTimeout() {
    return this.config.transactionSendTimeout;
  }
  set transactionSendTimeout(val) {
    this._triggerConfigChange("transactionSendTimeout", val);
    this.config.transactionSendTimeout = val;
  }
  get transactionBlockTimeout() {
    return this.config.transactionBlockTimeout;
  }
  set transactionBlockTimeout(val) {
    this._triggerConfigChange("transactionBlockTimeout", val);
    this.config.transactionBlockTimeout = val;
  }
  get transactionConfirmationBlocks() {
    return this.config.transactionConfirmationBlocks;
  }
  set transactionConfirmationBlocks(val) {
    this._triggerConfigChange("transactionConfirmationBlocks", val);
    this.config.transactionConfirmationBlocks = val;
  }
  get transactionPollingInterval() {
    return this.config.transactionPollingInterval;
  }
  set transactionPollingInterval(val) {
    this._triggerConfigChange("transactionPollingInterval", val);
    this.config.transactionPollingInterval = val;
    this.transactionReceiptPollingInterval = val;
    this.transactionConfirmationPollingInterval = val;
  }
  get transactionPollingTimeout() {
    return this.config.transactionPollingTimeout;
  }
  set transactionPollingTimeout(val) {
    this._triggerConfigChange("transactionPollingTimeout", val);
    this.config.transactionPollingTimeout = val;
  }
  get transactionReceiptPollingInterval() {
    return this.config.transactionReceiptPollingInterval;
  }
  set transactionReceiptPollingInterval(val) {
    this._triggerConfigChange("transactionReceiptPollingInterval", val);
    this.config.transactionReceiptPollingInterval = val;
  }
  get transactionConfirmationPollingInterval() {
    return this.config.transactionConfirmationPollingInterval;
  }
  set transactionConfirmationPollingInterval(val) {
    this._triggerConfigChange("transactionConfirmationPollingInterval", val);
    this.config.transactionConfirmationPollingInterval = val;
  }
  get blockHeaderTimeout() {
    return this.config.blockHeaderTimeout;
  }
  set blockHeaderTimeout(val) {
    this._triggerConfigChange("blockHeaderTimeout", val);
    this.config.blockHeaderTimeout = val;
  }
  get enableExperimentalFeatures() {
    return this.config.enableExperimentalFeatures;
  }
  set enableExperimentalFeatures(val) {
    this._triggerConfigChange("enableExperimentalFeatures", val);
    this.config.enableExperimentalFeatures = val;
  }
  get maxListenersWarningThreshold() {
    return this.config.maxListenersWarningThreshold;
  }
  set maxListenersWarningThreshold(val) {
    this._triggerConfigChange("maxListenersWarningThreshold", val);
    this.setMaxListenerWarningThreshold(val);
    this.config.maxListenersWarningThreshold = val;
  }
  get defaultNetworkId() {
    return this.config.defaultNetworkId;
  }
  set defaultNetworkId(val) {
    this._triggerConfigChange("defaultNetworkId", val);
    this.config.defaultNetworkId = val;
  }
  get defaultChain() {
    return this.config.defaultChain;
  }
  set defaultChain(val) {
    if (!isNullish5(this.config.defaultCommon) && !isNullish5(this.config.defaultCommon.baseChain) && val !== this.config.defaultCommon.baseChain)
      throw new ConfigChainMismatchError(this.config.defaultChain, val);
    this._triggerConfigChange("defaultChain", val);
    this.config.defaultChain = val;
  }
  get defaultHardfork() {
    return this.config.defaultHardfork;
  }
  set defaultHardfork(val) {
    if (!isNullish5(this.config.defaultCommon) && !isNullish5(this.config.defaultCommon.hardfork) && val !== this.config.defaultCommon.hardfork)
      throw new ConfigHardforkMismatchError(this.config.defaultCommon.hardfork, val);
    this._triggerConfigChange("defaultHardfork", val);
    this.config.defaultHardfork = val;
  }
  get defaultCommon() {
    return this.config.defaultCommon;
  }
  set defaultCommon(val) {
    if (!isNullish5(this.config.defaultHardfork) && !isNullish5(val) && !isNullish5(val.hardfork) && this.config.defaultHardfork !== val.hardfork)
      throw new ConfigHardforkMismatchError(this.config.defaultHardfork, val.hardfork);
    if (!isNullish5(this.config.defaultChain) && !isNullish5(val) && !isNullish5(val.baseChain) && this.config.defaultChain !== val.baseChain)
      throw new ConfigChainMismatchError(this.config.defaultChain, val.baseChain);
    this._triggerConfigChange("defaultCommon", val);
    this.config.defaultCommon = val;
  }
  get defaultTransactionType() {
    return this.config.defaultTransactionType;
  }
  set defaultTransactionType(val) {
    this._triggerConfigChange("defaultTransactionType", val);
    this.config.defaultTransactionType = val;
  }
  get defaultMaxPriorityFeePerGas() {
    return this.config.defaultMaxPriorityFeePerGas;
  }
  set defaultMaxPriorityFeePerGas(val) {
    this._triggerConfigChange("defaultMaxPriorityFeePerGas", val);
    this.config.defaultMaxPriorityFeePerGas = val;
  }
  get transactionBuilder() {
    return this.config.transactionBuilder;
  }
  set transactionBuilder(val) {
    this._triggerConfigChange("transactionBuilder", val);
    this.config.transactionBuilder = val;
  }
  get transactionTypeParser() {
    return this.config.transactionTypeParser;
  }
  set transactionTypeParser(val) {
    this._triggerConfigChange("transactionTypeParser", val);
    this.config.transactionTypeParser = val;
  }
  _triggerConfigChange(config, newValue) {
    this.emit(Web3ConfigEvent3.CONFIG_CHANGE, {
      name: config,
      oldValue: this.config[config],
      newValue
    });
  }
};

// node_modules/web3-net/node_modules/web3-core/lib/esm/web3_request_manager.js
init_shim();

// node_modules/web3-net/node_modules/web3-providers-http/lib/esm/index.js
init_shim();
var import_cross_fetch3 = __toESM(require_browser_ponyfill3());
var __awaiter36 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var HttpProvider3 = class extends Web3BaseProvider {
  constructor(clientUrl, httpProviderOptions) {
    super();
    if (!HttpProvider3.validateClientUrl(clientUrl))
      throw new InvalidClientError(clientUrl);
    this.clientUrl = clientUrl;
    this.httpProviderOptions = httpProviderOptions;
  }
  static validateClientUrl(clientUrl) {
    return typeof clientUrl === "string" ? /^http(s)?:\/\//i.test(clientUrl) : false;
  }
  getStatus() {
    throw new MethodNotImplementedError();
  }
  supportsSubscriptions() {
    return false;
  }
  request(payload, requestOptions) {
    var _a16;
    return __awaiter36(this, void 0, void 0, function* () {
      const providerOptionsCombined = Object.assign(Object.assign({}, (_a16 = this.httpProviderOptions) === null || _a16 === void 0 ? void 0 : _a16.providerOptions), requestOptions);
      const response = yield (0, import_cross_fetch3.default)(this.clientUrl, Object.assign(Object.assign({}, providerOptionsCombined), { method: "POST", headers: Object.assign(Object.assign({}, providerOptionsCombined.headers), { "Content-Type": "application/json" }), body: JSON.stringify(payload) }));
      if (!response.ok)
        throw new ResponseError(yield response.json());
      return yield response.json();
    });
  }
  on() {
    throw new MethodNotImplementedError();
  }
  removeListener() {
    throw new MethodNotImplementedError();
  }
  once() {
    throw new MethodNotImplementedError();
  }
  removeAllListeners() {
    throw new MethodNotImplementedError();
  }
  connect() {
    throw new MethodNotImplementedError();
  }
  disconnect() {
    throw new MethodNotImplementedError();
  }
  reset() {
    throw new MethodNotImplementedError();
  }
  reconnect() {
    throw new MethodNotImplementedError();
  }
};

// node_modules/web3-net/node_modules/web3-providers-ws/lib/esm/index.js
init_shim();

// node_modules/web3-net/node_modules/isomorphic-ws/browser.js
init_shim();
var ws3 = null;
if (typeof WebSocket !== "undefined") {
  ws3 = WebSocket;
} else if (typeof MozWebSocket !== "undefined") {
  ws3 = MozWebSocket;
} else if (typeof _global !== "undefined") {
  ws3 = _global.WebSocket || _global.MozWebSocket;
} else if (typeof window !== "undefined") {
  ws3 = window.WebSocket || window.MozWebSocket;
} else if (typeof self !== "undefined") {
  ws3 = self.WebSocket || self.MozWebSocket;
}
var browser_default3 = ws3;

// node_modules/web3-net/node_modules/web3-providers-ws/lib/esm/index.js
var WebSocketProvider3 = class extends SocketProvider3 {
  constructor(socketPath, socketOptions, reconnectOptions) {
    super(socketPath, socketOptions, reconnectOptions);
  }
  _validateProviderPath(providerUrl) {
    return typeof providerUrl === "string" ? /^ws(s)?:\/\//i.test(providerUrl) : false;
  }
  getStatus() {
    if (this._socketConnection && !isNullish5(this._socketConnection)) {
      switch (this._socketConnection.readyState) {
        case this._socketConnection.CONNECTING: {
          return "connecting";
        }
        case this._socketConnection.OPEN: {
          return "connected";
        }
        default: {
          return "disconnected";
        }
      }
    }
    return "disconnected";
  }
  _openSocketConnection() {
    this._socketConnection = new browser_default3(this._socketPath, void 0, this._socketOptions && Object.keys(this._socketOptions).length === 0 ? void 0 : this._socketOptions);
  }
  _closeSocketConnection(code, data) {
    var _a16;
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.close(code, data);
  }
  _sendToSocket(payload) {
    var _a16;
    if (this.getStatus() === "disconnected") {
      throw new ConnectionNotOpenError();
    }
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.send(JSON.stringify(payload));
  }
  _parseResponses(event) {
    return this.chunkResponseParser.parseResponse(event.data);
  }
  _addSocketListeners() {
    var _a16, _b, _c, _d;
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.addEventListener("open", this._onOpenHandler);
    (_b = this._socketConnection) === null || _b === void 0 ? void 0 : _b.addEventListener("message", this._onMessageHandler);
    (_c = this._socketConnection) === null || _c === void 0 ? void 0 : _c.addEventListener("close", (e) => this._onCloseHandler(e));
    (_d = this._socketConnection) === null || _d === void 0 ? void 0 : _d.addEventListener("error", this._onErrorHandler);
  }
  _removeSocketListeners() {
    var _a16, _b, _c;
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.removeEventListener("message", this._onMessageHandler);
    (_b = this._socketConnection) === null || _b === void 0 ? void 0 : _b.removeEventListener("open", this._onOpenHandler);
    (_c = this._socketConnection) === null || _c === void 0 ? void 0 : _c.removeEventListener("close", this._onCloseHandler);
  }
  _onCloseEvent(event) {
    var _a16;
    if (this._reconnectOptions.autoReconnect && (![1e3, 1001].includes(event.code) || !event.wasClean)) {
      this._reconnect();
      return;
    }
    this._clearQueues(event);
    this._removeSocketListeners();
    this._onDisconnect(event.code, event.reason);
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.removeEventListener("error", this._onErrorHandler);
  }
};

// node_modules/web3-net/node_modules/web3-core/lib/esm/utils.js
init_shim();
var isWeb3Provider3 = (provider) => Web3BaseProvider.isWeb3Provider(provider);
var isMetaMaskProvider3 = (provider) => typeof provider !== "string" && "request" in provider && provider.request.constructor.name === "AsyncFunction" && "isMetaMask" in provider && provider.isMetaMask;
var isLegacyRequestProvider3 = (provider) => typeof provider !== "string" && "request" in provider && provider.request.constructor.name === "Function";
var isEIP1193Provider3 = (provider) => typeof provider !== "string" && "request" in provider && provider.request.constructor.name === "AsyncFunction";
var isLegacySendProvider3 = (provider) => typeof provider !== "string" && "send" in provider;
var isLegacySendAsyncProvider3 = (provider) => typeof provider !== "string" && "sendAsync" in provider;
var isSupportedProvider3 = (provider) => provider && (isWeb3Provider3(provider) || isEIP1193Provider3(provider) || isLegacyRequestProvider3(provider) || isLegacySendAsyncProvider3(provider) || isLegacySendProvider3(provider));
var isSupportSubscriptions3 = (provider) => {
  if (provider && "supportsSubscriptions" in provider) {
    return provider.supportsSubscriptions();
  }
  if (provider && typeof provider !== "string" && "on" in provider) {
    return true;
  }
  return false;
};

// node_modules/web3-net/node_modules/web3-core/lib/esm/web3_request_manager.js
var __awaiter37 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3RequestManagerEvent3;
(function(Web3RequestManagerEvent7) {
  Web3RequestManagerEvent7["PROVIDER_CHANGED"] = "PROVIDER_CHANGED";
  Web3RequestManagerEvent7["BEFORE_PROVIDER_CHANGE"] = "BEFORE_PROVIDER_CHANGE";
})(Web3RequestManagerEvent3 || (Web3RequestManagerEvent3 = {}));
var availableProviders3 = {
  HttpProvider: HttpProvider3,
  WebsocketProvider: WebSocketProvider3
};
var metamaskPayload3 = (payload) => {
  var _a16;
  if (Array.isArray(payload.params)) {
    const params = payload.params[0];
    if (params.input && !params.data) {
      return Object.assign(Object.assign({}, payload), { params: [Object.assign(Object.assign({}, params), { data: (_a16 = params.data) !== null && _a16 !== void 0 ? _a16 : params.input })] });
    }
  }
  return payload;
};
var Web3RequestManager3 = class extends Web3EventEmitter3 {
  constructor(provider, useRpcCallSpecification) {
    super();
    if (!isNullish5(provider)) {
      this.setProvider(provider);
    }
    this.useRpcCallSpecification = useRpcCallSpecification;
  }
  static get providers() {
    return availableProviders3;
  }
  get provider() {
    return this._provider;
  }
  get providers() {
    return availableProviders3;
  }
  setProvider(provider) {
    let newProvider;
    if (provider && typeof provider === "string" && this.providers) {
      if (/^http(s)?:\/\//i.test(provider)) {
        newProvider = new this.providers.HttpProvider(provider);
      } else if (/^ws(s)?:\/\//i.test(provider)) {
        newProvider = new this.providers.WebsocketProvider(provider);
      } else {
        throw new ProviderError(`Can't autodetect provider for "${provider}"`);
      }
    } else if (isNullish5(provider)) {
      newProvider = void 0;
    } else {
      newProvider = provider;
    }
    this.emit(Web3RequestManagerEvent3.BEFORE_PROVIDER_CHANGE, this._provider);
    this._provider = newProvider;
    this.emit(Web3RequestManagerEvent3.PROVIDER_CHANGED, this._provider);
    return true;
  }
  send(request) {
    return __awaiter37(this, void 0, void 0, function* () {
      const response = yield this._sendRequest(request);
      if (json_rpc_exports4.isResponseWithResult(response)) {
        return response.result;
      }
      throw new ResponseError(response);
    });
  }
  sendBatch(request) {
    return __awaiter37(this, void 0, void 0, function* () {
      const response = yield this._sendRequest(request);
      return response;
    });
  }
  _sendRequest(request) {
    return __awaiter37(this, void 0, void 0, function* () {
      const { provider } = this;
      if (isNullish5(provider)) {
        throw new ProviderError("Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.");
      }
      let payload = json_rpc_exports4.isBatchRequest(request) ? json_rpc_exports4.toBatchPayload(request) : json_rpc_exports4.toPayload(request);
      if (isMetaMaskProvider3(provider)) {
        if (payload.method === "eth_sendTransaction") {
          if (!json_rpc_exports4.isBatchRequest(payload)) {
            payload = metamaskPayload3(payload);
          } else {
            payload = payload.map((p) => metamaskPayload3(p));
          }
        }
      }
      if (isWeb3Provider3(provider)) {
        let response;
        try {
          response = yield provider.request(payload);
        } catch (error) {
          response = error;
        }
        return this._processJsonRpcResponse(payload, response, { legacy: false, error: false });
      }
      if (isEIP1193Provider3(provider)) {
        return provider.request(payload).then((res) => this._processJsonRpcResponse(payload, res, {
          legacy: true,
          error: false
        })).catch((error) => this._processJsonRpcResponse(payload, error, { legacy: true, error: true }));
      }
      if (isLegacyRequestProvider3(provider)) {
        return new Promise((resolve, reject) => {
          const rejectWithError = (err) => reject(this._processJsonRpcResponse(payload, err, {
            legacy: true,
            error: true
          }));
          const resolveWithResponse = (response) => resolve(this._processJsonRpcResponse(payload, response, {
            legacy: true,
            error: false
          }));
          const result = provider.request(
            payload,
            (err, response) => {
              if (err) {
                return rejectWithError(err);
              }
              return resolveWithResponse(response);
            }
          );
          if (isPromise3(result)) {
            const responsePromise = result;
            responsePromise.then(resolveWithResponse).catch(rejectWithError);
          }
        });
      }
      if (isLegacySendProvider3(provider)) {
        return new Promise((resolve, reject) => {
          provider.send(payload, (err, response) => {
            if (err) {
              return reject(this._processJsonRpcResponse(payload, err, {
                legacy: true,
                error: true
              }));
            }
            if (isNullish5(response)) {
              throw new ResponseError("", 'Got a "nullish" response from provider.');
            }
            return resolve(this._processJsonRpcResponse(payload, response, {
              legacy: true,
              error: false
            }));
          });
        });
      }
      if (isLegacySendAsyncProvider3(provider)) {
        return provider.sendAsync(payload).then((response) => this._processJsonRpcResponse(payload, response, { legacy: true, error: false })).catch((error) => this._processJsonRpcResponse(payload, error, {
          legacy: true,
          error: true
        }));
      }
      throw new ProviderError("Provider does not have a request or send method to use.");
    });
  }
  _processJsonRpcResponse(payload, response, { legacy, error }) {
    if (isNullish5(response)) {
      return this._buildResponse(
        payload,
        null,
        error
      );
    }
    if (json_rpc_exports4.isResponseWithError(response)) {
      if (this.useRpcCallSpecification && isResponseRpcError4(response)) {
        const rpcErrorResponse = response;
        if (rpcErrorsMap.get(rpcErrorResponse.error.code)) {
          const Err = rpcErrorsMap.get(rpcErrorResponse.error.code).error;
          throw new Err(rpcErrorResponse);
        } else {
          throw new RpcError(rpcErrorResponse);
        }
      } else if (!Web3RequestManager3._isReverted(response)) {
        throw new InvalidResponseError(response, payload);
      }
    }
    if (json_rpc_exports4.isResponseWithResult(response)) {
      return response;
    }
    if (response instanceof Error) {
      Web3RequestManager3._isReverted(response);
      throw response;
    }
    if (!legacy && json_rpc_exports4.isBatchRequest(payload) && json_rpc_exports4.isBatchResponse(response)) {
      return response;
    }
    if (legacy && !error && json_rpc_exports4.isBatchRequest(payload)) {
      return response;
    }
    if (legacy && error && json_rpc_exports4.isBatchRequest(payload)) {
      throw response;
    }
    if (legacy && !json_rpc_exports4.isResponseWithError(response) && !json_rpc_exports4.isResponseWithResult(response)) {
      return this._buildResponse(payload, response, error);
    }
    if (json_rpc_exports4.isBatchRequest(payload) && !Array.isArray(response)) {
      throw new ResponseError(response, "Got normal response for a batch request.");
    }
    if (!json_rpc_exports4.isBatchRequest(payload) && Array.isArray(response)) {
      throw new ResponseError(response, "Got batch response for a normal request.");
    }
    if ((json_rpc_exports4.isResponseWithError(response) || json_rpc_exports4.isResponseWithResult(response)) && !json_rpc_exports4.isBatchRequest(payload)) {
      if (response.id && payload.id !== response.id) {
        throw new InvalidResponseError(response);
      }
    }
    throw new ResponseError(response, "Invalid response");
  }
  static _isReverted(response) {
    let error;
    if (json_rpc_exports4.isResponseWithError(response)) {
      error = response.error;
    } else if (response instanceof Error) {
      error = response;
    }
    if (error === null || error === void 0 ? void 0 : error.message.includes("revert"))
      throw new ContractExecutionError(error);
    return false;
  }
  _buildResponse(payload, response, error) {
    const res = {
      jsonrpc: "2.0",
      id: json_rpc_exports4.isBatchRequest(payload) ? payload[0].id : "id" in payload ? payload.id : null
    };
    if (error) {
      return Object.assign(Object.assign({}, res), { error: response });
    }
    return Object.assign(Object.assign({}, res), { result: response });
  }
};

// node_modules/web3-net/node_modules/web3-core/lib/esm/web3_subscription_manager.js
init_shim();
var __awaiter38 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3SubscriptionManager3 = class {
  constructor(requestManager, registeredSubscriptions2, tolerateUnlinkedSubscription = false) {
    this.requestManager = requestManager;
    this.registeredSubscriptions = registeredSubscriptions2;
    this.tolerateUnlinkedSubscription = tolerateUnlinkedSubscription;
    this._subscriptions = /* @__PURE__ */ new Map();
    this.requestManager.on(Web3RequestManagerEvent3.BEFORE_PROVIDER_CHANGE, () => __awaiter38(this, void 0, void 0, function* () {
      yield this.unsubscribe();
    }));
    this.requestManager.on(Web3RequestManagerEvent3.PROVIDER_CHANGED, () => {
      this.clear();
      this.listenToProviderEvents();
    });
    this.listenToProviderEvents();
  }
  listenToProviderEvents() {
    const providerAsWebProvider = this.requestManager.provider;
    if (!this.requestManager.provider || typeof (providerAsWebProvider === null || providerAsWebProvider === void 0 ? void 0 : providerAsWebProvider.supportsSubscriptions) === "function" && !(providerAsWebProvider === null || providerAsWebProvider === void 0 ? void 0 : providerAsWebProvider.supportsSubscriptions())) {
      return;
    }
    if (typeof this.requestManager.provider.on === "function") {
      if (typeof this.requestManager.provider.request === "function") {
        this.requestManager.provider.on(
          "message",
          (message) => this.messageListener(message)
        );
      } else {
        providerAsWebProvider.on("data", (data) => this.messageListener(data));
      }
    }
  }
  messageListener(data) {
    var _a16, _b, _c;
    if (!data) {
      throw new SubscriptionError("Should not call messageListener with no data. Type was");
    }
    const subscriptionId = ((_a16 = data.params) === null || _a16 === void 0 ? void 0 : _a16.subscription) || ((_b = data.data) === null || _b === void 0 ? void 0 : _b.subscription) || ((_c = data.id) === null || _c === void 0 ? void 0 : _c.toString(16));
    if (subscriptionId) {
      const sub = this._subscriptions.get(subscriptionId);
      sub === null || sub === void 0 ? void 0 : sub.processSubscriptionData(data);
    }
  }
  subscribe(name2, args, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter38(this, void 0, void 0, function* () {
      const Klass = this.registeredSubscriptions[name2];
      if (!Klass) {
        throw new SubscriptionError("Invalid subscription type");
      }
      const subscription = new Klass(args !== null && args !== void 0 ? args : void 0, {
        subscriptionManager: this,
        returnFormat
      });
      yield this.addSubscription(subscription);
      return subscription;
    });
  }
  get subscriptions() {
    return this._subscriptions;
  }
  addSubscription(sub) {
    return __awaiter38(this, void 0, void 0, function* () {
      if (!this.requestManager.provider) {
        throw new ProviderError("Provider not available");
      }
      if (!this.supportsSubscriptions()) {
        throw new SubscriptionError("The current provider does not support subscriptions");
      }
      if (sub.id && this._subscriptions.has(sub.id)) {
        throw new SubscriptionError(`Subscription with id "${sub.id}" already exists`);
      }
      yield sub.sendSubscriptionRequest();
      if (isNullish5(sub.id)) {
        throw new SubscriptionError("Subscription is not subscribed yet.");
      }
      this._subscriptions.set(sub.id, sub);
      return sub.id;
    });
  }
  removeSubscription(sub) {
    return __awaiter38(this, void 0, void 0, function* () {
      const { id } = sub;
      if (isNullish5(id)) {
        throw new SubscriptionError("Subscription is not subscribed yet. Or, had already been unsubscribed but not through the Subscription Manager.");
      }
      if (!this._subscriptions.has(id) && !this.tolerateUnlinkedSubscription) {
        throw new SubscriptionError(`Subscription with id "${id.toString()}" does not exists`);
      }
      yield sub.sendUnsubscribeRequest();
      this._subscriptions.delete(id);
      return id;
    });
  }
  unsubscribe(condition) {
    return __awaiter38(this, void 0, void 0, function* () {
      const result = [];
      for (const [id, sub] of this.subscriptions.entries()) {
        if (!condition || typeof condition === "function" && condition({ id, sub })) {
          result.push(this.removeSubscription(sub));
        }
      }
      return Promise.all(result);
    });
  }
  clear() {
    this._subscriptions.clear();
  }
  supportsSubscriptions() {
    return isNullish5(this.requestManager.provider) ? false : isSupportSubscriptions3(this.requestManager.provider);
  }
};

// node_modules/web3-net/node_modules/web3-core/lib/esm/web3_subscriptions.js
init_shim();

// node_modules/web3-net/node_modules/web3-core/lib/esm/web3_context.js
init_shim();

// node_modules/web3-net/node_modules/web3-core/lib/esm/web3_batch_request.js
init_shim();
var __awaiter39 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_BATCH_REQUEST_TIMEOUT3 = 1e3;
var Web3BatchRequest3 = class {
  constructor(requestManager) {
    this._requestManager = requestManager;
    this._requests = /* @__PURE__ */ new Map();
  }
  get requests() {
    return [...this._requests.values()].map((r) => r.payload);
  }
  add(request) {
    const payload = json_rpc_exports4.toPayload(request);
    const promise = new Web3DeferredPromise4();
    this._requests.set(payload.id, { payload, promise });
    return promise;
  }
  execute(options) {
    var _a16;
    return __awaiter39(this, void 0, void 0, function* () {
      if (this.requests.length === 0) {
        return Promise.resolve([]);
      }
      const request = new Web3DeferredPromise4({
        timeout: (_a16 = options === null || options === void 0 ? void 0 : options.timeout) !== null && _a16 !== void 0 ? _a16 : DEFAULT_BATCH_REQUEST_TIMEOUT3,
        eagerStart: true,
        timeoutMessage: "Batch request timeout"
      });
      this._processBatchRequest(request).catch((err) => request.reject(err));
      request.catch((err) => {
        if (err instanceof OperationTimeoutError) {
          this._abortAllRequests("Batch request timeout");
        }
        request.reject(err);
      });
      return request;
    });
  }
  _processBatchRequest(promise) {
    var _a16, _b;
    return __awaiter39(this, void 0, void 0, function* () {
      const response = yield this._requestManager.sendBatch([...this._requests.values()].map((r) => r.payload));
      if (response.length !== this._requests.size) {
        this._abortAllRequests("Invalid batch response");
        throw new ResponseError(response, `Batch request size mismatch the results size. Requests: ${this._requests.size}, Responses: ${response.length}`);
      }
      const requestIds = this.requests.map((r) => r.id).map(Number).sort((a, b) => a - b);
      const responseIds = response.map((r) => r.id).map(Number).sort((a, b) => a - b);
      if (JSON.stringify(requestIds) !== JSON.stringify(responseIds)) {
        this._abortAllRequests("Invalid batch response");
        throw new ResponseError(response, `Batch request mismatch the results. Requests: [${requestIds.join()}], Responses: [${responseIds.join()}]`);
      }
      for (const res of response) {
        if (json_rpc_exports4.isResponseWithResult(res)) {
          (_a16 = this._requests.get(res.id)) === null || _a16 === void 0 ? void 0 : _a16.promise.resolve(res.result);
        } else if (json_rpc_exports4.isResponseWithError(res)) {
          (_b = this._requests.get(res.id)) === null || _b === void 0 ? void 0 : _b.promise.reject(res.error);
        }
      }
      promise.resolve(response);
    });
  }
  _abortAllRequests(msg) {
    for (const { promise } of this._requests.values()) {
      promise.reject(new OperationAbortError(msg));
    }
  }
};

// node_modules/web3-net/node_modules/web3-core/lib/esm/web3_context.js
var __awaiter40 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3Context3 = class extends Web3Config3 {
  constructor(providerOrContext) {
    var _a16;
    super();
    this.providers = Web3RequestManager3.providers;
    if (isNullish5(providerOrContext) || typeof providerOrContext === "string" && providerOrContext.trim() !== "" || isSupportedProvider3(providerOrContext)) {
      this._requestManager = new Web3RequestManager3(providerOrContext);
      this._subscriptionManager = new Web3SubscriptionManager3(this._requestManager, {});
      return;
    }
    const { config, provider, requestManager, subscriptionManager, registeredSubscriptions: registeredSubscriptions2, accountProvider, wallet } = providerOrContext;
    this.setConfig(config !== null && config !== void 0 ? config : {});
    this._requestManager = requestManager !== null && requestManager !== void 0 ? requestManager : new Web3RequestManager3(provider, (_a16 = config === null || config === void 0 ? void 0 : config.enableExperimentalFeatures) === null || _a16 === void 0 ? void 0 : _a16.useSubscriptionWhenCheckingBlockTimeout);
    if (subscriptionManager) {
      this._subscriptionManager = subscriptionManager;
    } else {
      this._subscriptionManager = new Web3SubscriptionManager3(this.requestManager, registeredSubscriptions2 !== null && registeredSubscriptions2 !== void 0 ? registeredSubscriptions2 : {});
    }
    if (accountProvider) {
      this._accountProvider = accountProvider;
    }
    if (wallet) {
      this._wallet = wallet;
    }
  }
  get requestManager() {
    return this._requestManager;
  }
  get subscriptionManager() {
    return this._subscriptionManager;
  }
  get wallet() {
    return this._wallet;
  }
  get accountProvider() {
    return this._accountProvider;
  }
  static fromContextObject(...args) {
    return new this(...args.reverse());
  }
  getContextObject() {
    var _a16;
    return {
      config: this.config,
      provider: this.provider,
      requestManager: this.requestManager,
      subscriptionManager: this.subscriptionManager,
      registeredSubscriptions: (_a16 = this.subscriptionManager) === null || _a16 === void 0 ? void 0 : _a16.registeredSubscriptions,
      providers: this.providers,
      wallet: this.wallet,
      accountProvider: this.accountProvider
    };
  }
  use(ContextRef, ...args) {
    const newContextChild = new ContextRef(...[...args, this.getContextObject()]);
    this.on(Web3ConfigEvent3.CONFIG_CHANGE, (event) => {
      newContextChild.setConfig({ [event.name]: event.newValue });
    });
    return newContextChild;
  }
  link(parentContext) {
    this.setConfig(parentContext.config);
    this._requestManager = parentContext.requestManager;
    this.provider = parentContext.provider;
    this._subscriptionManager = parentContext.subscriptionManager;
    this._wallet = parentContext.wallet;
    this._accountProvider = parentContext._accountProvider;
    parentContext.on(Web3ConfigEvent3.CONFIG_CHANGE, (event) => {
      this.setConfig({ [event.name]: event.newValue });
    });
  }
  registerPlugin(plugin) {
    if (this[plugin.pluginNamespace] !== void 0)
      throw new ExistingPluginNamespaceError(plugin.pluginNamespace);
    const _pluginObject = {
      [plugin.pluginNamespace]: plugin
    };
    _pluginObject[plugin.pluginNamespace].link(this);
    Object.assign(this, _pluginObject);
  }
  get provider() {
    return this.currentProvider;
  }
  set provider(provider) {
    this.requestManager.setProvider(provider);
  }
  get currentProvider() {
    return this.requestManager.provider;
  }
  set currentProvider(provider) {
    this.requestManager.setProvider(provider);
  }
  get givenProvider() {
    return Web3Context3.givenProvider;
  }
  setProvider(provider) {
    this.provider = provider;
    return true;
  }
  get BatchRequest() {
    return Web3BatchRequest3.bind(void 0, this._requestManager);
  }
  extend(extendObj) {
    var _a16;
    if (extendObj.property && !this[extendObj.property])
      this[extendObj.property] = {};
    (_a16 = extendObj.methods) === null || _a16 === void 0 ? void 0 : _a16.forEach((element) => {
      const method = (...givenParams) => __awaiter40(this, void 0, void 0, function* () {
        return this.requestManager.send({
          method: element.call,
          params: givenParams
        });
      });
      if (extendObj.property)
        this[extendObj.property][element.name] = method;
      else
        this[element.name] = method;
    });
    return this;
  }
};
Web3Context3.providers = Web3RequestManager3.providers;

// node_modules/web3-net/node_modules/web3-core/lib/esm/types.js
init_shim();

// node_modules/web3-net/node_modules/web3-core/lib/esm/formatters.js
var formatters_exports3 = {};
__export(formatters_exports3, {
  inputAddressFormatter: () => inputAddressFormatter3,
  inputBlockNumberFormatter: () => inputBlockNumberFormatter3,
  inputCallFormatter: () => inputCallFormatter3,
  inputDefaultBlockNumberFormatter: () => inputDefaultBlockNumberFormatter3,
  inputLogFormatter: () => inputLogFormatter3,
  inputPostFormatter: () => inputPostFormatter3,
  inputSignFormatter: () => inputSignFormatter3,
  inputStorageKeysFormatter: () => inputStorageKeysFormatter3,
  inputTopicFormatter: () => inputTopicFormatter3,
  inputTransactionFormatter: () => inputTransactionFormatter3,
  outputBigIntegerFormatter: () => outputBigIntegerFormatter3,
  outputBlockFormatter: () => outputBlockFormatter3,
  outputLogFormatter: () => outputLogFormatter3,
  outputPostFormatter: () => outputPostFormatter3,
  outputProofFormatter: () => outputProofFormatter3,
  outputSyncingFormatter: () => outputSyncingFormatter3,
  outputTransactionFormatter: () => outputTransactionFormatter3,
  outputTransactionReceiptFormatter: () => outputTransactionReceiptFormatter3,
  txInputOptionsFormatter: () => txInputOptionsFormatter3
});
init_shim();

// node_modules/web3-net/node_modules/web3-eth-iban/lib/esm/index.js
init_shim();

// node_modules/web3-net/node_modules/web3-eth-iban/lib/esm/iban.js
init_shim();
var Iban3 = class {
  constructor(iban) {
    this.toAddress = () => {
      if (this.isDirect()) {
        const base36 = this._iban.slice(4);
        const parsedBigInt = Iban3._parseInt(base36, 36);
        const paddedBigInt = leftPad4(parsedBigInt, 40);
        return toChecksumAddress4(paddedBigInt);
      }
      throw new Error("Iban is indirect and cannot be converted. Must be length of 34 or 35");
    };
    if (Iban3.isIndirect(iban) || Iban3.isDirect(iban)) {
      this._iban = iban;
    } else {
      throw new Error("Invalid IBAN was provided");
    }
  }
  static isDirect(iban) {
    return iban.length === 34 || iban.length === 35;
  }
  isDirect() {
    return Iban3.isDirect(this._iban);
  }
  static isIndirect(iban) {
    return iban.length === 20;
  }
  isIndirect() {
    return Iban3.isIndirect(this._iban);
  }
  static isValid(iban) {
    return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(iban) && Iban3._mod9710(Iban3._iso13616Prepare(iban)) === 1;
  }
  isValid() {
    return Iban3.isValid(this._iban);
  }
  static fromBban(bban) {
    const countryCode = "XE";
    const remainder = this._mod9710(this._iso13616Prepare(`${countryCode}00${bban}`));
    const checkDigit = `0${(98 - remainder).toString()}`.slice(-2);
    return new Iban3(`${countryCode}${checkDigit}${bban}`);
  }
  static createIndirect(options) {
    return Iban3.fromBban(`ETH${options.institution}${options.identifier}`);
  }
  static fromAddress(address) {
    if (!isAddress(address)) {
      throw new InvalidAddressError(address);
    }
    const num = BigInt(hexToNumber4(address));
    const base36 = num.toString(36);
    const padded = leftPad4(base36, 15);
    return Iban3.fromBban(padded.toUpperCase());
  }
  static toIban(address) {
    return Iban3.fromAddress(address).toString();
  }
  client() {
    return this.isIndirect() ? this._iban.slice(11) : "";
  }
  checksum() {
    return this._iban.slice(2, 4);
  }
  institution() {
    return this.isIndirect() ? this._iban.slice(7, 11) : "";
  }
  toString() {
    return this._iban;
  }
};
Iban3._iso13616Prepare = (iban) => {
  const A = "A".charCodeAt(0);
  const Z = "Z".charCodeAt(0);
  const upperIban = iban.toUpperCase();
  const modifiedIban = `${upperIban.slice(4)}${upperIban.slice(0, 4)}`;
  return modifiedIban.split("").map((n) => {
    const code = n.charCodeAt(0);
    if (code >= A && code <= Z) {
      return code - A + 10;
    }
    return n;
  }).join("");
};
Iban3._parseInt = (str, base2) => [...str].reduce((acc, curr) => BigInt(parseInt(curr, base2)) + BigInt(base2) * acc, BigInt(0));
Iban3._mod9710 = (iban) => {
  let remainder = iban;
  let block;
  while (remainder.length > 2) {
    block = remainder.slice(0, 9);
    remainder = `${(parseInt(block, 10) % 97).toString()}${remainder.slice(block.length)}`;
  }
  return parseInt(remainder, 10) % 97;
};
Iban3.toAddress = (iban) => {
  const ibanObject = new Iban3(iban);
  return ibanObject.toAddress();
};

// node_modules/web3-net/node_modules/web3-eth-iban/lib/esm/types.js
init_shim();

// node_modules/web3-net/node_modules/web3-core/lib/esm/formatters.js
var inputStorageKeysFormatter3 = (keys) => keys.map((num) => numberToHex5(num));
var outputProofFormatter3 = (proof) => ({
  address: toChecksumAddress4(proof.address),
  nonce: hexToNumberString3(proof.nonce),
  balance: hexToNumberString3(proof.balance)
});
var outputBigIntegerFormatter3 = (number) => toNumber4(number);
var inputBlockNumberFormatter3 = (blockNumber) => {
  if (isNullish(blockNumber)) {
    return void 0;
  }
  if (typeof blockNumber === "string" && isBlockTag(blockNumber)) {
    return blockNumber;
  }
  if (blockNumber === "genesis") {
    return "0x0";
  }
  if (typeof blockNumber === "string" && isHexStrict4(blockNumber)) {
    return blockNumber.toLowerCase();
  }
  return numberToHex5(blockNumber);
};
var inputDefaultBlockNumberFormatter3 = (blockNumber, defaultBlock) => {
  if (!blockNumber) {
    return inputBlockNumberFormatter3(defaultBlock);
  }
  return inputBlockNumberFormatter3(blockNumber);
};
var inputAddressFormatter3 = (address) => {
  if (Iban3.isValid(address) && Iban3.isDirect(address)) {
    const iban = new Iban3(address);
    return iban.toAddress().toLowerCase();
  }
  if (isAddress4(address)) {
    return `0x${address.toLowerCase().replace("0x", "")}`;
  }
  throw new FormatterError(`Provided address ${address} is invalid, the capitalization checksum test failed, or it's an indirect IBAN address which can't be converted.`);
};
var txInputOptionsFormatter3 = (options) => {
  var _a16;
  const modifiedOptions = Object.assign({}, options);
  if (options.to) {
    modifiedOptions.to = inputAddressFormatter3(options.to);
  }
  if (options.data && options.input) {
    throw new FormatterError(`You can't have "data" and "input" as properties of transactions at the same time, please use either "data" or "input" instead.`);
  }
  if (!options.input && options.data) {
    modifiedOptions.input = options.data;
    delete modifiedOptions.data;
  }
  if (options.input && !options.input.startsWith("0x")) {
    modifiedOptions.input = `0x${options.input}`;
  }
  if (modifiedOptions.input && !isHexStrict4(modifiedOptions.input)) {
    throw new FormatterError("The input field must be HEX encoded data.");
  }
  if (options.gas || options.gasLimit) {
    modifiedOptions.gas = toNumber4((_a16 = options.gas) !== null && _a16 !== void 0 ? _a16 : options.gasLimit);
  }
  if (options.maxPriorityFeePerGas || options.maxFeePerGas) {
    delete modifiedOptions.gasPrice;
  }
  ["gasPrice", "gas", "value", "maxPriorityFeePerGas", "maxFeePerGas", "nonce", "chainId"].filter((key) => !isNullish(modifiedOptions[key])).forEach((key) => {
    modifiedOptions[key] = numberToHex5(modifiedOptions[key]);
  });
  return modifiedOptions;
};
var inputCallFormatter3 = (options, defaultAccount) => {
  var _a16;
  const opts = txInputOptionsFormatter3(options);
  const from = (_a16 = opts.from) !== null && _a16 !== void 0 ? _a16 : defaultAccount;
  if (from) {
    opts.from = inputAddressFormatter3(from);
  }
  return opts;
};
var inputTransactionFormatter3 = (options, defaultAccount) => {
  var _a16;
  const opts = txInputOptionsFormatter3(options);
  if (!(typeof opts.from === "number") && !(!!opts.from && typeof opts.from === "object")) {
    opts.from = (_a16 = opts.from) !== null && _a16 !== void 0 ? _a16 : defaultAccount;
    if (!options.from && !(typeof options.from === "number")) {
      throw new FormatterError('The send transactions "from" field must be defined!');
    }
    opts.from = inputAddressFormatter3(options.from);
  }
  return opts;
};
var inputSignFormatter3 = (data) => isHexStrict4(data) ? data : utf8ToHex4(data);
var outputTransactionFormatter3 = (tx) => {
  const modifiedTx = Object.assign({}, tx);
  if (tx.blockNumber) {
    modifiedTx.blockNumber = hexToNumber4(tx.blockNumber);
  }
  if (tx.transactionIndex) {
    modifiedTx.transactionIndex = hexToNumber4(tx.transactionIndex);
  }
  modifiedTx.nonce = hexToNumber4(tx.nonce);
  modifiedTx.gas = hexToNumber4(tx.gas);
  if (tx.gasPrice) {
    modifiedTx.gasPrice = outputBigIntegerFormatter3(tx.gasPrice);
  }
  if (tx.maxFeePerGas) {
    modifiedTx.maxFeePerGas = outputBigIntegerFormatter3(tx.maxFeePerGas);
  }
  if (tx.maxPriorityFeePerGas) {
    modifiedTx.maxPriorityFeePerGas = outputBigIntegerFormatter3(tx.maxPriorityFeePerGas);
  }
  if (tx.type) {
    modifiedTx.type = hexToNumber4(tx.type);
  }
  modifiedTx.value = outputBigIntegerFormatter3(tx.value);
  if (tx.to && isAddress4(tx.to)) {
    modifiedTx.to = toChecksumAddress4(tx.to);
  } else {
    modifiedTx.to = void 0;
  }
  if (tx.from) {
    modifiedTx.from = toChecksumAddress4(tx.from);
  }
  return modifiedTx;
};
var inputTopicFormatter3 = (topic) => {
  if (isNullish(topic))
    return null;
  const value = String(topic);
  return isHex(value) ? value : fromUtf84(value);
};
var inputLogFormatter3 = (filter) => {
  var _a16;
  const val = isNullish(filter) ? {} : mergeDeep4({}, filter);
  if (isNullish(val.fromBlock)) {
    val.fromBlock = BlockTags.LATEST;
  }
  val.fromBlock = inputBlockNumberFormatter3(val.fromBlock);
  if (!isNullish(val.toBlock)) {
    val.toBlock = inputBlockNumberFormatter3(val.toBlock);
  }
  val.topics = (_a16 = val.topics) !== null && _a16 !== void 0 ? _a16 : [];
  val.topics = val.topics.map((topic) => Array.isArray(topic) ? topic.map(inputTopicFormatter3) : inputTopicFormatter3(topic));
  if (val.address) {
    val.address = Array.isArray(val.address) ? val.address.map((addr) => inputAddressFormatter3(addr)) : inputAddressFormatter3(val.address);
  }
  return val;
};
var outputLogFormatter3 = (log) => {
  const modifiedLog = Object.assign({}, log);
  const logIndex = typeof log.logIndex === "string" ? log.logIndex : numberToHex5(log.logIndex);
  if (typeof log.blockHash === "string" && typeof log.transactionHash === "string") {
    const shaId = sha3Raw4(`${log.blockHash.replace("0x", "")}${log.transactionHash.replace("0x", "")}${logIndex.replace("0x", "")}`);
    modifiedLog.id = `log_${shaId.replace("0x", "").slice(0, 8)}`;
  } else if (!log.id) {
    modifiedLog.id = void 0;
  }
  if (log.blockNumber && isHexStrict4(log.blockNumber)) {
    modifiedLog.blockNumber = hexToNumber4(log.blockNumber);
  }
  if (log.transactionIndex && isHexStrict4(log.transactionIndex)) {
    modifiedLog.transactionIndex = hexToNumber4(log.transactionIndex);
  }
  if (log.logIndex && isHexStrict4(log.logIndex)) {
    modifiedLog.logIndex = hexToNumber4(log.logIndex);
  }
  if (log.address) {
    modifiedLog.address = toChecksumAddress4(log.address);
  }
  return modifiedLog;
};
var outputTransactionReceiptFormatter3 = (receipt) => {
  if (typeof receipt !== "object") {
    throw new FormatterError(`Received receipt is invalid: ${String(receipt)}`);
  }
  const modifiedReceipt = Object.assign({}, receipt);
  if (receipt.blockNumber) {
    modifiedReceipt.blockNumber = hexToNumber4(receipt.blockNumber);
  }
  if (receipt.transactionIndex) {
    modifiedReceipt.transactionIndex = hexToNumber4(receipt.transactionIndex);
  }
  modifiedReceipt.cumulativeGasUsed = hexToNumber4(receipt.cumulativeGasUsed);
  modifiedReceipt.gasUsed = hexToNumber4(receipt.gasUsed);
  if (receipt.logs && Array.isArray(receipt.logs)) {
    modifiedReceipt.logs = receipt.logs.map(outputLogFormatter3);
  }
  if (receipt.effectiveGasPrice) {
    modifiedReceipt.effectiveGasPrice = hexToNumber4(receipt.effectiveGasPrice);
  }
  if (receipt.contractAddress) {
    modifiedReceipt.contractAddress = toChecksumAddress4(receipt.contractAddress);
  }
  if (receipt.status) {
    modifiedReceipt.status = Boolean(parseInt(receipt.status, 10));
  }
  return modifiedReceipt;
};
var outputBlockFormatter3 = (block) => {
  const modifiedBlock = Object.assign({}, block);
  modifiedBlock.gasLimit = hexToNumber4(block.gasLimit);
  modifiedBlock.gasUsed = hexToNumber4(block.gasUsed);
  modifiedBlock.size = hexToNumber4(block.size);
  modifiedBlock.timestamp = hexToNumber4(block.timestamp);
  if (block.number) {
    modifiedBlock.number = hexToNumber4(block.number);
  }
  if (block.difficulty) {
    modifiedBlock.difficulty = outputBigIntegerFormatter3(block.difficulty);
  }
  if (block.totalDifficulty) {
    modifiedBlock.totalDifficulty = outputBigIntegerFormatter3(block.totalDifficulty);
  }
  if (block.transactions && Array.isArray(block.transactions)) {
    modifiedBlock.transactions = block.transactions.map(outputTransactionFormatter3);
  }
  if (block.miner) {
    modifiedBlock.miner = toChecksumAddress4(block.miner);
  }
  if (block.baseFeePerGas) {
    modifiedBlock.baseFeePerGas = outputBigIntegerFormatter3(block.baseFeePerGas);
  }
  return modifiedBlock;
};
var inputPostFormatter3 = (post) => {
  var _a16;
  const modifiedPost = Object.assign({}, post);
  if (post.ttl) {
    modifiedPost.ttl = numberToHex5(post.ttl);
  }
  if (post.workToProve) {
    modifiedPost.workToProve = numberToHex5(post.workToProve);
  }
  if (post.priority) {
    modifiedPost.priority = numberToHex5(post.priority);
  }
  if (post.topics && !Array.isArray(post.topics)) {
    modifiedPost.topics = post.topics ? [post.topics] : [];
  }
  modifiedPost.topics = (_a16 = modifiedPost.topics) === null || _a16 === void 0 ? void 0 : _a16.map((topic) => topic.startsWith("0x") ? topic : fromUtf84(topic));
  return modifiedPost;
};
var outputPostFormatter3 = (post) => {
  var _a16;
  const modifiedPost = Object.assign({}, post);
  if (post.expiry) {
    modifiedPost.expiry = hexToNumber4(post.expiry);
  }
  if (post.sent) {
    modifiedPost.sent = hexToNumber4(post.sent);
  }
  if (post.ttl) {
    modifiedPost.ttl = hexToNumber4(post.ttl);
  }
  if (post.workProved) {
    modifiedPost.workProved = hexToNumber4(post.workProved);
  }
  if (!post.topics) {
    modifiedPost.topics = [];
  }
  modifiedPost.topics = (_a16 = modifiedPost.topics) === null || _a16 === void 0 ? void 0 : _a16.map(toUtf83);
  return modifiedPost;
};
var outputSyncingFormatter3 = (result) => {
  const modifiedResult = Object.assign({}, result);
  modifiedResult.startingBlock = hexToNumber4(result.startingBlock);
  modifiedResult.currentBlock = hexToNumber4(result.currentBlock);
  modifiedResult.highestBlock = hexToNumber4(result.highestBlock);
  if (result.knownStates) {
    modifiedResult.knownStates = hexToNumber4(result.knownStates);
  }
  if (result.pulledStates) {
    modifiedResult.pulledStates = hexToNumber4(result.pulledStates);
  }
  return modifiedResult;
};

// node_modules/web3-net/node_modules/web3-core/lib/esm/web3_promi_event.js
init_shim();
var _a8;
_a8 = Symbol.toStringTag;

// node_modules/web3-net/lib/esm/rpc_method_wrappers.js
init_shim();
var __awaiter41 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getId2(web3Context, returnFormat) {
  return __awaiter41(this, void 0, void 0, function* () {
    const response = yield net_rpc_methods_exports.getId(web3Context.requestManager);
    return format3({ format: "uint" }, response, returnFormat);
  });
}
function getPeerCount2(web3Context, returnFormat) {
  return __awaiter41(this, void 0, void 0, function* () {
    const response = yield net_rpc_methods_exports.getPeerCount(web3Context.requestManager);
    return format3({ format: "uint" }, response, returnFormat);
  });
}
var isListening2 = (web3Context) => __awaiter41(void 0, void 0, void 0, function* () {
  return net_rpc_methods_exports.isListening(web3Context.requestManager);
});

// node_modules/web3-net/lib/esm/net.js
var __awaiter42 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Net = class extends Web3Context3 {
  getId(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter42(this, void 0, void 0, function* () {
      return getId2(this, returnFormat);
    });
  }
  getPeerCount(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter42(this, void 0, void 0, function* () {
      return getPeerCount2(this, returnFormat);
    });
  }
  isListening() {
    return __awaiter42(this, void 0, void 0, function* () {
      return isListening2(this);
    });
  }
};

// node_modules/web3-net/lib/esm/index.js
var esm_default2 = Net;

// node_modules/web3-eth/lib/esm/constants.js
init_shim();
var ALL_EVENTS = "ALLEVENTS";
var ALL_EVENTS_ABI = {
  name: ALL_EVENTS,
  signature: "",
  type: "event",
  inputs: []
};
var NUMBER_DATA_FORMAT = { bytes: FMT_BYTES.HEX, number: FMT_NUMBER.NUMBER };

// node_modules/web3-eth/lib/esm/utils/get_transaction_gas_pricing.js
init_shim();
var __awaiter43 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getEip1559GasPricing(transaction, web3Context, returnFormat) {
  var _a16, _b, _c;
  return __awaiter43(this, void 0, void 0, function* () {
    const block = yield getBlock(web3Context, web3Context.defaultBlock, false, returnFormat);
    if (isNullish(block.baseFeePerGas))
      throw new Eip1559NotSupportedError();
    if (!isNullish(transaction.gasPrice)) {
      const convertedTransactionGasPrice = format2({ format: "uint" }, transaction.gasPrice, returnFormat);
      return {
        maxPriorityFeePerGas: convertedTransactionGasPrice,
        maxFeePerGas: convertedTransactionGasPrice
      };
    }
    return {
      maxPriorityFeePerGas: format2({ format: "uint" }, (_a16 = transaction.maxPriorityFeePerGas) !== null && _a16 !== void 0 ? _a16 : web3Context.defaultMaxPriorityFeePerGas, returnFormat),
      maxFeePerGas: format2({ format: "uint" }, (_b = transaction.maxFeePerGas) !== null && _b !== void 0 ? _b : BigInt(block.baseFeePerGas) * BigInt(2) + BigInt((_c = transaction.maxPriorityFeePerGas) !== null && _c !== void 0 ? _c : web3Context.defaultMaxPriorityFeePerGas), returnFormat)
    };
  });
}
function getTransactionGasPricing(transaction, web3Context, returnFormat) {
  return __awaiter43(this, void 0, void 0, function* () {
    const transactionType = getTransactionType(transaction, web3Context);
    if (!isNullish(transactionType)) {
      if (transactionType.startsWith("-"))
        throw new UnsupportedTransactionTypeError(transactionType);
      if (Number(transactionType) < 0 || Number(transactionType) > 127)
        throw new UnsupportedTransactionTypeError(transactionType);
      if (isNullish(transaction.gasPrice) && (transactionType === "0x0" || transactionType === "0x1"))
        return {
          gasPrice: yield getGasPrice2(web3Context, returnFormat),
          maxPriorityFeePerGas: void 0,
          maxFeePerGas: void 0
        };
      if (transactionType === "0x2") {
        return Object.assign({ gasPrice: void 0 }, yield getEip1559GasPricing(transaction, web3Context, returnFormat));
      }
    }
    return void 0;
  });
}

// node_modules/web3-eth/lib/esm/utils/transaction_builder.js
var __awaiter44 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getTransactionFromOrToAttr = (attr, web3Context, transaction, privateKey) => {
  if (transaction !== void 0 && attr in transaction && transaction[attr] !== void 0) {
    if (typeof transaction[attr] === "string" && isAddress(transaction[attr])) {
      return transaction[attr];
    }
    if (!isHexStrict(transaction[attr]) && isNumber(transaction[attr])) {
      if (web3Context.wallet) {
        const account = web3Context.wallet.get(format2({ format: "uint" }, transaction[attr], NUMBER_DATA_FORMAT));
        if (!isNullish(account)) {
          return account.address;
        }
        throw new LocalWalletNotAvailableError();
      }
      throw new LocalWalletNotAvailableError();
    } else {
      throw attr === "from" ? new InvalidTransactionWithSender(transaction.from) : new InvalidTransactionWithReceiver(transaction.to);
    }
  }
  if (attr === "from") {
    if (!isNullish(privateKey))
      return privateKeyToAddress(privateKey);
    if (!isNullish(web3Context.defaultAccount))
      return web3Context.defaultAccount;
  }
  return void 0;
};
var getTransactionNonce = (web3Context, address, returnFormat = DEFAULT_RETURN_FORMAT) => __awaiter44(void 0, void 0, void 0, function* () {
  if (isNullish(address)) {
    throw new UnableToPopulateNonceError();
  }
  return getTransactionCount2(web3Context, address, web3Context.defaultBlock, returnFormat);
});
var getTransactionType = (transaction, web3Context) => {
  const inferredType = detectTransactionType(transaction, web3Context);
  if (!isNullish(inferredType))
    return inferredType;
  if (!isNullish(web3Context.defaultTransactionType))
    return format2({ format: "uint" }, web3Context.defaultTransactionType, ETH_DATA_FORMAT);
  return void 0;
};
function defaultTransactionBuilder(options) {
  var _a16, _b;
  return __awaiter44(this, void 0, void 0, function* () {
    let populatedTransaction = format2(transactionSchema, options.transaction, DEFAULT_RETURN_FORMAT);
    if (isNullish(populatedTransaction.from)) {
      populatedTransaction.from = getTransactionFromOrToAttr("from", options.web3Context, void 0, options.privateKey);
    }
    if (isNullish(populatedTransaction.nonce)) {
      populatedTransaction.nonce = yield getTransactionNonce(options.web3Context, populatedTransaction.from, ETH_DATA_FORMAT);
    }
    if (isNullish(populatedTransaction.value)) {
      populatedTransaction.value = "0x0";
    }
    if (!isNullish(populatedTransaction.data)) {
      if (!isNullish(populatedTransaction.input) && populatedTransaction.data !== populatedTransaction.input)
        throw new TransactionDataAndInputError({
          data: bytesToHex3(populatedTransaction.data),
          input: bytesToHex3(populatedTransaction.input)
        });
      if (!populatedTransaction.data.startsWith("0x"))
        populatedTransaction.data = `0x${populatedTransaction.data}`;
    } else if (!isNullish(populatedTransaction.input)) {
      if (!populatedTransaction.input.startsWith("0x"))
        populatedTransaction.input = `0x${populatedTransaction.input}`;
    } else {
      populatedTransaction.input = "0x";
    }
    if (isNullish(populatedTransaction.common)) {
      if (options.web3Context.defaultCommon) {
        const common = options.web3Context.defaultCommon;
        const chainId = common.customChain.chainId;
        const networkId = common.customChain.networkId;
        const name2 = common.customChain.name;
        populatedTransaction.common = Object.assign(Object.assign({}, common), { customChain: { chainId, networkId, name: name2 } });
      }
      if (isNullish(populatedTransaction.chain)) {
        populatedTransaction.chain = options.web3Context.defaultChain;
      }
      if (isNullish(populatedTransaction.hardfork)) {
        populatedTransaction.hardfork = options.web3Context.defaultHardfork;
      }
    }
    if (isNullish(populatedTransaction.chainId) && isNullish((_a16 = populatedTransaction.common) === null || _a16 === void 0 ? void 0 : _a16.customChain.chainId)) {
      populatedTransaction.chainId = yield getChainId2(options.web3Context, ETH_DATA_FORMAT);
    }
    if (isNullish(populatedTransaction.networkId)) {
      populatedTransaction.networkId = (_b = options.web3Context.defaultNetworkId) !== null && _b !== void 0 ? _b : yield getId2(options.web3Context, ETH_DATA_FORMAT);
    }
    if (isNullish(populatedTransaction.gasLimit) && !isNullish(populatedTransaction.gas)) {
      populatedTransaction.gasLimit = populatedTransaction.gas;
    }
    populatedTransaction.type = getTransactionType(populatedTransaction, options.web3Context);
    if (isNullish(populatedTransaction.accessList) && (populatedTransaction.type === "0x1" || populatedTransaction.type === "0x2")) {
      populatedTransaction.accessList = [];
    }
    if (options.fillGasPrice)
      populatedTransaction = Object.assign(Object.assign({}, populatedTransaction), yield getTransactionGasPricing(populatedTransaction, options.web3Context, ETH_DATA_FORMAT));
    if (isNullish(populatedTransaction.gas) && isNullish(populatedTransaction.gasLimit) && options.fillGasLimit) {
      const fillGasLimit = yield estimateGas2(options.web3Context, populatedTransaction, "latest", ETH_DATA_FORMAT);
      populatedTransaction = Object.assign(Object.assign({}, populatedTransaction), { gas: format2({ format: "uint" }, fillGasLimit, ETH_DATA_FORMAT) });
    }
    return populatedTransaction;
  });
}
var transactionBuilder = (options) => __awaiter44(void 0, void 0, void 0, function* () {
  var _a16;
  return ((_a16 = options.web3Context.transactionBuilder) !== null && _a16 !== void 0 ? _a16 : defaultTransactionBuilder)(Object.assign(Object.assign({}, options), { transaction: options.transaction }));
});

// node_modules/web3-eth/lib/esm/utils/try_send_transaction.js
init_shim();

// node_modules/web3-eth/lib/esm/utils/reject_if_block_timeout.js
init_shim();
var __awaiter45 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function resolveByPolling(web3Context, starterBlockNumber, transactionHash) {
  const pollingInterval = web3Context.transactionPollingInterval;
  const [intervalId, promiseToError] = rejectIfConditionAtInterval2(() => __awaiter45(this, void 0, void 0, function* () {
    let lastBlockNumber;
    try {
      lastBlockNumber = yield getBlockNumber2(web3Context, NUMBER_DATA_FORMAT);
    } catch (error) {
      console.warn("An error happen while trying to get the block number", error);
      return void 0;
    }
    const numberOfBlocks = lastBlockNumber - starterBlockNumber;
    if (numberOfBlocks >= web3Context.transactionBlockTimeout) {
      return new TransactionBlockTimeoutError({
        starterBlockNumber,
        numberOfBlocks,
        transactionHash
      });
    }
    return void 0;
  }), pollingInterval);
  const clean = () => {
    clearInterval(intervalId);
  };
  return [promiseToError, { clean }];
}
function resolveBySubscription(web3Context, starterBlockNumber, transactionHash) {
  var _a16;
  return __awaiter45(this, void 0, void 0, function* () {
    let needToWatchLater = true;
    let subscription;
    let resourceCleaner;
    function revertToPolling(reject, previousError) {
      if (previousError) {
        console.warn("error happened at subscription. So revert to polling...", previousError);
      }
      resourceCleaner.clean();
      needToWatchLater = false;
      const [promiseToError2, newResourceCleaner] = resolveByPolling(web3Context, starterBlockNumber, transactionHash);
      resourceCleaner.clean = newResourceCleaner.clean;
      promiseToError2.catch((error) => reject(error));
    }
    try {
      subscription = yield (_a16 = web3Context.subscriptionManager) === null || _a16 === void 0 ? void 0 : _a16.subscribe("newHeads");
      resourceCleaner = {
        clean: () => {
          var _a17;
          if (subscription.id) {
            (_a17 = web3Context.subscriptionManager) === null || _a17 === void 0 ? void 0 : _a17.removeSubscription(subscription).then(() => {
            }).catch(() => {
            });
          }
        }
      };
    } catch (error) {
      return resolveByPolling(web3Context, starterBlockNumber, transactionHash);
    }
    const promiseToError = new Promise((_, reject) => {
      try {
        subscription.on("data", (lastBlockHeader) => {
          needToWatchLater = false;
          if (!(lastBlockHeader === null || lastBlockHeader === void 0 ? void 0 : lastBlockHeader.number)) {
            return;
          }
          const numberOfBlocks = Number(BigInt(lastBlockHeader.number) - BigInt(starterBlockNumber));
          if (numberOfBlocks >= web3Context.transactionBlockTimeout) {
            reject(new TransactionBlockTimeoutError({
              starterBlockNumber,
              numberOfBlocks,
              transactionHash
            }));
          }
        });
        subscription.on("error", (error) => {
          revertToPolling(reject, error);
        });
      } catch (error) {
        revertToPolling(reject, error);
      }
      setTimeout(() => {
        if (needToWatchLater) {
          revertToPolling(reject);
        }
      }, web3Context.blockHeaderTimeout * 1e3);
    });
    return [promiseToError, resourceCleaner];
  });
}
function rejectIfBlockTimeout(web3Context, transactionHash) {
  var _a16, _b;
  return __awaiter45(this, void 0, void 0, function* () {
    const { provider } = web3Context.requestManager;
    let callingRes;
    const starterBlockNumber = yield getBlockNumber2(web3Context, NUMBER_DATA_FORMAT);
    if (((_b = (_a16 = provider).supportsSubscriptions) === null || _b === void 0 ? void 0 : _b.call(_a16)) && web3Context.enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout) {
      callingRes = yield resolveBySubscription(web3Context, starterBlockNumber, transactionHash);
    } else {
      callingRes = resolveByPolling(web3Context, starterBlockNumber, transactionHash);
    }
    return callingRes;
  });
}

// node_modules/web3-eth/lib/esm/utils/try_send_transaction.js
var __awaiter46 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function trySendTransaction(web3Context, sendTransactionFunc, transactionHash) {
  return __awaiter46(this, void 0, void 0, function* () {
    const [timeoutId, rejectOnTimeout] = rejectIfTimeout2(web3Context.transactionSendTimeout, new TransactionSendTimeoutError({
      numberOfSeconds: web3Context.transactionSendTimeout / 1e3,
      transactionHash
    }));
    const [rejectOnBlockTimeout, blockTimeoutResourceCleaner] = yield rejectIfBlockTimeout(web3Context, transactionHash);
    try {
      return yield Promise.race([
        sendTransactionFunc(),
        rejectOnTimeout,
        rejectOnBlockTimeout
      ]);
    } finally {
      clearTimeout(timeoutId);
      blockTimeoutResourceCleaner.clean();
    }
  });
}

// node_modules/web3-eth/lib/esm/utils/wait_for_transaction_receipt.js
init_shim();
var __awaiter47 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function waitForTransactionReceipt(web3Context, transactionHash, returnFormat) {
  var _a16;
  return __awaiter47(this, void 0, void 0, function* () {
    const pollingInterval = (_a16 = web3Context.transactionReceiptPollingInterval) !== null && _a16 !== void 0 ? _a16 : web3Context.transactionPollingInterval;
    const [awaitableTransactionReceipt, IntervalId] = pollTillDefinedAndReturnIntervalId2(() => __awaiter47(this, void 0, void 0, function* () {
      try {
        return getTransactionReceipt2(web3Context, transactionHash, returnFormat);
      } catch (error) {
        console.warn("An error happen while trying to get the transaction receipt", error);
        return void 0;
      }
    }), pollingInterval);
    const [timeoutId, rejectOnTimeout] = rejectIfTimeout2(web3Context.transactionPollingTimeout, new TransactionPollingTimeoutError({
      numberOfSeconds: web3Context.transactionPollingTimeout / 1e3,
      transactionHash
    }));
    const [rejectOnBlockTimeout, blockTimeoutResourceCleaner] = yield rejectIfBlockTimeout(web3Context, transactionHash);
    try {
      return yield Promise.race([
        awaitableTransactionReceipt,
        rejectOnTimeout,
        rejectOnBlockTimeout
      ]);
    } finally {
      if (timeoutId)
        clearTimeout(timeoutId);
      if (IntervalId)
        clearInterval(IntervalId);
      blockTimeoutResourceCleaner.clean();
    }
  });
}

// node_modules/web3-eth/lib/esm/utils/send_tx_helper.js
init_shim();

// node_modules/web3-eth/lib/esm/utils/watch_transaction_for_confirmations.js
init_shim();

// node_modules/web3-eth/lib/esm/utils/watch_transaction_by_pooling.js
init_shim();
var __awaiter48 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var watchTransactionByPolling = ({ web3Context, transactionReceipt, transactionPromiEvent, returnFormat }) => {
  var _a16;
  let confirmations = 1;
  const intervalId = setInterval(() => {
    (() => __awaiter48(void 0, void 0, void 0, function* () {
      if (confirmations >= web3Context.transactionConfirmationBlocks)
        clearInterval(intervalId);
      const nextBlock = yield eth_rpc_methods_exports.getBlockByNumber(web3Context.requestManager, numberToHex3(BigInt(transactionReceipt.blockNumber) + BigInt(confirmations)), false);
      if (nextBlock === null || nextBlock === void 0 ? void 0 : nextBlock.hash) {
        confirmations += 1;
        transactionPromiEvent.emit("confirmation", {
          confirmations: format2({ format: "uint" }, confirmations, returnFormat),
          receipt: format2(transactionReceiptSchema, transactionReceipt, returnFormat),
          latestBlockHash: format2({ format: "bytes32" }, nextBlock.hash, returnFormat)
        });
      }
    }))();
  }, (_a16 = web3Context.transactionReceiptPollingInterval) !== null && _a16 !== void 0 ? _a16 : web3Context.transactionPollingInterval);
};

// node_modules/web3-eth/lib/esm/utils/watch_transaction_by_subscription.js
init_shim();
var __awaiter49 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var watchTransactionBySubscription = ({ web3Context, transactionReceipt, transactionPromiEvent, returnFormat }) => {
  let needToWatchLater = true;
  let lastCaughtBlockHash;
  setImmediate(() => {
    var _a16;
    (_a16 = web3Context.subscriptionManager) === null || _a16 === void 0 ? void 0 : _a16.subscribe("newHeads").then((subscription) => {
      subscription.on("data", (newBlockHeader) => __awaiter49(void 0, void 0, void 0, function* () {
        var _a17;
        needToWatchLater = false;
        if (!(newBlockHeader === null || newBlockHeader === void 0 ? void 0 : newBlockHeader.number) || lastCaughtBlockHash === (newBlockHeader === null || newBlockHeader === void 0 ? void 0 : newBlockHeader.parentHash)) {
          return;
        }
        lastCaughtBlockHash = newBlockHeader === null || newBlockHeader === void 0 ? void 0 : newBlockHeader.parentHash;
        const confirmations = BigInt(newBlockHeader.number) - BigInt(transactionReceipt.blockNumber) + BigInt(1);
        transactionPromiEvent.emit("confirmation", {
          confirmations: format2({ format: "uint" }, confirmations, returnFormat),
          receipt: format2(transactionReceiptSchema, transactionReceipt, returnFormat),
          latestBlockHash: format2({ format: "bytes32" }, newBlockHeader.parentHash, returnFormat)
        });
        if (confirmations >= web3Context.transactionConfirmationBlocks) {
          yield (_a17 = web3Context.subscriptionManager) === null || _a17 === void 0 ? void 0 : _a17.removeSubscription(subscription);
        }
      }));
      subscription.on("error", () => __awaiter49(void 0, void 0, void 0, function* () {
        var _b;
        yield (_b = web3Context.subscriptionManager) === null || _b === void 0 ? void 0 : _b.removeSubscription(subscription);
        needToWatchLater = false;
        watchTransactionByPolling({
          web3Context,
          transactionReceipt,
          transactionPromiEvent,
          returnFormat
        });
      }));
    }).catch(() => {
      needToWatchLater = false;
      watchTransactionByPolling({
        web3Context,
        transactionReceipt,
        transactionPromiEvent,
        returnFormat
      });
    });
  });
  setTimeout(() => {
    if (needToWatchLater) {
      watchTransactionByPolling({
        web3Context,
        transactionReceipt,
        transactionPromiEvent,
        returnFormat
      });
    }
  }, web3Context.blockHeaderTimeout * 1e3);
};

// node_modules/web3-eth/lib/esm/utils/watch_transaction_for_confirmations.js
function watchTransactionForConfirmations(web3Context, transactionPromiEvent, transactionReceipt, transactionHash, returnFormat) {
  if (isNullish(transactionReceipt) || isNullish(transactionReceipt.blockHash))
    throw new TransactionMissingReceiptOrBlockHashError({
      receipt: transactionReceipt,
      blockHash: format2({ format: "bytes32" }, transactionReceipt === null || transactionReceipt === void 0 ? void 0 : transactionReceipt.blockHash, returnFormat),
      transactionHash: format2({ format: "bytes32" }, transactionHash, returnFormat)
    });
  if (!transactionReceipt.blockNumber)
    throw new TransactionReceiptMissingBlockNumberError({ receipt: transactionReceipt });
  transactionPromiEvent.emit("confirmation", {
    confirmations: format2({ format: "uint" }, 1, returnFormat),
    receipt: format2(transactionReceiptSchema, transactionReceipt, returnFormat),
    latestBlockHash: format2({ format: "bytes32" }, transactionReceipt.blockHash, returnFormat)
  });
  const provider = web3Context.requestManager.provider;
  if (provider && "supportsSubscriptions" in provider && provider.supportsSubscriptions()) {
    watchTransactionBySubscription({
      web3Context,
      transactionReceipt,
      transactionPromiEvent,
      returnFormat
    });
  } else {
    watchTransactionByPolling({
      web3Context,
      transactionReceipt,
      transactionPromiEvent,
      returnFormat
    });
  }
}

// node_modules/web3-eth/lib/esm/utils/get_transaction_error.js
init_shim();

// node_modules/web3-eth/lib/esm/utils/get_revert_reason.js
init_shim();

// node_modules/web3-eth-abi/lib/esm/index.js
var esm_exports12 = {};
__export(esm_exports12, {
  decodeContractErrorData: () => decodeContractErrorData,
  decodeLog: () => decodeLog,
  decodeParameter: () => decodeParameter,
  decodeParameters: () => decodeParameters2,
  decodeParametersWith: () => decodeParametersWith,
  encodeErrorSignature: () => encodeErrorSignature,
  encodeEventSignature: () => encodeEventSignature,
  encodeFunctionCall: () => encodeFunctionCall,
  encodeFunctionSignature: () => encodeFunctionSignature,
  encodeParameter: () => encodeParameter,
  encodeParameters: () => encodeParameters2,
  flattenTypes: () => flattenTypes,
  formatOddHexstrings: () => formatOddHexstrings,
  formatParam: () => formatParam,
  getEncodedEip712Data: () => getMessage,
  isAbiConstructorFragment: () => isAbiConstructorFragment,
  isAbiErrorFragment: () => isAbiErrorFragment,
  isAbiEventFragment: () => isAbiEventFragment,
  isAbiFragment: () => isAbiFragment,
  isAbiFunctionFragment: () => isAbiFunctionFragment,
  isOddHexstring: () => isOddHexstring,
  isSimplifiedStructFormat: () => isSimplifiedStructFormat,
  jsonInterfaceMethodToString: () => jsonInterfaceMethodToString,
  mapStructNameAndType: () => mapStructNameAndType,
  mapStructToCoderFormat: () => mapStructToCoderFormat,
  mapTypes: () => mapTypes
});
init_shim();

// node_modules/web3-eth-abi/lib/esm/api/errors_api.js
init_shim();

// node_modules/web3-eth-abi/node_modules/web3-utils/lib/esm/index.js
init_shim();

// node_modules/web3-eth-abi/node_modules/web3-utils/lib/esm/converters.js
init_shim();

// node_modules/web3-eth-abi/node_modules/ethereum-cryptography/esm/keccak.js
init_shim();
init_sha3();

// node_modules/web3-eth-abi/node_modules/ethereum-cryptography/esm/utils.js
init_shim();
init_assert();
init_utils();
init_utils();
var assertBool6 = assert_default.bool;
var assertBytes6 = assert_default.bytes;
function bytesToUtf85(data) {
  if (!(data instanceof Uint8Array)) {
    throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
  }
  return new TextDecoder().decode(data);
}
function wrapHash6(hash) {
  return (msg) => {
    assert_default.bytes(msg);
    return hash(msg);
  };
}
var crypto8 = (() => {
  const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
  return {
    node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
    web: webCrypto
  };
})();

// node_modules/web3-eth-abi/node_modules/ethereum-cryptography/esm/keccak.js
var keccak2246 = wrapHash6(keccak_224);
var keccak2566 = (() => {
  const k = wrapHash6(keccak_256);
  k.create = keccak_256.create;
  return k;
})();
var keccak3846 = wrapHash6(keccak_384);
var keccak5126 = wrapHash6(keccak_512);

// node_modules/web3-eth-abi/node_modules/web3-utils/lib/esm/converters.js
var ethUnitMap5 = {
  noether: BigInt(0),
  wei: BigInt(1),
  kwei: BigInt(1e3),
  Kwei: BigInt(1e3),
  babbage: BigInt(1e3),
  femtoether: BigInt(1e3),
  mwei: BigInt(1e6),
  Mwei: BigInt(1e6),
  lovelace: BigInt(1e6),
  picoether: BigInt(1e6),
  gwei: BigInt(1e9),
  Gwei: BigInt(1e9),
  shannon: BigInt(1e9),
  nanoether: BigInt(1e9),
  nano: BigInt(1e9),
  szabo: BigInt(1e12),
  microether: BigInt(1e12),
  micro: BigInt(1e12),
  finney: BigInt(1e15),
  milliether: BigInt(1e15),
  milli: BigInt(1e15),
  ether: BigInt("1000000000000000000"),
  kether: BigInt("1000000000000000000000"),
  grand: BigInt("1000000000000000000000"),
  mether: BigInt("1000000000000000000000000"),
  gether: BigInt("1000000000000000000000000000"),
  tether: BigInt("1000000000000000000000000000000")
};
var bytesToUint8Array5 = (data) => {
  validator.validate(["bytes"], [data]);
  if (data instanceof Uint8Array) {
    return data;
  }
  if (Array.isArray(data)) {
    return new Uint8Array(data);
  }
  if (typeof data === "string") {
    return utils_exports.hexToUint8Array(data);
  }
  throw new InvalidBytesError(data);
};
var { uint8ArrayToHexString: uint8ArrayToHexString6 } = utils_exports;
var bytesToHex6 = (bytes) => uint8ArrayToHexString6(bytesToUint8Array5(bytes));
var hexToBytes6 = (bytes) => {
  if (typeof bytes === "string" && bytes.slice(0, 2).toLowerCase() !== "0x") {
    return bytesToUint8Array5(`0x${bytes}`);
  }
  return bytesToUint8Array5(bytes);
};
var hexToNumber5 = (value) => {
  validator.validate(["hex"], [value]);
  return utils_exports.hexToNumber(value);
};
var numberToHex6 = (value, hexstrict) => {
  if (typeof value !== "bigint")
    validator.validate(["int"], [value]);
  let updatedValue = utils_exports.numberToHex(value);
  if (hexstrict) {
    if (!updatedValue.startsWith("-") && updatedValue.length % 2 === 1) {
      updatedValue = "0x0".concat(updatedValue.slice(2));
    } else if (updatedValue.length % 2 === 0 && updatedValue.startsWith("-"))
      updatedValue = "-0x0".concat(updatedValue.slice(3));
  }
  return updatedValue;
};
var utf8ToHex5 = (str) => {
  validator.validate(["string"], [str]);
  let strWithoutNullCharacter = str.replace(/^(?:\u0000)/, "");
  strWithoutNullCharacter = strWithoutNullCharacter.replace(/(?:\u0000)$/, "");
  return bytesToHex6(new TextEncoder().encode(strWithoutNullCharacter));
};
var hexToUtf84 = (str) => bytesToUtf85(hexToBytes6(str));
var utf8ToBytes6 = utf8ToBytes;
var toHex5 = (value, returnType) => {
  if (typeof value === "string" && isAddress(value)) {
    return returnType ? "address" : `0x${value.toLowerCase().replace(/^0x/i, "")}`;
  }
  if (typeof value === "boolean") {
    return returnType ? "bool" : value ? "0x01" : "0x00";
  }
  if (typeof value === "number") {
    return returnType ? value < 0 ? "int256" : "uint256" : numberToHex6(value);
  }
  if (typeof value === "bigint") {
    return returnType ? "bigint" : numberToHex6(value);
  }
  if (typeof value === "object" && !!value) {
    return returnType ? "string" : utf8ToHex5(JSON.stringify(value));
  }
  if (typeof value === "string") {
    if (value.startsWith("-0x") || value.startsWith("-0X")) {
      return returnType ? "int256" : numberToHex6(value);
    }
    if (isHexStrict(value)) {
      return returnType ? "bytes" : value;
    }
    if (isHex(value) && !isInt(value)) {
      return returnType ? "bytes" : `0x${value}`;
    }
    if (!Number.isFinite(value)) {
      return returnType ? "string" : utf8ToHex5(value);
    }
  }
  throw new HexProcessingError(value);
};
var toNumber5 = (value) => {
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "bigint") {
    return value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER ? Number(value) : value;
  }
  if (typeof value === "string" && isHexStrict(value)) {
    return hexToNumber5(value);
  }
  try {
    return toNumber5(BigInt(value));
  } catch (_a16) {
    throw new InvalidNumberError(value);
  }
};
var toBigInt5 = (value) => {
  if (typeof value === "number") {
    return BigInt(value);
  }
  if (typeof value === "bigint") {
    return value;
  }
  if (typeof value === "string" && isHex(value)) {
    if (value.startsWith("-")) {
      return -BigInt(value.substring(1));
    }
    return BigInt(value);
  }
  throw new InvalidNumberError(value);
};
var toChecksumAddress5 = (address) => {
  if (!isAddress(address, false)) {
    throw new InvalidAddressError(address);
  }
  const lowerCaseAddress = address.toLowerCase().replace(/^0x/i, "");
  const hash = utils_exports.uint8ArrayToHexString(keccak2566(utf8ToBytes6(lowerCaseAddress)));
  if (isNullish(hash) || hash === "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470")
    return "";
  let checksumAddress = "0x";
  const addressHash = hash.replace(/^0x/i, "");
  for (let i = 0; i < lowerCaseAddress.length; i += 1) {
    if (parseInt(addressHash[i], 16) > 7) {
      checksumAddress += lowerCaseAddress[i].toUpperCase();
    } else {
      checksumAddress += lowerCaseAddress[i];
    }
  }
  return checksumAddress;
};
var toBool2 = (value) => {
  if (typeof value === "boolean") {
    return value;
  }
  if (typeof value === "number" && (value === 0 || value === 1)) {
    return Boolean(value);
  }
  if (typeof value === "bigint" && (value === BigInt(0) || value === BigInt(1))) {
    return Boolean(value);
  }
  if (typeof value === "string" && !isHexStrict(value) && (value === "1" || value === "0" || value === "false" || value === "true")) {
    if (value === "true") {
      return true;
    }
    if (value === "false") {
      return false;
    }
    return Boolean(Number(value));
  }
  if (typeof value === "string" && isHexStrict(value) && (value === "0x1" || value === "0x0")) {
    return Boolean(toNumber5(value));
  }
  throw new InvalidBooleanError(value);
};

// node_modules/web3-eth-abi/node_modules/web3-utils/lib/esm/event_emitter.js
init_shim();
var import_events9 = __toESM(require_events(), 1);
var __awaiter50 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var wrapFunction5 = (fn) => (params) => fn(params.detail);
var EventEmitterAtBrowser5 = class extends EventTarget {
  constructor() {
    super(...arguments);
    this._listeners = {};
    this.maxListeners = Number.MAX_SAFE_INTEGER;
  }
  on(eventName, fn) {
    this.addEventListener(eventName, fn);
    return this;
  }
  once(eventName, fn) {
    const onceCallback = (params) => __awaiter50(this, void 0, void 0, function* () {
      this.off(eventName, onceCallback);
      yield fn(params);
    });
    return this.on(eventName, onceCallback);
  }
  off(eventName, fn) {
    this.removeEventListener(eventName, fn);
    return this;
  }
  emit(eventName, params) {
    const event = new CustomEvent(eventName, { detail: params });
    return super.dispatchEvent(event);
  }
  listenerCount(eventName) {
    const eventListeners = this._listeners[eventName];
    return eventListeners ? eventListeners.length : 0;
  }
  listeners(eventName) {
    return this._listeners[eventName].map((value) => value[0]) || [];
  }
  eventNames() {
    return Object.keys(this._listeners);
  }
  removeAllListeners() {
    Object.keys(this._listeners).forEach((event) => {
      this._listeners[event].forEach((listener) => {
        super.removeEventListener(event, listener[1]);
      });
    });
    this._listeners = {};
    return this;
  }
  setMaxListeners(maxListeners) {
    this.maxListeners = maxListeners;
    return this;
  }
  getMaxListeners() {
    return this.maxListeners;
  }
  addEventListener(eventName, fn) {
    const wrappedFn = wrapFunction5(fn);
    super.addEventListener(eventName, wrappedFn);
    if (!this._listeners[eventName]) {
      this._listeners[eventName] = [];
    }
    this._listeners[eventName].push([fn, wrappedFn]);
  }
  removeEventListener(eventName, fn) {
    const eventListeners = this._listeners[eventName];
    if (eventListeners) {
      const index = eventListeners.findIndex((item) => item[0] === fn);
      if (index !== -1) {
        super.removeEventListener(eventName, eventListeners[index][1]);
        eventListeners.splice(index, 1);
      }
    }
  }
};
var EventEmitterType5;
if (typeof window === "undefined") {
  EventEmitterType5 = import_events9.EventEmitter;
} else {
  EventEmitterType5 = EventEmitterAtBrowser5;
}

// node_modules/web3-eth-abi/node_modules/web3-utils/lib/esm/validation.js
init_shim();
var isNullish6 = isNullish;

// node_modules/web3-eth-abi/node_modules/web3-utils/lib/esm/formatter.js
init_shim();

// node_modules/web3-eth-abi/node_modules/web3-utils/lib/esm/objects.js
init_shim();

// node_modules/web3-eth-abi/node_modules/web3-utils/lib/esm/string_manipulation.js
init_shim();
var padLeft6 = (value, characterAmount, sign6 = "0") => {
  if (typeof value === "string") {
    if (!isHexStrict(value)) {
      return value.padStart(characterAmount, sign6);
    }
    return utils_exports.padLeft(value, characterAmount, sign6);
  }
  validator.validate(["int"], [value]);
  return utils_exports.padLeft(value, characterAmount, sign6);
};
var padRight2 = (value, characterAmount, sign6 = "0") => {
  if (typeof value === "string" && !isHexStrict(value)) {
    return value.padEnd(characterAmount, sign6);
  }
  validator.validate(["int"], [value]);
  const hexString = typeof value === "string" && isHexStrict(value) ? value : numberToHex6(value);
  const prefixLength = hexString.startsWith("-") ? 3 : 2;
  return hexString.padEnd(characterAmount + prefixLength, sign6);
};
var rightPad5 = padRight2;
var leftPad5 = padLeft6;

// node_modules/web3-eth-abi/node_modules/web3-utils/lib/esm/uint8array.js
init_shim();
function uint8ArrayConcat5(...parts) {
  const length = parts.reduce((prev, part) => {
    const agg = prev + part.length;
    return agg;
  }, 0);
  const result = new Uint8Array(length);
  let offset = 0;
  for (const part of parts) {
    result.set(part, offset);
    offset += part.length;
  }
  return result;
}

// node_modules/web3-eth-abi/node_modules/web3-utils/lib/esm/formatter.js
var { parseBaseType: parseBaseType6 } = utils_exports;

// node_modules/web3-eth-abi/node_modules/web3-utils/lib/esm/hash.js
init_shim();
var SHA3_EMPTY_BYTES5 = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
var sha35 = (data) => {
  let updatedData;
  if (typeof data === "string") {
    if (data.startsWith("0x") && isHexStrict(data)) {
      updatedData = hexToBytes6(data);
    } else {
      updatedData = utf8ToBytes(data);
    }
  } else {
    updatedData = data;
  }
  const hash = bytesToHex6(keccak2566(updatedData));
  return hash === SHA3_EMPTY_BYTES5 ? void 0 : hash;
};
var sha3Raw5 = (data) => {
  const hash = sha35(data);
  if (isNullish(hash)) {
    return SHA3_EMPTY_BYTES5;
  }
  return hash;
};
var keccak256Wrapper3 = (data) => {
  let processedData;
  if (typeof data === "bigint" || typeof data === "number") {
    processedData = utf8ToBytes(data.toString());
  } else if (Array.isArray(data)) {
    processedData = new Uint8Array(data);
  } else if (typeof data === "string" && !isHexStrict(data)) {
    processedData = utf8ToBytes(data);
  } else {
    processedData = bytesToUint8Array5(data);
  }
  return bytesToHex6(keccak2566(processedData));
};

// node_modules/web3-eth-abi/node_modules/web3-utils/lib/esm/random.js
init_shim();

// node_modules/web3-eth-abi/node_modules/ethereum-cryptography/esm/random.js
init_shim();
init_utils();
function getRandomBytesSync5(bytes) {
  return randomBytes(bytes);
}

// node_modules/web3-eth-abi/node_modules/web3-utils/lib/esm/random.js
var randomBytes6 = (size) => getRandomBytesSync5(size);

// node_modules/web3-eth-abi/node_modules/web3-utils/lib/esm/promise_helpers.js
init_shim();

// node_modules/web3-eth-abi/node_modules/web3-utils/lib/esm/json_rpc.js
var json_rpc_exports5 = {};
__export(json_rpc_exports5, {
  isBatchRequest: () => isBatchRequest5,
  isBatchResponse: () => isBatchResponse5,
  isResponseRpcError: () => isResponseRpcError5,
  isResponseWithError: () => isResponseWithError6,
  isResponseWithNotification: () => isResponseWithNotification5,
  isResponseWithResult: () => isResponseWithResult5,
  isSubscriptionResult: () => isSubscriptionResult5,
  isValidResponse: () => isValidResponse5,
  setRequestIdStart: () => setRequestIdStart5,
  toBatchPayload: () => toBatchPayload5,
  toPayload: () => toPayload5,
  validateResponse: () => validateResponse5
});
init_shim();

// node_modules/web3-eth-abi/node_modules/web3-utils/lib/esm/uuid.js
init_shim();
var uuidV45 = () => {
  const bytes = randomBytes6(16);
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 63 | 128;
  const hexString = bytesToHex6(bytes);
  return [
    hexString.substring(2, 10),
    hexString.substring(10, 14),
    hexString.substring(14, 18),
    hexString.substring(18, 22),
    hexString.substring(22, 34)
  ].join("-");
};

// node_modules/web3-eth-abi/node_modules/web3-utils/lib/esm/json_rpc.js
var isResponseRpcError5 = (rpcError) => {
  const errorCode = rpcError.error.code;
  return rpcErrorsMap.has(errorCode) || errorCode >= -32099 && errorCode <= -32e3;
};
var isResponseWithResult5 = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && "result" in response && isNullish(response.error) && (typeof response.id === "number" || typeof response.id === "string");
var isResponseWithError6 = (response) => !Array.isArray(response) && response.jsonrpc === "2.0" && !!response && isNullish(response.result) && "error" in response && (typeof response.id === "number" || typeof response.id === "string");
var isResponseWithNotification5 = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && !isNullish(response.params) && !isNullish(response.method);
var isSubscriptionResult5 = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && "id" in response && "result" in response;
var validateResponse5 = (response) => isResponseWithResult5(response) || isResponseWithError6(response);
var isValidResponse5 = (response) => Array.isArray(response) ? response.every(validateResponse5) : validateResponse5(response);
var isBatchResponse5 = (response) => Array.isArray(response) && response.length > 0 && isValidResponse5(response);
var requestIdSeed5;
var setRequestIdStart5 = (start) => {
  requestIdSeed5 = start;
};
var toPayload5 = (request) => {
  var _a16, _b, _c, _d;
  if (typeof requestIdSeed5 !== "undefined") {
    requestIdSeed5 += 1;
  }
  return {
    jsonrpc: (_a16 = request.jsonrpc) !== null && _a16 !== void 0 ? _a16 : "2.0",
    id: (_c = (_b = request.id) !== null && _b !== void 0 ? _b : requestIdSeed5) !== null && _c !== void 0 ? _c : uuidV45(),
    method: request.method,
    params: (_d = request.params) !== null && _d !== void 0 ? _d : void 0
  };
};
var toBatchPayload5 = (requests) => requests.map((request) => toPayload5(request));
var isBatchRequest5 = (request) => Array.isArray(request) && request.length > 0;

// node_modules/web3-eth-abi/node_modules/web3-utils/lib/esm/web3_deferred_promise.js
init_shim();
var _a9;
_a9 = Symbol.toStringTag;

// node_modules/web3-eth-abi/node_modules/web3-utils/lib/esm/chunk_response_parser.js
init_shim();

// node_modules/web3-eth-abi/node_modules/web3-utils/lib/esm/web3_eip1193_provider.js
init_shim();
var import_events10 = __toESM(require_events(), 1);

// node_modules/web3-eth-abi/node_modules/web3-utils/lib/esm/socket_provider.js
init_shim();

// node_modules/web3-eth-abi/lib/esm/utils.js
init_shim();
var isAbiFragment = (item) => !isNullish6(item) && typeof item === "object" && !isNullish6(item.type) && ["function", "event", "constructor", "error"].includes(item.type);
var isAbiErrorFragment = (item) => !isNullish6(item) && typeof item === "object" && !isNullish6(item.type) && item.type === "error";
var isAbiEventFragment = (item) => !isNullish6(item) && typeof item === "object" && !isNullish6(item.type) && item.type === "event";
var isAbiFunctionFragment = (item) => !isNullish6(item) && typeof item === "object" && !isNullish6(item.type) && item.type === "function";
var isAbiConstructorFragment = (item) => !isNullish6(item) && typeof item === "object" && !isNullish6(item.type) && item.type === "constructor";
var isSimplifiedStructFormat = (type) => typeof type === "object" && typeof type.components === "undefined" && typeof type.name === "undefined";
var mapStructNameAndType = (structName) => structName.includes("[]") ? { type: "tuple[]", name: structName.slice(0, -2) } : { type: "tuple", name: structName };
var mapStructToCoderFormat = (struct) => {
  const components = [];
  for (const key of Object.keys(struct)) {
    const item = struct[key];
    if (typeof item === "object") {
      components.push(Object.assign(Object.assign({}, mapStructNameAndType(key)), { components: mapStructToCoderFormat(item) }));
    } else {
      components.push({
        name: key,
        type: struct[key]
      });
    }
  }
  return components;
};
var mapTypes = (types) => {
  const mappedTypes = [];
  for (const type of types) {
    let modifiedType = type;
    if (typeof type === "object") {
      modifiedType = Object.assign({}, type);
    }
    if (typeof type === "object" && type.type === "function") {
      modifiedType = Object.assign(Object.assign({}, type), { type: "bytes24" });
    }
    if (isSimplifiedStructFormat(modifiedType)) {
      const structName = Object.keys(modifiedType)[0];
      mappedTypes.push(Object.assign(Object.assign({}, mapStructNameAndType(structName)), { components: mapStructToCoderFormat(modifiedType[structName]) }));
    } else {
      mappedTypes.push(modifiedType);
    }
  }
  return mappedTypes;
};
var isOddHexstring = (param) => typeof param === "string" && /^(-)?0x[0-9a-f]*$/i.test(param) && param.length % 2 === 1;
var formatOddHexstrings = (param) => isOddHexstring(param) ? `0x0${param.substring(2)}` : param;
var formatParam = (type, _param) => {
  var _a16;
  const param = typeof _param === "object" && !Array.isArray(_param) ? Object.assign({}, _param) : _param;
  const paramTypeBytes = /^bytes([0-9]*)$/;
  const paramTypeBytesArray = /^bytes([0-9]*)\[\]$/;
  const paramTypeNumber = /^(u?int)([0-9]*)$/;
  const paramTypeNumberArray = /^(u?int)([0-9]*)\[\]$/;
  if (param instanceof BigInt) {
    return param.toString(10);
  }
  if (paramTypeBytesArray.exec(type) || paramTypeNumberArray.exec(type)) {
    const paramClone = [...param];
    return paramClone.map((p) => formatParam(type.replace("[]", ""), p));
  }
  let match = paramTypeNumber.exec(type);
  if (match) {
    const size = parseInt((_a16 = match[2]) !== null && _a16 !== void 0 ? _a16 : "256", 10);
    if (size / 8 < param.length) {
      return leftPad5(param, size);
    }
  }
  match = paramTypeBytes.exec(type);
  if (match) {
    const hexParam = param instanceof Uint8Array ? toHex5(param) : param;
    const size = parseInt(match[1], 10);
    if (size) {
      let maxSize = size * 2;
      if (param.startsWith("0x")) {
        maxSize += 2;
      }
      const paddedParam = hexParam.length < maxSize ? rightPad5(param, size * 2) : hexParam;
      return formatOddHexstrings(paddedParam);
    }
    return formatOddHexstrings(hexParam);
  }
  return param;
};
var flattenTypes = (includeTuple, puts) => {
  const types = [];
  puts.forEach((param) => {
    if (typeof param.components === "object") {
      if (!param.type.startsWith("tuple")) {
        throw new AbiError(`Invalid value given "${param.type}". Error: components found but type is not tuple.`);
      }
      const arrayBracket = param.type.indexOf("[");
      const suffix = arrayBracket >= 0 ? param.type.substring(arrayBracket) : "";
      const result = flattenTypes(includeTuple, param.components);
      if (Array.isArray(result) && includeTuple) {
        types.push(`tuple(${result.join(",")})${suffix}`);
      } else if (!includeTuple) {
        types.push(`(${result.join(",")})${suffix}`);
      } else {
        types.push(`(${result.join()})`);
      }
    } else {
      types.push(param.type);
    }
  });
  return types;
};
var jsonInterfaceMethodToString = (json) => {
  var _a16, _b, _c, _d;
  if (isAbiErrorFragment(json) || isAbiEventFragment(json) || isAbiFunctionFragment(json)) {
    if ((_a16 = json.name) === null || _a16 === void 0 ? void 0 : _a16.includes("(")) {
      return json.name;
    }
    return `${(_b = json.name) !== null && _b !== void 0 ? _b : ""}(${flattenTypes(false, (_c = json.inputs) !== null && _c !== void 0 ? _c : []).join(",")})`;
  }
  return `(${flattenTypes(false, (_d = json.inputs) !== null && _d !== void 0 ? _d : []).join(",")})`;
};

// node_modules/web3-eth-abi/lib/esm/api/errors_api.js
var encodeErrorSignature = (functionName) => {
  if (typeof functionName !== "string" && !isAbiErrorFragment(functionName)) {
    throw new AbiError("Invalid parameter value in encodeErrorSignature");
  }
  let name2;
  if (functionName && (typeof functionName === "function" || typeof functionName === "object")) {
    name2 = jsonInterfaceMethodToString(functionName);
  } else {
    name2 = functionName;
  }
  return sha3Raw5(name2);
};

// node_modules/web3-eth-abi/lib/esm/api/events_api.js
init_shim();
var encodeEventSignature = (functionName) => {
  if (typeof functionName !== "string" && !isAbiEventFragment(functionName)) {
    throw new AbiError("Invalid parameter value in encodeEventSignature");
  }
  let name2;
  if (functionName && (typeof functionName === "function" || typeof functionName === "object")) {
    name2 = jsonInterfaceMethodToString(functionName);
  } else {
    name2 = functionName;
  }
  return sha3Raw5(name2);
};

// node_modules/web3-eth-abi/lib/esm/api/functions_api.js
init_shim();

// node_modules/web3-eth-abi/lib/esm/api/parameters_api.js
init_shim();

// node_modules/web3-eth-abi/lib/esm/coders/decode.js
init_shim();

// node_modules/web3-eth-abi/lib/esm/coders/base/tuple.js
init_shim();

// node_modules/web3-eth-abi/lib/esm/coders/base/index.js
init_shim();

// node_modules/web3-eth-abi/lib/esm/coders/base/address.js
init_shim();

// node_modules/web3-eth-abi/lib/esm/coders/utils.js
init_shim();

// node_modules/web3-eth-abi/node_modules/abitype/dist/index.mjs
init_shim();

// node_modules/web3-eth-abi/node_modules/abitype/dist/chunk-WP7KDV47.mjs
init_shim();
function execTyped(regex, string) {
  const match = regex.exec(string);
  return match == null ? void 0 : match.groups;
}
var bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var isTupleRegex = /^\(.+?\).*?$/;

// node_modules/web3-eth-abi/node_modules/abitype/dist/chunk-NHABU752.mjs
init_shim();
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/web3-eth-abi/node_modules/abitype/dist/index.mjs
var name = "abitype";
var version = "0.7.1";
var BaseError = class extends Error {
  constructor(shortMessage, args = {}) {
    var _a16;
    const details = args.cause instanceof BaseError ? args.cause.details : ((_a16 = args.cause) == null ? void 0 : _a16.message) ? args.cause.message : args.details;
    const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
    const message = [
      shortMessage || "An error occurred.",
      "",
      ...args.metaMessages ? [...args.metaMessages, ""] : [],
      ...docsPath ? [`Docs: https://abitype.dev${docsPath}`] : [],
      ...details ? [`Details: ${details}`] : [],
      `Version: ${name}@${version}`
    ].join("\n");
    super(message);
    __publicField(this, "details");
    __publicField(this, "docsPath");
    __publicField(this, "metaMessages");
    __publicField(this, "shortMessage");
    __publicField(this, "name", "AbiTypeError");
    if (args.cause)
      this.cause = args.cause;
    this.details = details;
    this.docsPath = docsPath;
    this.metaMessages = args.metaMessages;
    this.shortMessage = shortMessage;
  }
};
var structSignatureRegex = /^struct (?<name>[a-zA-Z0-9_]+) \{(?<properties>.*?)\}$/;
function isStructSignature(signature) {
  return structSignatureRegex.test(signature);
}
function execStructSignature(signature) {
  return execTyped(
    structSignatureRegex,
    signature
  );
}
var modifiers = /* @__PURE__ */ new Set([
  "memory",
  "indexed",
  "storage",
  "calldata"
]);
var functionModifiers = /* @__PURE__ */ new Set([
  "calldata",
  "memory",
  "storage"
]);
function getParameterCacheKey(param, type) {
  if (type)
    return `${type}:${param}`;
  return param;
}
var parameterCache = /* @__PURE__ */ new Map([
  ["address", { type: "address" }],
  ["bool", { type: "bool" }],
  ["bytes", { type: "bytes" }],
  ["bytes32", { type: "bytes32" }],
  ["int", { type: "int256" }],
  ["int256", { type: "int256" }],
  ["string", { type: "string" }],
  ["uint", { type: "uint256" }],
  ["uint8", { type: "uint8" }],
  ["uint16", { type: "uint16" }],
  ["uint24", { type: "uint24" }],
  ["uint32", { type: "uint32" }],
  ["uint64", { type: "uint64" }],
  ["uint96", { type: "uint96" }],
  ["uint112", { type: "uint112" }],
  ["uint160", { type: "uint160" }],
  ["uint192", { type: "uint192" }],
  ["uint256", { type: "uint256" }],
  ["address owner", { type: "address", name: "owner" }],
  ["address to", { type: "address", name: "to" }],
  ["bool approved", { type: "bool", name: "approved" }],
  ["bytes _data", { type: "bytes", name: "_data" }],
  ["bytes data", { type: "bytes", name: "data" }],
  ["bytes signature", { type: "bytes", name: "signature" }],
  ["bytes32 hash", { type: "bytes32", name: "hash" }],
  ["bytes32 r", { type: "bytes32", name: "r" }],
  ["bytes32 root", { type: "bytes32", name: "root" }],
  ["bytes32 s", { type: "bytes32", name: "s" }],
  ["string name", { type: "string", name: "name" }],
  ["string symbol", { type: "string", name: "symbol" }],
  ["string tokenURI", { type: "string", name: "tokenURI" }],
  ["uint tokenId", { type: "uint256", name: "tokenId" }],
  ["uint8 v", { type: "uint8", name: "v" }],
  ["uint256 balance", { type: "uint256", name: "balance" }],
  ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
  ["uint256 value", { type: "uint256", name: "value" }],
  [
    "event:address indexed from",
    { type: "address", name: "from", indexed: true }
  ],
  ["event:address indexed to", { type: "address", name: "to", indexed: true }],
  [
    "event:uint indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: true }
  ],
  [
    "event:uint256 indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: true }
  ]
]);
var abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/;
var abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/;
var dynamicIntegerRegex = /^u?int$/;
function parseAbiParameter(param, options) {
  var _a16, _b, _c, _d;
  const parameterCacheKey = getParameterCacheKey(param, options == null ? void 0 : options.type);
  if (parameterCache.has(parameterCacheKey))
    return parameterCache.get(parameterCacheKey);
  const isTuple = isTupleRegex.test(param);
  const match = execTyped(
    isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex,
    param
  );
  if (!match)
    throw new BaseError("Invalid ABI parameter.", {
      details: param
    });
  if (match.name && isSolidityKeyword(match.name))
    throw new BaseError("Invalid ABI parameter.", {
      details: param,
      metaMessages: [
        `"${match.name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
      ]
    });
  const name2 = match.name ? { name: match.name } : {};
  const indexed = match.modifier === "indexed" ? { indexed: true } : {};
  const structs = (_a16 = options == null ? void 0 : options.structs) != null ? _a16 : {};
  let type;
  let components = {};
  if (isTuple) {
    type = "tuple";
    const params = splitParameters(match.type);
    const components_ = [];
    const length = params.length;
    for (let i = 0; i < length; i++) {
      components_.push(parseAbiParameter(params[i], { structs }));
    }
    components = { components: components_ };
  } else if (match.type in structs) {
    type = "tuple";
    components = { components: structs[match.type] };
  } else if (dynamicIntegerRegex.test(match.type)) {
    type = `${match.type}256`;
  } else {
    type = match.type;
    if (!((options == null ? void 0 : options.type) === "struct") && !isSolidityType(type))
      throw new BaseError("Unknown type.", {
        metaMessages: [`Type "${type}" is not a valid ABI type.`]
      });
  }
  if (match.modifier) {
    if (!((_c = (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.has) == null ? void 0 : _c.call(_b, match.modifier)))
      throw new BaseError("Invalid ABI parameter.", {
        details: param,
        metaMessages: [
          `Modifier "${match.modifier}" not allowed${(options == null ? void 0 : options.type) ? ` in "${options.type}" type` : ""}.`
        ]
      });
    if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))
      throw new BaseError("Invalid ABI parameter.", {
        details: param,
        metaMessages: [
          `Modifier "${match.modifier}" not allowed${(options == null ? void 0 : options.type) ? ` in "${options.type}" type` : ""}.`,
          `Data location can only be specified for array, struct, or mapping types, but "${match.modifier}" was given.`
        ]
      });
  }
  const abiParameter = {
    type: `${type}${(_d = match.array) != null ? _d : ""}`,
    ...name2,
    ...indexed,
    ...components
  };
  parameterCache.set(parameterCacheKey, abiParameter);
  return abiParameter;
}
function splitParameters(params, result = [], current = "", depth = 0) {
  if (params === "") {
    if (current === "")
      return result;
    if (depth !== 0)
      throw new BaseError("Unbalanced parentheses.", {
        metaMessages: [
          `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
        ],
        details: `Depth "${depth}"`
      });
    return [...result, current.trim()];
  }
  const length = params.length;
  for (let i = 0; i < length; i++) {
    const char = params[i];
    const tail = params.slice(i + 1);
    switch (char) {
      case ",":
        return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);
      case "(":
        return splitParameters(tail, result, `${current}${char}`, depth + 1);
      case ")":
        return splitParameters(tail, result, `${current}${char}`, depth - 1);
      default:
        return splitParameters(tail, result, `${current}${char}`, depth);
    }
  }
  return [];
}
function isSolidityType(type) {
  return type === "address" || type === "bool" || type === "function" || type === "string" || bytesRegex.test(type) || integerRegex.test(type);
}
var protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function isSolidityKeyword(name2) {
  return name2 === "address" || name2 === "bool" || name2 === "function" || name2 === "string" || name2 === "tuple" || bytesRegex.test(name2) || integerRegex.test(name2) || protectedKeywordsRegex.test(name2);
}
function isValidDataLocation(type, isArray) {
  return isArray || type === "bytes" || type === "string" || type === "tuple";
}
function parseStructs(signatures) {
  const shallowStructs = {};
  const signaturesLength = signatures.length;
  for (let i = 0; i < signaturesLength; i++) {
    const signature = signatures[i];
    if (!isStructSignature(signature))
      continue;
    const match = execStructSignature(signature);
    if (!match)
      throw new BaseError("Invalid struct signature.", {
        details: signature
      });
    const properties = match.properties.split(";");
    const components = [];
    const propertiesLength = properties.length;
    for (let k = 0; k < propertiesLength; k++) {
      const property = properties[k];
      const trimmed = property.trim();
      if (!trimmed)
        continue;
      const abiParameter = parseAbiParameter(trimmed, {
        type: "struct"
      });
      components.push(abiParameter);
    }
    if (!components.length)
      throw new BaseError("Invalid struct signature.", {
        details: signature,
        metaMessages: ["No properties exist."]
      });
    shallowStructs[match.name] = components;
  }
  const resolvedStructs = {};
  const entries = Object.entries(shallowStructs);
  const entriesLength = entries.length;
  for (let i = 0; i < entriesLength; i++) {
    const [name2, parameters] = entries[i];
    resolvedStructs[name2] = resolveStructs(parameters, shallowStructs);
  }
  return resolvedStructs;
}
var typeWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?$/;
function resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */ new Set()) {
  var _a16;
  const components = [];
  const length = abiParameters.length;
  for (let i = 0; i < length; i++) {
    const abiParameter = abiParameters[i];
    const isTuple = isTupleRegex.test(abiParameter.type);
    if (isTuple)
      components.push(abiParameter);
    else {
      const match = execTyped(
        typeWithoutTupleRegex,
        abiParameter.type
      );
      if (!(match == null ? void 0 : match.type))
        throw new BaseError("Invalid ABI parameter.", {
          details: JSON.stringify(abiParameter, null, 2),
          metaMessages: ["ABI parameter type is invalid."]
        });
      const { array, type } = match;
      if (type in structs) {
        if (ancestors.has(type))
          throw new BaseError("Circular reference detected.", {
            metaMessages: [`Struct "${type}" is a circular reference.`]
          });
        components.push({
          ...abiParameter,
          type: `tuple${array != null ? array : ""}`,
          components: resolveStructs(
            (_a16 = structs[type]) != null ? _a16 : [],
            structs,
            /* @__PURE__ */ new Set([...ancestors, type])
          )
        });
      } else {
        if (isSolidityType(type))
          components.push(abiParameter);
        else
          throw new BaseError("Unknown type.", {
            metaMessages: [
              `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
            ]
          });
      }
    }
  }
  return components;
}
function parseAbiParameter2(param) {
  let abiParameter;
  if (typeof param === "string")
    abiParameter = parseAbiParameter(param, {
      modifiers
    });
  else {
    const structs = parseStructs(param);
    const length = param.length;
    for (let i = 0; i < length; i++) {
      const signature = param[i];
      if (isStructSignature(signature))
        continue;
      abiParameter = parseAbiParameter(signature, { modifiers, structs });
      break;
    }
  }
  if (!abiParameter)
    throw new BaseError("Failed to parse ABI parameter.", {
      details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,
      docsPath: "/api/human.html#parseabiparameter-1"
    });
  return abiParameter;
}

// node_modules/web3-eth-abi/lib/esm/coders/utils.js
var WORD_SIZE = 32;
function alloc(size = 0) {
  var _a16;
  if (((_a16 = globalThis.Buffer) === null || _a16 === void 0 ? void 0 : _a16.alloc) !== void 0) {
    const buf = globalThis.Buffer.alloc(size);
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return new Uint8Array(size);
}
function convertExternalAbiParameter(abiParam) {
  var _a16, _b;
  return Object.assign(Object.assign({}, abiParam), { name: (_a16 = abiParam.name) !== null && _a16 !== void 0 ? _a16 : "", components: (_b = abiParam.components) === null || _b === void 0 ? void 0 : _b.map((c) => convertExternalAbiParameter(c)) });
}
function isAbiParameter(param) {
  return !isNullish6(param) && typeof param === "object" && !isNullish6(param.type) && typeof param.type === "string";
}
function toAbiParams(abi) {
  return abi.map((input) => {
    var _a16;
    if (isAbiParameter(input)) {
      return input;
    }
    if (typeof input === "string") {
      return convertExternalAbiParameter(parseAbiParameter2(input.replace(/tuple/, "")));
    }
    if (isSimplifiedStructFormat(input)) {
      const structName = Object.keys(input)[0];
      const structInfo = mapStructNameAndType(structName);
      structInfo.name = (_a16 = structInfo.name) !== null && _a16 !== void 0 ? _a16 : "";
      return Object.assign(Object.assign({}, structInfo), { components: mapStructToCoderFormat(input[structName]) });
    }
    throw new AbiError("Invalid abi");
  });
}
function extractArrayType(param) {
  const arrayParenthesisStart = param.type.lastIndexOf("[");
  const arrayParamType = param.type.substring(0, arrayParenthesisStart);
  const sizeString = param.type.substring(arrayParenthesisStart);
  let size = -1;
  if (sizeString !== "[]") {
    size = Number(sizeString.slice(1, -1));
    if (isNaN(size)) {
      throw new AbiError("Invalid fixed array size", { size: sizeString });
    }
  }
  return {
    param: { type: arrayParamType, name: "", components: param.components },
    size
  };
}
function isDynamic(param) {
  var _a16, _b;
  if (param.type === "string" || param.type === "bytes" || param.type.endsWith("[]"))
    return true;
  if (param.type === "tuple") {
    return (_b = (_a16 = param.components) === null || _a16 === void 0 ? void 0 : _a16.some(isDynamic)) !== null && _b !== void 0 ? _b : false;
  }
  if (param.type.endsWith("]")) {
    return isDynamic(extractArrayType(param).param);
  }
  return false;
}

// node_modules/web3-eth-abi/lib/esm/coders/base/address.js
var ADDRESS_BYTES_COUNT = 20;
var ADDRESS_OFFSET = WORD_SIZE - ADDRESS_BYTES_COUNT;
function encodeAddress(param, input) {
  if (typeof input !== "string") {
    throw new AbiError("address type expects string as input type", {
      value: input,
      name: param.name,
      type: param.type
    });
  }
  let address = input.toLowerCase();
  if (!address.startsWith("0x")) {
    address = `0x${address}`;
  }
  if (!isAddress(address)) {
    throw new AbiError("provided input is not valid address", {
      value: input,
      name: param.name,
      type: param.type
    });
  }
  const addressBytes = utils_exports.hexToUint8Array(address);
  const encoded = alloc(WORD_SIZE);
  encoded.set(addressBytes, ADDRESS_OFFSET);
  return {
    dynamic: false,
    encoded
  };
}
function decodeAddress(_param, bytes) {
  const addressBytes = bytes.subarray(ADDRESS_OFFSET, WORD_SIZE);
  if (addressBytes.length !== ADDRESS_BYTES_COUNT) {
    throw new AbiError("Invalid decoding input, not enough bytes to decode address", { bytes });
  }
  const result = utils_exports.uint8ArrayToHexString(addressBytes);
  return {
    result: toChecksumAddress5(result),
    encoded: bytes.subarray(WORD_SIZE),
    consumed: WORD_SIZE
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/base/bool.js
init_shim();

// node_modules/web3-eth-abi/lib/esm/coders/base/number.js
init_shim();

// node_modules/web3-eth-abi/lib/esm/coders/base/numbersLimits.js
init_shim();
var numberLimits = /* @__PURE__ */ new Map();
var base = BigInt(256);
for (let i = 8; i <= 256; i += 8) {
  numberLimits.set(`uint${i}`, {
    min: BigInt(0),
    max: base - BigInt(1)
  });
  numberLimits.set(`int${i}`, {
    min: -base / BigInt(2),
    max: base / BigInt(2) - BigInt(1)
  });
  base *= BigInt(256);
}
numberLimits.set(`int`, numberLimits.get("int256"));
numberLimits.set(`uint`, numberLimits.get("uint256"));

// node_modules/web3-eth-abi/lib/esm/coders/base/number.js
var mask = BigInt(1) << BigInt(256);
function bigIntToUint8Array2(value, byteLength = WORD_SIZE) {
  let hexValue;
  if (value < 0) {
    hexValue = (mask + value).toString(16);
  } else {
    hexValue = value.toString(16);
  }
  hexValue = padLeft6(hexValue, byteLength * 2);
  return utils_exports.hexToUint8Array(hexValue);
}
function uint8ArrayToBigInt2(value, max) {
  const hexValue = utils_exports.uint8ArrayToHexString(value);
  const result = BigInt(hexValue);
  if (result <= max)
    return result;
  return result - mask;
}
function encodeNumber(param, input) {
  let value;
  try {
    value = toBigInt5(input);
  } catch (e) {
    throw new AbiError("provided input is not number value", {
      type: param.type,
      value: input,
      name: param.name
    });
  }
  const limit = numberLimits.get(param.type);
  if (!limit) {
    throw new AbiError("provided abi contains invalid number datatype", { type: param.type });
  }
  if (value < limit.min) {
    throw new AbiError("provided input is less then minimum for given type", {
      type: param.type,
      value: input,
      name: param.name,
      minimum: limit.min.toString()
    });
  }
  if (value > limit.max) {
    throw new AbiError("provided input is greater then maximum for given type", {
      type: param.type,
      value: input,
      name: param.name,
      maximum: limit.max.toString()
    });
  }
  return {
    dynamic: false,
    encoded: bigIntToUint8Array2(value)
  };
}
function decodeNumber(param, bytes) {
  if (bytes.length < WORD_SIZE) {
    throw new AbiError("Not enough bytes left to decode", { param, bytesLeft: bytes.length });
  }
  const boolBytes = bytes.subarray(0, WORD_SIZE);
  const limit = numberLimits.get(param.type);
  if (!limit) {
    throw new AbiError("provided abi contains invalid number datatype", { type: param.type });
  }
  const numberResult = uint8ArrayToBigInt2(boolBytes, limit.max);
  if (numberResult < limit.min) {
    throw new AbiError("decoded value is less then minimum for given type", {
      type: param.type,
      value: numberResult,
      name: param.name,
      minimum: limit.min.toString()
    });
  }
  if (numberResult > limit.max) {
    throw new AbiError("decoded value is greater then maximum for given type", {
      type: param.type,
      value: numberResult,
      name: param.name,
      maximum: limit.max.toString()
    });
  }
  return {
    result: numberResult,
    encoded: bytes.subarray(WORD_SIZE),
    consumed: WORD_SIZE
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/base/bool.js
function encodeBoolean(param, input) {
  let value;
  try {
    value = toBool2(input);
  } catch (e) {
    if (e instanceof InvalidBooleanError) {
      throw new AbiError("provided input is not valid boolean value", {
        type: param.type,
        value: input,
        name: param.name
      });
    }
  }
  return encodeNumber({ type: "uint8", name: "" }, Number(value));
}
function decodeBool(_param, bytes) {
  const numberResult = decodeNumber({ type: "uint8", name: "" }, bytes);
  if (numberResult.result > 1 || numberResult.result < 0) {
    throw new AbiError("Invalid boolean value encoded", {
      boolBytes: bytes.subarray(0, WORD_SIZE),
      numberResult
    });
  }
  return {
    result: numberResult.result === BigInt(1),
    encoded: numberResult.encoded,
    consumed: WORD_SIZE
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/base/bytes.js
init_shim();
var MAX_STATIC_BYTES_COUNT = 32;
function encodeBytes(param, input) {
  if (typeof input === "string" && input.length % 2 !== 0) {
    input += "0";
  }
  if (!isBytes(input)) {
    throw new AbiError("provided input is not valid bytes value", {
      type: param.type,
      value: input,
      name: param.name
    });
  }
  const bytes = bytesToUint8Array5(input);
  const [, size] = param.type.split("bytes");
  if (size) {
    if (Number(size) > MAX_STATIC_BYTES_COUNT || Number(size) < 1) {
      throw new AbiError("invalid bytes type. Static byte type can have between 1 and 32 bytes", {
        type: param.type
      });
    }
    if (Number(size) < bytes.length) {
      throw new AbiError("provided input size is different than type size", {
        type: param.type,
        value: input,
        name: param.name
      });
    }
    const encoded2 = alloc(WORD_SIZE);
    encoded2.set(bytes);
    return {
      dynamic: false,
      encoded: encoded2
    };
  }
  const partsLength = Math.ceil(bytes.length / WORD_SIZE);
  const encoded = alloc(WORD_SIZE + partsLength * WORD_SIZE);
  encoded.set(encodeNumber({ type: "uint32", name: "" }, bytes.length).encoded);
  encoded.set(bytes, WORD_SIZE);
  return {
    dynamic: true,
    encoded
  };
}
function decodeBytes(param, bytes) {
  const [, sizeString] = param.type.split("bytes");
  let size = Number(sizeString);
  let remainingBytes = bytes;
  let partsCount = 1;
  let consumed = 0;
  if (!size) {
    const result = decodeNumber({ type: "uint32", name: "" }, remainingBytes);
    size = Number(result.result);
    consumed += result.consumed;
    remainingBytes = result.encoded;
    partsCount = Math.ceil(size / WORD_SIZE);
  }
  if (size > bytes.length) {
    throw new AbiError("there is not enough data to decode", {
      type: param.type,
      encoded: bytes,
      size
    });
  }
  return {
    result: bytesToHex6(remainingBytes.subarray(0, size)),
    encoded: remainingBytes.subarray(partsCount * WORD_SIZE),
    consumed: consumed + partsCount * WORD_SIZE
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/base/string.js
init_shim();
function encodeString(_param, input) {
  if (typeof input !== "string") {
    throw new AbiError("invalid input, should be string", { input });
  }
  const bytes = utf8ToBytes6(input);
  return encodeBytes({ type: "bytes", name: "" }, bytes);
}
function decodeString(_param, bytes) {
  const r = decodeBytes({ type: "bytes", name: "" }, bytes);
  return {
    result: hexToUtf84(r.result),
    encoded: r.encoded,
    consumed: r.consumed
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/base/array.js
init_shim();

// node_modules/web3-eth-abi/lib/esm/coders/base/utils.js
init_shim();
function encodeDynamicParams(encodedParams) {
  let staticSize = 0;
  let dynamicSize = 0;
  const staticParams = [];
  const dynamicParams = [];
  for (const encodedParam of encodedParams) {
    if (encodedParam.dynamic) {
      staticSize += WORD_SIZE;
    } else {
      staticSize += encodedParam.encoded.length;
    }
  }
  for (const encodedParam of encodedParams) {
    if (encodedParam.dynamic) {
      staticParams.push(encodeNumber({ type: "uint256", name: "" }, staticSize + dynamicSize));
      dynamicParams.push(encodedParam);
      dynamicSize += encodedParam.encoded.length;
    } else {
      staticParams.push(encodedParam);
    }
  }
  return uint8ArrayConcat5(...staticParams.map((p) => p.encoded), ...dynamicParams.map((p) => p.encoded));
}

// node_modules/web3-eth-abi/lib/esm/coders/base/array.js
function encodeArray(param, values) {
  if (!Array.isArray(values)) {
    throw new AbiError("Expected value to be array", { abi: param, values });
  }
  const { size, param: arrayItemParam } = extractArrayType(param);
  const encodedParams = values.map((v) => encodeParamFromAbiParameter(arrayItemParam, v));
  const dynamic = size === -1;
  const dynamicItems = encodedParams.length > 0 && encodedParams[0].dynamic;
  if (!dynamic && values.length !== size) {
    throw new AbiError("Given arguments count doesn't match array length", {
      arrayLength: size,
      argumentsLength: values.length
    });
  }
  if (dynamic || dynamicItems) {
    const encodingResult = encodeDynamicParams(encodedParams);
    if (dynamic) {
      const encodedLength = encodeNumber({ type: "uint256", name: "" }, encodedParams.length).encoded;
      return {
        dynamic: true,
        encoded: encodedParams.length > 0 ? uint8ArrayConcat5(encodedLength, encodingResult) : encodedLength
      };
    }
    return {
      dynamic: true,
      encoded: encodingResult
    };
  }
  return {
    dynamic: false,
    encoded: uint8ArrayConcat5(...encodedParams.map((p) => p.encoded))
  };
}
function decodeArray(param, bytes) {
  let { size, param: arrayItemParam } = extractArrayType(param);
  const dynamic = size === -1;
  let consumed = 0;
  const result = [];
  let remaining = bytes;
  if (dynamic) {
    const lengthResult = decodeNumber({ type: "uint32", name: "" }, bytes);
    size = Number(lengthResult.result);
    consumed = lengthResult.consumed;
    remaining = lengthResult.encoded;
  }
  const hasDynamicChild = isDynamic(arrayItemParam);
  if (hasDynamicChild) {
    for (let i = 0; i < size; i += 1) {
      const offsetResult = decodeNumber({ type: "uint32", name: "" }, remaining.subarray(i * WORD_SIZE));
      consumed += offsetResult.consumed;
      const decodedChildResult = decodeParamFromAbiParameter(arrayItemParam, remaining.subarray(Number(offsetResult.result)));
      consumed += decodedChildResult.consumed;
      result.push(decodedChildResult.result);
    }
    return {
      result,
      encoded: remaining.subarray(consumed),
      consumed
    };
  }
  for (let i = 0; i < size; i += 1) {
    const decodedChildResult = decodeParamFromAbiParameter(arrayItemParam, bytes.subarray(consumed));
    consumed += decodedChildResult.consumed;
    result.push(decodedChildResult.result);
  }
  return {
    result,
    encoded: bytes.subarray(consumed),
    consumed
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/base/index.js
function encodeParamFromAbiParameter(param, value) {
  if (param.type === "string") {
    return encodeString(param, value);
  }
  if (param.type === "bool") {
    return encodeBoolean(param, value);
  }
  if (param.type === "address") {
    return encodeAddress(param, value);
  }
  if (param.type === "tuple") {
    return encodeTuple(param, value);
  }
  if (param.type.endsWith("]")) {
    return encodeArray(param, value);
  }
  if (param.type.startsWith("bytes")) {
    return encodeBytes(param, value);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    return encodeNumber(param, value);
  }
  throw new Error("Unsupported");
}
function decodeParamFromAbiParameter(param, bytes) {
  if (param.type === "string") {
    return decodeString(param, bytes);
  }
  if (param.type === "bool") {
    return decodeBool(param, bytes);
  }
  if (param.type === "address") {
    return decodeAddress(param, bytes);
  }
  if (param.type === "tuple") {
    return decodeTuple(param, bytes);
  }
  if (param.type.endsWith("]")) {
    return decodeArray(param, bytes);
  }
  if (param.type.startsWith("bytes")) {
    return decodeBytes(param, bytes);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    return decodeNumber(param, bytes);
  }
  throw new Error("Unsupported");
}

// node_modules/web3-eth-abi/lib/esm/coders/base/tuple.js
function encodeTuple(param, input) {
  var _a16, _b, _c;
  let dynamic = false;
  if (!Array.isArray(input) && typeof input !== "object") {
    throw new AbiError("param must be either Array or Object", {
      param,
      input
    });
  }
  const narrowedInput = input;
  const encoded = [];
  for (let i = 0; i < ((_b = (_a16 = param.components) === null || _a16 === void 0 ? void 0 : _a16.length) !== null && _b !== void 0 ? _b : 0); i += 1) {
    const paramComponent = param.components[i];
    let result;
    if (Array.isArray(narrowedInput)) {
      if (i >= narrowedInput.length) {
        throw new AbiError("input param length missmatch", {
          param,
          input
        });
      }
      result = encodeParamFromAbiParameter(paramComponent, narrowedInput[i]);
    } else {
      const paramInput = narrowedInput[(_c = paramComponent.name) !== null && _c !== void 0 ? _c : ""];
      if (paramInput === void 0 || paramInput === null) {
        throw new AbiError("missing input defined in abi", {
          param,
          input,
          paramName: paramComponent.name
        });
      }
      result = encodeParamFromAbiParameter(paramComponent, paramInput);
    }
    if (result.dynamic) {
      dynamic = true;
    }
    encoded.push(result);
  }
  if (dynamic) {
    return {
      dynamic: true,
      encoded: encodeDynamicParams(encoded)
    };
  }
  return {
    dynamic: false,
    encoded: uint8ArrayConcat5(...encoded.map((e) => e.encoded))
  };
}
function decodeTuple(param, bytes) {
  const result = {
    __length__: 0
  };
  let consumed = 0;
  if (!param.components) {
    return {
      result,
      encoded: bytes,
      consumed
    };
  }
  let dynamicConsumed = 0;
  for (const [index, childParam] of param.components.entries()) {
    let decodedResult;
    if (isDynamic(childParam)) {
      const offsetResult = decodeNumber({ type: "uint32", name: "" }, bytes.subarray(consumed));
      decodedResult = decodeParamFromAbiParameter(childParam, bytes.subarray(Number(offsetResult.result)));
      consumed += offsetResult.consumed;
      dynamicConsumed += decodedResult.consumed;
    } else {
      decodedResult = decodeParamFromAbiParameter(childParam, bytes.subarray(consumed));
      consumed += decodedResult.consumed;
    }
    result.__length__ += 1;
    result[index] = decodedResult.result;
    if (childParam.name && childParam.name !== "") {
      result[childParam.name] = decodedResult.result;
    }
  }
  return {
    encoded: bytes.subarray(consumed + dynamicConsumed),
    result,
    consumed: consumed + dynamicConsumed
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/decode.js
function decodeParameters(abis, bytes, _loose) {
  const abiParams = toAbiParams(abis);
  const bytesArray = utils_exports.hexToUint8Array(bytes);
  return decodeTuple({ type: "tuple", name: "", components: abiParams }, bytesArray).result;
}

// node_modules/web3-eth-abi/lib/esm/coders/encode.js
init_shim();
function encodeParameters(abi, params) {
  if (abi.length !== params.length) {
    throw new AbiError("Invalid number of values received for given ABI", {
      expected: abi.length,
      received: params.length
    });
  }
  const abiParams = toAbiParams(abi);
  return utils_exports.uint8ArrayToHexString(encodeTuple({ type: "tuple", name: "", components: abiParams }, params).encoded);
}

// node_modules/web3-eth-abi/lib/esm/api/parameters_api.js
var encodeParameters2 = (abi, params) => encodeParameters(abi, params);
var encodeParameter = (abi, param) => encodeParameters2([abi], [param]);
var decodeParametersWith = (abis, bytes, loose) => {
  try {
    if (abis.length > 0 && (!bytes || bytes === "0x" || bytes === "0X")) {
      throw new AbiError("Returned values aren't valid, did it run Out of Gas? You might also see this error if you are not using the correct ABI for the contract you are retrieving data from, requesting data from a block number that does not exist, or querying a node which is not fully synced.");
    }
    return decodeParameters(abis, `0x${bytes.replace(/0x/i, "")}`, loose);
  } catch (err) {
    throw new AbiError(`Parameter decoding error: ${err.message}`, {
      internalErr: err
    });
  }
};
var decodeParameters2 = (abi, bytes) => decodeParametersWith(abi, bytes, false);
var decodeParameter = (abi, bytes) => decodeParameters2([abi], bytes)["0"];

// node_modules/web3-eth-abi/lib/esm/api/functions_api.js
var encodeFunctionSignature = (functionName) => {
  if (typeof functionName !== "string" && !isAbiFunctionFragment(functionName)) {
    throw new AbiError("Invalid parameter value in encodeFunctionSignature");
  }
  let name2;
  if (functionName && (typeof functionName === "function" || typeof functionName === "object")) {
    name2 = jsonInterfaceMethodToString(functionName);
  } else {
    name2 = functionName;
  }
  return sha3Raw5(name2).slice(0, 10);
};
var encodeFunctionCall = (jsonInterface, params) => {
  var _a16;
  if (!isAbiFunctionFragment(jsonInterface)) {
    throw new AbiError("Invalid parameter value in encodeFunctionCall");
  }
  return `${encodeFunctionSignature(jsonInterface)}${encodeParameters2((_a16 = jsonInterface.inputs) !== null && _a16 !== void 0 ? _a16 : [], params !== null && params !== void 0 ? params : []).replace("0x", "")}`;
};

// node_modules/web3-eth-abi/lib/esm/api/logs_api.js
init_shim();
var STATIC_TYPES = ["bool", "string", "int", "uint", "address", "fixed", "ufixed"];
var _decodeParameter = (inputType, clonedTopic) => inputType === "string" ? clonedTopic : decodeParameter(inputType, clonedTopic);
var decodeLog = (inputs, data, topics) => {
  const clonedTopics = Array.isArray(topics) ? topics : [topics];
  const indexedInputs = {};
  const nonIndexedInputs = {};
  for (const [i, input] of inputs.entries()) {
    if (input.indexed) {
      indexedInputs[i] = input;
    } else {
      nonIndexedInputs[i] = input;
    }
  }
  const decodedNonIndexedInputs = data ? decodeParametersWith(Object.values(nonIndexedInputs), data, true) : { __length__: 0 };
  const offset = clonedTopics.length - Object.keys(indexedInputs).length;
  const decodedIndexedInputs = Object.values(indexedInputs).map((input, index) => STATIC_TYPES.some((s) => input.type.startsWith(s)) ? _decodeParameter(input.type, clonedTopics[index + offset]) : clonedTopics[index + offset]);
  const returnValues = { __length__: 0 };
  let indexedCounter = 0;
  let nonIndexedCounter = 0;
  for (const [i, res] of inputs.entries()) {
    returnValues[i] = res.type === "string" ? "" : void 0;
    if (indexedInputs[i]) {
      returnValues[i] = decodedIndexedInputs[indexedCounter];
      indexedCounter += 1;
    }
    if (nonIndexedInputs[i]) {
      returnValues[i] = decodedNonIndexedInputs[String(nonIndexedCounter)];
      nonIndexedCounter += 1;
    }
    if (res.name) {
      returnValues[res.name] = returnValues[i];
    }
    returnValues.__length__ += 1;
  }
  return returnValues;
};

// node_modules/web3-eth-abi/lib/esm/decode_contract_error_data.js
init_shim();
var decodeContractErrorData = (errorsAbi, error) => {
  if (error === null || error === void 0 ? void 0 : error.data) {
    let errorName;
    let errorSignature;
    let errorArgs;
    try {
      const errorSha = error.data.slice(0, 10);
      const errorAbi = errorsAbi.find((abi) => encodeErrorSignature(abi).startsWith(errorSha));
      if (errorAbi === null || errorAbi === void 0 ? void 0 : errorAbi.inputs) {
        errorName = errorAbi.name;
        errorSignature = jsonInterfaceMethodToString(errorAbi);
        errorArgs = decodeParameters2([...errorAbi.inputs], error.data.substring(10));
      }
    } catch (err) {
      console.error(err);
    }
    if (errorName) {
      error.setDecodedProperties(errorName, errorSignature, errorArgs);
    }
  }
};

// node_modules/web3-eth-abi/lib/esm/eip_712.js
init_shim();
var TYPE_REGEX = /^\w+/;
var ARRAY_REGEX = /^(.*)\[([0-9]*?)]$/;
var getDependencies = (typedData, type, dependencies = []) => {
  const match = type.match(TYPE_REGEX);
  const actualType = match[0];
  if (dependencies.includes(actualType)) {
    return dependencies;
  }
  if (!typedData.types[actualType]) {
    return dependencies;
  }
  return [
    actualType,
    ...typedData.types[actualType].reduce((previous, _type) => [
      ...previous,
      ...getDependencies(typedData, _type.type, previous).filter((dependency) => !previous.includes(dependency))
    ], [])
  ];
};
var encodeType = (typedData, type) => {
  const [primary, ...dependencies] = getDependencies(typedData, type);
  const types = [primary, ...dependencies.sort()];
  return types.map((dependency) => `${dependency}(${typedData.types[dependency].map((_type) => `${_type.type} ${_type.name}`)})`).join("");
};
var getTypeHash = (typedData, type) => keccak256Wrapper3(encodeType(typedData, type));
var getStructHash = (typedData, type, data) => keccak256Wrapper3(encodeData(typedData, type, data));
var getMessage = (typedData, hash) => {
  const EIP_191_PREFIX = "1901";
  const message = `0x${EIP_191_PREFIX}${getStructHash(typedData, "EIP712Domain", typedData.domain).substring(2)}${getStructHash(typedData, typedData.primaryType, typedData.message).substring(2)}`;
  if (hash) {
    return keccak256Wrapper3(message);
  }
  return message;
};
var encodeValue = (typedData, type, data) => {
  const match = type.match(ARRAY_REGEX);
  if (match) {
    const arrayType = match[1];
    const length = Number(match[2]) || void 0;
    if (!Array.isArray(data)) {
      throw new Error("Cannot encode data: value is not of array type");
    }
    if (length && data.length !== length) {
      throw new Error(`Cannot encode data: expected length of ${length}, but got ${data.length}`);
    }
    const encodedData = data.map((item) => encodeValue(typedData, arrayType, item));
    const types = encodedData.map((item) => item[0]);
    const values = encodedData.map((item) => item[1]);
    return ["bytes32", keccak256Wrapper3(encodeParameters(types, values))];
  }
  if (typedData.types[type]) {
    return ["bytes32", getStructHash(typedData, type, data)];
  }
  if (type === "string") {
    return ["bytes32", keccak256Wrapper3(data)];
  }
  if (type === "bytes") {
    return ["bytes32", keccak256Wrapper3(data)];
  }
  return [type, data];
};
var encodeData = (typedData, type, data) => {
  const [types, values] = typedData.types[type].reduce(([_types, _values], field) => {
    if (isNullish6(data[field.name]) || isNullish6(data[field.name])) {
      throw new Error(`Cannot encode data: missing data for '${field.name}'`);
    }
    const value = data[field.name];
    const [_type, encodedValue] = encodeValue(typedData, field.type, value);
    return [
      [..._types, _type],
      [..._values, encodedValue]
    ];
  }, [["bytes32"], [getTypeHash(typedData, type)]]);
  return encodeParameters(types, values);
};

// node_modules/web3-eth/lib/esm/utils/get_revert_reason.js
var __awaiter51 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var parseTransactionError = (error, contractAbi) => {
  var _a16, _b, _c, _d;
  if (error instanceof ContractExecutionError && error.innerError instanceof Eip838ExecutionError) {
    if (contractAbi !== void 0) {
      const errorsAbi = contractAbi.filter((abi) => isAbiErrorFragment(abi));
      decodeContractErrorData(errorsAbi, error.innerError);
      return {
        reason: error.innerError.message,
        signature: (_a16 = error.innerError.data) === null || _a16 === void 0 ? void 0 : _a16.slice(0, 10),
        data: (_b = error.innerError.data) === null || _b === void 0 ? void 0 : _b.substring(10),
        customErrorName: error.innerError.errorName,
        customErrorDecodedSignature: error.innerError.errorSignature,
        customErrorArguments: error.innerError.errorArgs
      };
    }
    return {
      reason: error.innerError.message,
      signature: (_c = error.innerError.data) === null || _c === void 0 ? void 0 : _c.slice(0, 10),
      data: (_d = error.innerError.data) === null || _d === void 0 ? void 0 : _d.substring(10)
    };
  }
  if (error instanceof InvalidResponseError && !Array.isArray(error.innerError) && error.innerError !== void 0) {
    return error.innerError.message;
  }
  throw error;
};
function getRevertReason(web3Context, transaction, contractAbi, returnFormat = DEFAULT_RETURN_FORMAT) {
  return __awaiter51(this, void 0, void 0, function* () {
    try {
      yield call2(web3Context, transaction, web3Context.defaultBlock, returnFormat);
      return void 0;
    } catch (error) {
      return parseTransactionError(error, contractAbi);
    }
  });
}

// node_modules/web3-eth/lib/esm/utils/get_transaction_error.js
var __awaiter52 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getTransactionError(web3Context, transactionFormatted, transactionReceiptFormatted, receivedError, contractAbi, knownReason) {
  return __awaiter52(this, void 0, void 0, function* () {
    let _reason = knownReason;
    if (_reason === void 0) {
      if (receivedError !== void 0) {
        _reason = parseTransactionError(receivedError);
      } else if (web3Context.handleRevert && transactionFormatted !== void 0) {
        _reason = yield getRevertReason(web3Context, transactionFormatted, contractAbi);
      }
    }
    let error;
    if (_reason === void 0) {
      error = new TransactionRevertedWithoutReasonError(transactionReceiptFormatted);
    } else if (typeof _reason === "string") {
      error = new TransactionRevertInstructionError(_reason, void 0, transactionReceiptFormatted);
    } else if (_reason.customErrorName !== void 0 && _reason.customErrorDecodedSignature !== void 0 && _reason.customErrorArguments !== void 0) {
      const reasonWithCustomError = _reason;
      error = new TransactionRevertWithCustomError(reasonWithCustomError.reason, reasonWithCustomError.customErrorName, reasonWithCustomError.customErrorDecodedSignature, reasonWithCustomError.customErrorArguments, reasonWithCustomError.signature, transactionReceiptFormatted, reasonWithCustomError.data);
    } else {
      error = new TransactionRevertInstructionError(_reason.reason, _reason.signature, transactionReceiptFormatted, _reason.data);
    }
    return error;
  });
}

// node_modules/web3-eth/lib/esm/utils/decoding.js
init_shim();
var decodeEventABI = (event, data, jsonInterface, returnFormat = DEFAULT_RETURN_FORMAT) => {
  var _a16, _b, _c, _d, _e;
  let modifiedEvent = Object.assign({}, event);
  const result = format2(logSchema, data, returnFormat);
  if ([ALL_EVENTS, "allEvents"].includes(modifiedEvent.name)) {
    const matchedEvent = jsonInterface.find((j) => j.signature === data.topics[0]);
    if (matchedEvent) {
      modifiedEvent = matchedEvent;
    } else {
      modifiedEvent = { anonymous: true };
    }
  }
  modifiedEvent.inputs = (_b = (_a16 = modifiedEvent.inputs) !== null && _a16 !== void 0 ? _a16 : event.inputs) !== null && _b !== void 0 ? _b : [];
  if (!modifiedEvent.anonymous) {
    let indexedInputs = 0;
    ((_c = modifiedEvent.inputs) !== null && _c !== void 0 ? _c : []).forEach((input) => {
      if (input.indexed) {
        indexedInputs += 1;
      }
    });
    if (indexedInputs > 0 && (data === null || data === void 0 ? void 0 : data.topics) && (data === null || data === void 0 ? void 0 : data.topics.length) !== indexedInputs + 1) {
      modifiedEvent = Object.assign(Object.assign({}, modifiedEvent), { anonymous: true, inputs: [] });
    }
  }
  const argTopics = modifiedEvent.anonymous ? data.topics : ((_d = data.topics) !== null && _d !== void 0 ? _d : []).slice(1);
  return Object.assign(Object.assign({}, result), { returnValues: decodeLog([...(_e = modifiedEvent.inputs) !== null && _e !== void 0 ? _e : []], data.data, argTopics), event: modifiedEvent.name, signature: modifiedEvent.anonymous || !data.topics || data.topics.length === 0 || !data.topics[0] ? void 0 : data.topics[0], raw: {
    data: data.data,
    topics: data.topics
  } });
};

// node_modules/web3-eth/lib/esm/utils/send_tx_helper.js
var __awaiter53 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SendTxHelper = class {
  constructor({ options, web3Context, promiEvent, returnFormat }) {
    this.options = {
      checkRevertBeforeSending: true
    };
    this.options = options;
    this.web3Context = web3Context;
    this.promiEvent = promiEvent;
    this.returnFormat = returnFormat;
  }
  getReceiptWithEvents(data) {
    var _a16, _b;
    const result = Object.assign({}, data !== null && data !== void 0 ? data : {});
    if (((_a16 = this.options) === null || _a16 === void 0 ? void 0 : _a16.contractAbi) && result.logs && result.logs.length > 0) {
      result.events = {};
      for (const log of result.logs) {
        const event = decodeEventABI(ALL_EVENTS_ABI, log, (_b = this.options) === null || _b === void 0 ? void 0 : _b.contractAbi, this.returnFormat);
        if (event.event) {
          result.events[event.event] = event;
        }
      }
    }
    return result;
  }
  checkRevertBeforeSending(tx) {
    return __awaiter53(this, void 0, void 0, function* () {
      if (this.options.checkRevertBeforeSending !== false) {
        const reason = yield getRevertReason(this.web3Context, tx, this.options.contractAbi);
        if (reason !== void 0) {
          throw yield getTransactionError(this.web3Context, tx, void 0, void 0, this.options.contractAbi, reason);
        }
      }
    });
  }
  emitSending(tx) {
    if (this.promiEvent.listenerCount("sending") > 0) {
      this.promiEvent.emit("sending", tx);
    }
  }
  populateGasPrice({ transactionFormatted, transaction }) {
    var _a16;
    return __awaiter53(this, void 0, void 0, function* () {
      let result = transactionFormatted;
      if (!((_a16 = this.options) === null || _a16 === void 0 ? void 0 : _a16.ignoreGasPricing) && isNullish(transactionFormatted.gasPrice) && (isNullish(transaction.maxPriorityFeePerGas) || isNullish(transaction.maxFeePerGas))) {
        result = Object.assign(Object.assign({}, transactionFormatted), yield getTransactionGasPricing(transactionFormatted, this.web3Context, ETH_DATA_FORMAT));
      }
      return result;
    });
  }
  signAndSend({ wallet, tx }) {
    return __awaiter53(this, void 0, void 0, function* () {
      if (wallet) {
        const signedTransaction = yield wallet.signTransaction(tx);
        return trySendTransaction(this.web3Context, () => __awaiter53(this, void 0, void 0, function* () {
          return eth_rpc_methods_exports.sendRawTransaction(this.web3Context.requestManager, signedTransaction.rawTransaction);
        }), signedTransaction.transactionHash);
      }
      return trySendTransaction(this.web3Context, () => __awaiter53(this, void 0, void 0, function* () {
        return eth_rpc_methods_exports.sendTransaction(this.web3Context.requestManager, tx);
      }));
    });
  }
  emitSent(tx) {
    if (this.promiEvent.listenerCount("sent") > 0) {
      this.promiEvent.emit("sent", tx);
    }
  }
  emitTransactionHash(hash) {
    if (this.promiEvent.listenerCount("transactionHash") > 0) {
      this.promiEvent.emit("transactionHash", hash);
    }
  }
  emitReceipt(receipt) {
    if (this.promiEvent.listenerCount("receipt") > 0) {
      this.promiEvent.emit(
        "receipt",
        receipt
      );
    }
  }
  handleError({ error, tx }) {
    var _a16;
    return __awaiter53(this, void 0, void 0, function* () {
      let _error = error;
      if (_error instanceof ContractExecutionError && this.web3Context.handleRevert) {
        _error = yield getTransactionError(this.web3Context, tx, void 0, void 0, (_a16 = this.options) === null || _a16 === void 0 ? void 0 : _a16.contractAbi);
      }
      if ((_error instanceof InvalidResponseError || _error instanceof ContractExecutionError || _error instanceof TransactionRevertWithCustomError || _error instanceof TransactionRevertedWithoutReasonError || _error instanceof TransactionRevertInstructionError) && this.promiEvent.listenerCount("error") > 0) {
        this.promiEvent.emit("error", _error);
      }
      return _error;
    });
  }
  emitConfirmation({ receipt, transactionHash }) {
    if (this.promiEvent.listenerCount("confirmation") > 0) {
      watchTransactionForConfirmations(this.web3Context, this.promiEvent, receipt, transactionHash, this.returnFormat);
    }
  }
  handleResolve({ receipt, tx }) {
    var _a16, _b, _c;
    return __awaiter53(this, void 0, void 0, function* () {
      if ((_a16 = this.options) === null || _a16 === void 0 ? void 0 : _a16.transactionResolver) {
        return (_b = this.options) === null || _b === void 0 ? void 0 : _b.transactionResolver(receipt);
      }
      if (receipt.status === BigInt(0)) {
        const error = yield getTransactionError(
          this.web3Context,
          tx,
          receipt,
          void 0,
          (_c = this.options) === null || _c === void 0 ? void 0 : _c.contractAbi
        );
        if (this.promiEvent.listenerCount("error") > 0) {
          this.promiEvent.emit("error", error);
        }
        throw error;
      } else {
        return receipt;
      }
    });
  }
};

// node_modules/web3-eth/lib/esm/rpc_method_wrappers.js
var __awaiter54 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var getProtocolVersion2 = (web3Context) => __awaiter54(void 0, void 0, void 0, function* () {
  return eth_rpc_methods_exports.getProtocolVersion(web3Context.requestManager);
});
var isSyncing = (web3Context) => __awaiter54(void 0, void 0, void 0, function* () {
  return eth_rpc_methods_exports.getSyncing(web3Context.requestManager);
});
var getCoinbase2 = (web3Context) => __awaiter54(void 0, void 0, void 0, function* () {
  return eth_rpc_methods_exports.getCoinbase(web3Context.requestManager);
});
var isMining = (web3Context) => __awaiter54(void 0, void 0, void 0, function* () {
  return eth_rpc_methods_exports.getMining(web3Context.requestManager);
});
function getHashRate2(web3Context, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    const response = yield eth_rpc_methods_exports.getHashRate(web3Context.requestManager);
    return format2({ format: "uint" }, response, returnFormat);
  });
}
function getGasPrice2(web3Context, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    const response = yield eth_rpc_methods_exports.getGasPrice(web3Context.requestManager);
    return format2({ format: "uint" }, response, returnFormat);
  });
}
function getBlockNumber2(web3Context, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    const response = yield eth_rpc_methods_exports.getBlockNumber(web3Context.requestManager);
    return format2({ format: "uint" }, response, returnFormat);
  });
}
function getBalance2(web3Context, address, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format2({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield eth_rpc_methods_exports.getBalance(web3Context.requestManager, address, blockNumberFormatted);
    return format2({ format: "uint" }, response, returnFormat);
  });
}
function getStorageAt2(web3Context, address, storageSlot, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    const storageSlotFormatted = format2({ format: "uint" }, storageSlot, ETH_DATA_FORMAT);
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format2({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield eth_rpc_methods_exports.getStorageAt(web3Context.requestManager, address, storageSlotFormatted, blockNumberFormatted);
    return format2({ format: "bytes" }, response, returnFormat);
  });
}
function getCode2(web3Context, address, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format2({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield eth_rpc_methods_exports.getCode(web3Context.requestManager, address, blockNumberFormatted);
    return format2({ format: "bytes" }, response, returnFormat);
  });
}
function getBlock(web3Context, block = web3Context.defaultBlock, hydrated = false, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    let response;
    if (isBytes(block)) {
      const blockHashFormatted = format2({ format: "bytes32" }, block, ETH_DATA_FORMAT);
      response = yield eth_rpc_methods_exports.getBlockByHash(web3Context.requestManager, blockHashFormatted, hydrated);
    } else {
      const blockNumberFormatted = isBlockTag(block) ? block : format2({ format: "uint" }, block, ETH_DATA_FORMAT);
      response = yield eth_rpc_methods_exports.getBlockByNumber(web3Context.requestManager, blockNumberFormatted, hydrated);
    }
    return format2(blockSchema, response, returnFormat);
  });
}
function getBlockTransactionCount(web3Context, block = web3Context.defaultBlock, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    let response;
    if (isBytes(block)) {
      const blockHashFormatted = format2({ format: "bytes32" }, block, ETH_DATA_FORMAT);
      response = yield eth_rpc_methods_exports.getBlockTransactionCountByHash(web3Context.requestManager, blockHashFormatted);
    } else {
      const blockNumberFormatted = isBlockTag(block) ? block : format2({ format: "uint" }, block, ETH_DATA_FORMAT);
      response = yield eth_rpc_methods_exports.getBlockTransactionCountByNumber(web3Context.requestManager, blockNumberFormatted);
    }
    return format2({ format: "uint" }, response, returnFormat);
  });
}
function getBlockUncleCount(web3Context, block = web3Context.defaultBlock, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    let response;
    if (isBytes(block)) {
      const blockHashFormatted = format2({ format: "bytes32" }, block, ETH_DATA_FORMAT);
      response = yield eth_rpc_methods_exports.getUncleCountByBlockHash(web3Context.requestManager, blockHashFormatted);
    } else {
      const blockNumberFormatted = isBlockTag(block) ? block : format2({ format: "uint" }, block, ETH_DATA_FORMAT);
      response = yield eth_rpc_methods_exports.getUncleCountByBlockNumber(web3Context.requestManager, blockNumberFormatted);
    }
    return format2({ format: "uint" }, response, returnFormat);
  });
}
function getUncle(web3Context, block = web3Context.defaultBlock, uncleIndex, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    const uncleIndexFormatted = format2({ format: "uint" }, uncleIndex, ETH_DATA_FORMAT);
    let response;
    if (isBytes(block)) {
      const blockHashFormatted = format2({ format: "bytes32" }, block, ETH_DATA_FORMAT);
      response = yield eth_rpc_methods_exports.getUncleByBlockHashAndIndex(web3Context.requestManager, blockHashFormatted, uncleIndexFormatted);
    } else {
      const blockNumberFormatted = isBlockTag(block) ? block : format2({ format: "uint" }, block, ETH_DATA_FORMAT);
      response = yield eth_rpc_methods_exports.getUncleByBlockNumberAndIndex(web3Context.requestManager, blockNumberFormatted, uncleIndexFormatted);
    }
    return format2(blockSchema, response, returnFormat);
  });
}
function getTransaction(web3Context, transactionHash, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    const transactionHashFormatted = format2({ format: "bytes32" }, transactionHash, DEFAULT_RETURN_FORMAT);
    const response = yield eth_rpc_methods_exports.getTransactionByHash(web3Context.requestManager, transactionHashFormatted);
    return isNullish(response) ? response : formatTransaction(response, returnFormat, { fillInputAndData: true });
  });
}
function getPendingTransactions2(web3Context, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    const response = yield eth_rpc_methods_exports.getPendingTransactions(web3Context.requestManager);
    return response.map((transaction) => formatTransaction(transaction, returnFormat, {
      fillInputAndData: true
    }));
  });
}
function getTransactionFromBlock(web3Context, block = web3Context.defaultBlock, transactionIndex, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    const transactionIndexFormatted = format2({ format: "uint" }, transactionIndex, ETH_DATA_FORMAT);
    let response;
    if (isBytes(block)) {
      const blockHashFormatted = format2({ format: "bytes32" }, block, ETH_DATA_FORMAT);
      response = yield eth_rpc_methods_exports.getTransactionByBlockHashAndIndex(web3Context.requestManager, blockHashFormatted, transactionIndexFormatted);
    } else {
      const blockNumberFormatted = isBlockTag(block) ? block : format2({ format: "uint" }, block, ETH_DATA_FORMAT);
      response = yield eth_rpc_methods_exports.getTransactionByBlockNumberAndIndex(web3Context.requestManager, blockNumberFormatted, transactionIndexFormatted);
    }
    return isNullish(response) ? response : formatTransaction(response, returnFormat, { fillInputAndData: true });
  });
}
function getTransactionReceipt2(web3Context, transactionHash, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    const transactionHashFormatted = format2({ format: "bytes32" }, transactionHash, DEFAULT_RETURN_FORMAT);
    const response = yield eth_rpc_methods_exports.getTransactionReceipt(web3Context.requestManager, transactionHashFormatted);
    return isNullish(response) ? response : format2(transactionReceiptSchema, response, returnFormat);
  });
}
function getTransactionCount2(web3Context, address, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format2({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield eth_rpc_methods_exports.getTransactionCount(web3Context.requestManager, address, blockNumberFormatted);
    return format2({ format: "uint" }, response, returnFormat);
  });
}
function sendTransaction3(web3Context, transaction, returnFormat, options = { checkRevertBeforeSending: true }) {
  const promiEvent = new Web3PromiEvent2((resolve, reject) => {
    setImmediate(() => {
      (() => __awaiter54(this, void 0, void 0, function* () {
        const sendTxHelper = new SendTxHelper({
          web3Context,
          promiEvent,
          options,
          returnFormat
        });
        let transactionFormatted = formatTransaction(Object.assign(Object.assign({}, transaction), { from: getTransactionFromOrToAttr("from", web3Context, transaction), to: getTransactionFromOrToAttr("to", web3Context, transaction) }), ETH_DATA_FORMAT);
        try {
          transactionFormatted = yield sendTxHelper.populateGasPrice({
            transaction,
            transactionFormatted
          });
          yield sendTxHelper.checkRevertBeforeSending(transactionFormatted);
          sendTxHelper.emitSending(transactionFormatted);
          let wallet;
          if (web3Context.wallet && !isNullish(transactionFormatted.from)) {
            wallet = web3Context.wallet.get(transactionFormatted.from);
          }
          const transactionHash = yield sendTxHelper.signAndSend({
            wallet,
            tx: transactionFormatted
          });
          const transactionHashFormatted = format2({ format: "bytes32" }, transactionHash, returnFormat);
          sendTxHelper.emitSent(transactionFormatted);
          sendTxHelper.emitTransactionHash(transactionHashFormatted);
          const transactionReceipt = yield waitForTransactionReceipt(web3Context, transactionHash, returnFormat);
          const transactionReceiptFormatted = sendTxHelper.getReceiptWithEvents(format2(transactionReceiptSchema, transactionReceipt, returnFormat));
          sendTxHelper.emitReceipt(transactionReceiptFormatted);
          resolve(yield sendTxHelper.handleResolve({
            receipt: transactionReceiptFormatted,
            tx: transactionFormatted
          }));
          sendTxHelper.emitConfirmation({
            receipt: transactionReceiptFormatted,
            transactionHash
          });
        } catch (error) {
          reject(yield sendTxHelper.handleError({
            error,
            tx: transactionFormatted
          }));
        }
      }))();
    });
  });
  return promiEvent;
}
function sendSignedTransaction(web3Context, signedTransaction, returnFormat, options = { checkRevertBeforeSending: true }) {
  const promiEvent = new Web3PromiEvent2((resolve, reject) => {
    setImmediate(() => {
      (() => __awaiter54(this, void 0, void 0, function* () {
        const sendTxHelper = new SendTxHelper({
          web3Context,
          promiEvent,
          options,
          returnFormat
        });
        const signedTransactionFormattedHex = format2({ format: "bytes" }, signedTransaction, ETH_DATA_FORMAT);
        const unSerializedTransaction = TransactionFactory.fromSerializedData(bytesToUint8Array2(hexToBytes3(signedTransactionFormattedHex)));
        const unSerializedTransactionWithFrom = Object.assign(Object.assign({}, unSerializedTransaction.toJSON()), {
          from: unSerializedTransaction.getSenderAddress().toString()
        });
        try {
          const { v, r, s } = unSerializedTransactionWithFrom, txWithoutSigParams = __rest(unSerializedTransactionWithFrom, ["v", "r", "s"]);
          yield sendTxHelper.checkRevertBeforeSending(txWithoutSigParams);
          sendTxHelper.emitSending(signedTransactionFormattedHex);
          const transactionHash = yield trySendTransaction(web3Context, () => __awaiter54(this, void 0, void 0, function* () {
            return eth_rpc_methods_exports.sendRawTransaction(web3Context.requestManager, signedTransactionFormattedHex);
          }));
          sendTxHelper.emitSent(signedTransactionFormattedHex);
          const transactionHashFormatted = format2({ format: "bytes32" }, transactionHash, returnFormat);
          sendTxHelper.emitTransactionHash(transactionHashFormatted);
          const transactionReceipt = yield waitForTransactionReceipt(web3Context, transactionHash, returnFormat);
          const transactionReceiptFormatted = sendTxHelper.getReceiptWithEvents(format2(transactionReceiptSchema, transactionReceipt, returnFormat));
          sendTxHelper.emitReceipt(transactionReceiptFormatted);
          resolve(yield sendTxHelper.handleResolve({
            receipt: transactionReceiptFormatted,
            tx: unSerializedTransactionWithFrom
          }));
          sendTxHelper.emitConfirmation({
            receipt: transactionReceiptFormatted,
            transactionHash
          });
        } catch (error) {
          reject(yield sendTxHelper.handleError({
            error,
            tx: unSerializedTransactionWithFrom
          }));
        }
      }))();
    });
  });
  return promiEvent;
}
function sign4(web3Context, message, addressOrIndex, returnFormat) {
  var _a16;
  return __awaiter54(this, void 0, void 0, function* () {
    const messageFormatted = format2({ format: "bytes" }, message, DEFAULT_RETURN_FORMAT);
    if ((_a16 = web3Context.wallet) === null || _a16 === void 0 ? void 0 : _a16.get(addressOrIndex)) {
      const wallet = web3Context.wallet.get(addressOrIndex);
      const signed2 = wallet.sign(messageFormatted);
      return format2(SignatureObjectSchema, signed2, returnFormat);
    }
    if (typeof addressOrIndex === "number") {
      throw new SignatureError(message, 'RPC method "eth_sign" does not support index signatures');
    }
    const response = yield eth_rpc_methods_exports.sign(web3Context.requestManager, addressOrIndex, messageFormatted);
    return format2({ format: "bytes" }, response, returnFormat);
  });
}
function signTransaction4(web3Context, transaction, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    const response = yield eth_rpc_methods_exports.signTransaction(web3Context.requestManager, formatTransaction(transaction, ETH_DATA_FORMAT));
    return isString(response) ? decodeSignedTransaction(response, returnFormat, {
      fillInputAndData: true
    }) : {
      raw: format2({ format: "bytes" }, response.raw, returnFormat),
      tx: formatTransaction(response.tx, returnFormat, {
        fillInputAndData: true
      })
    };
  });
}
function call2(web3Context, transaction, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format2({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield eth_rpc_methods_exports.call(web3Context.requestManager, formatTransaction(transaction, ETH_DATA_FORMAT), blockNumberFormatted);
    return format2({ format: "bytes" }, response, returnFormat);
  });
}
function estimateGas2(web3Context, transaction, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    const transactionFormatted = formatTransaction(transaction, ETH_DATA_FORMAT);
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format2({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield eth_rpc_methods_exports.estimateGas(web3Context.requestManager, transactionFormatted, blockNumberFormatted);
    return format2({ format: "uint" }, response, returnFormat);
  });
}
function getLogs2(web3Context, filter, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    let { toBlock, fromBlock } = filter;
    if (!isNullish(toBlock)) {
      if (typeof toBlock === "number" || typeof toBlock === "bigint") {
        toBlock = numberToHex3(toBlock);
      }
    }
    if (!isNullish(fromBlock)) {
      if (typeof fromBlock === "number" || typeof fromBlock === "bigint") {
        fromBlock = numberToHex3(fromBlock);
      }
    }
    const formattedFilter = Object.assign(Object.assign({}, filter), { fromBlock, toBlock });
    const response = yield eth_rpc_methods_exports.getLogs(web3Context.requestManager, formattedFilter);
    const result = response.map((res) => {
      if (typeof res === "string") {
        return res;
      }
      return format2(logSchema, res, returnFormat);
    });
    return result;
  });
}
function getChainId2(web3Context, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    const response = yield eth_rpc_methods_exports.getChainId(web3Context.requestManager);
    return format2(
      { format: "uint" },
      response,
      returnFormat
    );
  });
}
function getProof2(web3Context, address, storageKeys, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    const storageKeysFormatted = storageKeys.map((storageKey) => format2({ format: "bytes" }, storageKey, ETH_DATA_FORMAT));
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format2({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield eth_rpc_methods_exports.getProof(web3Context.requestManager, address, storageKeysFormatted, blockNumberFormatted);
    return format2(accountSchema, response, returnFormat);
  });
}
function getFeeHistory2(web3Context, blockCount, newestBlock = web3Context.defaultBlock, rewardPercentiles, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    const blockCountFormatted = format2({ format: "uint" }, blockCount, ETH_DATA_FORMAT);
    const newestBlockFormatted = isBlockTag(newestBlock) ? newestBlock : format2({ format: "uint" }, newestBlock, ETH_DATA_FORMAT);
    const rewardPercentilesFormatted = format2({
      type: "array",
      items: {
        format: "uint"
      }
    }, rewardPercentiles, NUMBER_DATA_FORMAT);
    const response = yield eth_rpc_methods_exports.getFeeHistory(web3Context.requestManager, blockCountFormatted, newestBlockFormatted, rewardPercentilesFormatted);
    return format2(feeHistorySchema, response, returnFormat);
  });
}
function createAccessList2(web3Context, transaction, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format2({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield eth_rpc_methods_exports.createAccessList(web3Context.requestManager, formatTransaction(transaction, ETH_DATA_FORMAT), blockNumberFormatted);
    return format2(accessListResultSchema, response, returnFormat);
  });
}
function signTypedData2(web3Context, address, typedData, useLegacy, returnFormat) {
  return __awaiter54(this, void 0, void 0, function* () {
    const response = yield eth_rpc_methods_exports.signTypedData(web3Context.requestManager, address, typedData, useLegacy);
    return format2({ format: "bytes" }, response, returnFormat);
  });
}

// node_modules/web3-eth/lib/esm/web3_subscriptions.js
init_shim();
var LogsSubscription = class extends Web3Subscription2 {
  _buildSubscriptionParams() {
    return ["logs", this.args];
  }
  formatSubscriptionResult(data) {
    return format2(logSchema, data, super.returnFormat);
  }
};
var NewPendingTransactionsSubscription = class extends Web3Subscription2 {
  _buildSubscriptionParams() {
    return ["newPendingTransactions"];
  }
  formatSubscriptionResult(data) {
    return format2({ format: "string" }, data, super.returnFormat);
  }
};
var NewHeadsSubscription = class extends Web3Subscription2 {
  _buildSubscriptionParams() {
    return ["newHeads"];
  }
  formatSubscriptionResult(data) {
    return format2(blockHeaderSchema, data, super.returnFormat);
  }
};
var SyncingSubscription = class extends Web3Subscription2 {
  _buildSubscriptionParams() {
    return ["syncing"];
  }
  _processSubscriptionResult(data) {
    if (typeof data === "boolean") {
      this.emit("changed", data);
    } else {
      const mappedData = Object.fromEntries(Object.entries(data.status).map(([key, value]) => [
        key.charAt(0).toLowerCase() + key.substring(1),
        value
      ]));
      this.emit("changed", data.syncing);
      this.emit("data", format2(syncSchema, mappedData, super.returnFormat));
    }
  }
};

// node_modules/web3-eth/lib/esm/web3_eth.js
var __awaiter55 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var registeredSubscriptions = {
  logs: LogsSubscription,
  newPendingTransactions: NewPendingTransactionsSubscription,
  newHeads: NewHeadsSubscription,
  syncing: SyncingSubscription,
  pendingTransactions: NewPendingTransactionsSubscription,
  newBlockHeaders: NewHeadsSubscription
};
var Web3Eth = class extends Web3Context2 {
  constructor(providerOrContext) {
    if (typeof providerOrContext === "string" || isSupportedProvider2(providerOrContext)) {
      super({
        provider: providerOrContext,
        registeredSubscriptions
      });
      return;
    }
    if (providerOrContext.registeredSubscriptions) {
      super(providerOrContext);
      return;
    }
    super(Object.assign(Object.assign({}, providerOrContext), { registeredSubscriptions }));
  }
  getProtocolVersion() {
    return __awaiter55(this, void 0, void 0, function* () {
      return eth_rpc_methods_exports.getProtocolVersion(this.requestManager);
    });
  }
  isSyncing() {
    return __awaiter55(this, void 0, void 0, function* () {
      return eth_rpc_methods_exports.getSyncing(this.requestManager);
    });
  }
  getCoinbase() {
    return __awaiter55(this, void 0, void 0, function* () {
      return eth_rpc_methods_exports.getCoinbase(this.requestManager);
    });
  }
  isMining() {
    return __awaiter55(this, void 0, void 0, function* () {
      return eth_rpc_methods_exports.getMining(this.requestManager);
    });
  }
  getHashrate(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return this.getHashRate(returnFormat);
    });
  }
  getHashRate(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return getHashRate2(this, returnFormat);
    });
  }
  getGasPrice(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return getGasPrice2(this, returnFormat);
    });
  }
  getAccounts() {
    var _a16;
    return __awaiter55(this, void 0, void 0, function* () {
      const hexAddresses = (_a16 = yield eth_rpc_methods_exports.getAccounts(this.requestManager)) !== null && _a16 !== void 0 ? _a16 : [];
      return hexAddresses.map((address) => toChecksumAddress2(address));
    });
  }
  getBlockNumber(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return getBlockNumber2(this, returnFormat);
    });
  }
  getBalance(address, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return getBalance2(this, address, blockNumber, returnFormat);
    });
  }
  getStorageAt(address, storageSlot, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return getStorageAt2(this, address, storageSlot, blockNumber, returnFormat);
    });
  }
  getCode(address, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return getCode2(this, address, blockNumber, returnFormat);
    });
  }
  getBlock(block = this.defaultBlock, hydrated = false, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return getBlock(this, block, hydrated, returnFormat);
    });
  }
  getBlockTransactionCount(block = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return getBlockTransactionCount(this, block, returnFormat);
    });
  }
  getBlockUncleCount(block = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return getBlockUncleCount(this, block, returnFormat);
    });
  }
  getUncle(block = this.defaultBlock, uncleIndex, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return getUncle(this, block, uncleIndex, returnFormat);
    });
  }
  getTransaction(transactionHash, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      const response = yield getTransaction(this, transactionHash, returnFormat);
      if (!response)
        throw new TransactionNotFound();
      return response;
    });
  }
  getPendingTransactions(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return getPendingTransactions2(this, returnFormat);
    });
  }
  getTransactionFromBlock(block = this.defaultBlock, transactionIndex, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return getTransactionFromBlock(this, block, transactionIndex, returnFormat);
    });
  }
  getTransactionReceipt(transactionHash, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      const response = yield getTransactionReceipt2(this, transactionHash, returnFormat);
      if (!response)
        throw new TransactionNotFound();
      return response;
    });
  }
  getTransactionCount(address, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return getTransactionCount2(this, address, blockNumber, returnFormat);
    });
  }
  sendTransaction(transaction, returnFormat = DEFAULT_RETURN_FORMAT, options) {
    return sendTransaction3(this, transaction, returnFormat, options);
  }
  sendSignedTransaction(transaction, returnFormat = DEFAULT_RETURN_FORMAT, options) {
    return sendSignedTransaction(this, transaction, returnFormat, options);
  }
  sign(message, address, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return sign4(this, message, address, returnFormat);
    });
  }
  signTransaction(transaction, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return signTransaction4(this, transaction, returnFormat);
    });
  }
  call(transaction, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return call2(this, transaction, blockNumber, returnFormat);
    });
  }
  estimateGas(transaction, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return estimateGas2(this, transaction, blockNumber, returnFormat);
    });
  }
  getPastLogs(filter, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return getLogs2(this, filter, returnFormat);
    });
  }
  getWork() {
    return __awaiter55(this, void 0, void 0, function* () {
      return eth_rpc_methods_exports.getWork(this.requestManager);
    });
  }
  submitWork(nonce, hash, digest) {
    return __awaiter55(this, void 0, void 0, function* () {
      return eth_rpc_methods_exports.submitWork(this.requestManager, nonce, hash, digest);
    });
  }
  requestAccounts() {
    return __awaiter55(this, void 0, void 0, function* () {
      return eth_rpc_methods_exports.requestAccounts(this.requestManager);
    });
  }
  getChainId(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return getChainId2(this, returnFormat);
    });
  }
  getNodeInfo() {
    return __awaiter55(this, void 0, void 0, function* () {
      return eth_rpc_methods_exports.getNodeInfo(this.requestManager);
    });
  }
  getProof(address, storageKeys, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return getProof2(this, address, storageKeys, blockNumber, returnFormat);
    });
  }
  getFeeHistory(blockCount, newestBlock = this.defaultBlock, rewardPercentiles, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return getFeeHistory2(this, blockCount, newestBlock, rewardPercentiles, returnFormat);
    });
  }
  createAccessList(transaction, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return createAccessList2(this, transaction, blockNumber, returnFormat);
    });
  }
  signTypedData(address, typedData, useLegacy = false, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter55(this, void 0, void 0, function* () {
      return signTypedData2(this, address, typedData, useLegacy, returnFormat);
    });
  }
  subscribe(name2, args, returnFormat = DEFAULT_RETURN_FORMAT) {
    var _a16;
    return __awaiter55(this, void 0, void 0, function* () {
      const subscription = yield (_a16 = this.subscriptionManager) === null || _a16 === void 0 ? void 0 : _a16.subscribe(name2, args, returnFormat);
      if (subscription instanceof LogsSubscription && name2 === "logs" && typeof args === "object" && !isNullish3(args.fromBlock) && Number.isFinite(Number(args.fromBlock))) {
        setImmediate(() => {
          this.getPastLogs(args).then((logs) => {
            for (const log of logs) {
              subscription._processSubscriptionResult(log);
            }
          }).catch((e) => {
            subscription._processSubscriptionError(e);
          });
        });
      }
      return subscription;
    });
  }
  static shouldClearSubscription({ sub }) {
    return !(sub instanceof SyncingSubscription);
  }
  clearSubscriptions(notClearSyncing = false) {
    var _a16;
    return (_a16 = this.subscriptionManager) === null || _a16 === void 0 ? void 0 : _a16.unsubscribe(
      notClearSyncing ? Web3Eth.shouldClearSubscription : void 0
    );
  }
};

// node_modules/web3-eth/lib/esm/types.js
init_shim();

// node_modules/web3-eth/lib/esm/validation.js
init_shim();
function isBaseTransaction(value) {
  if (!isNullish(value.to) && !isAddress(value.to))
    return false;
  if (!isHexStrict(value.type) && !isNullish(value.type) && value.type.length !== 2)
    return false;
  if (!isHexStrict(value.nonce))
    return false;
  if (!isHexStrict(value.gas))
    return false;
  if (!isHexStrict(value.value))
    return false;
  if (!isHexStrict(value.input))
    return false;
  if (value.chainId && !isHexStrict(value.chainId))
    return false;
  return true;
}
function isAccessListEntry(value) {
  if (!isNullish(value.address) && !isAddress(value.address))
    return false;
  if (!isNullish(value.storageKeys) && !value.storageKeys.every((storageKey) => isHexString32Bytes(storageKey)))
    return false;
  return true;
}
function isAccessList2(value) {
  if (!Array.isArray(value) || !value.every((accessListEntry) => isAccessListEntry(accessListEntry)))
    return false;
  return true;
}
function isTransaction1559Unsigned(value) {
  if (!isBaseTransaction(value))
    return false;
  if (!isHexStrict(value.maxFeePerGas))
    return false;
  if (!isHexStrict(value.maxPriorityFeePerGas))
    return false;
  if (!isAccessList2(value.accessList))
    return false;
  return true;
}
function isTransaction2930Unsigned(value) {
  if (!isBaseTransaction(value))
    return false;
  if (!isHexStrict(value.gasPrice))
    return false;
  if (!isAccessList2(value.accessList))
    return false;
  return true;
}
function isTransactionLegacyUnsigned(value) {
  if (!isBaseTransaction(value))
    return false;
  if (!isHexStrict(value.gasPrice))
    return false;
  return true;
}
function isTransactionWithSender(value) {
  if (!isAddress(value.from))
    return false;
  if (!isBaseTransaction(value))
    return false;
  if (!isTransaction1559Unsigned(value) && !isTransaction2930Unsigned(value) && !isTransactionLegacyUnsigned(value))
    return false;
  return true;
}
function validateTransactionWithSender(value) {
  if (!isTransactionWithSender(value))
    throw new InvalidTransactionWithSender(value);
}
function isTransactionCall(value) {
  if (!isNullish(value.from) && !isAddress(value.from))
    return false;
  if (!isAddress(value.to))
    return false;
  if (!isNullish(value.gas) && !isHexStrict(value.gas))
    return false;
  if (!isNullish(value.gasPrice) && !isHexStrict(value.gasPrice))
    return false;
  if (!isNullish(value.value) && !isHexStrict(value.value))
    return false;
  if (!isNullish(value.data) && !isHexStrict(value.data))
    return false;
  if (!isNullish(value.input) && !isHexStrict(value.input))
    return false;
  if (!isNullish(value.type))
    return false;
  if (isTransaction1559Unsigned(value))
    return false;
  if (isTransaction2930Unsigned(value))
    return false;
  return true;
}
function validateTransactionCall(value) {
  if (!isTransactionCall(value))
    throw new InvalidTransactionCall(value);
}
var validateCustomChainInfo = (transaction) => {
  if (!isNullish(transaction.common)) {
    if (isNullish(transaction.common.customChain))
      throw new MissingCustomChainError();
    if (isNullish(transaction.common.customChain.chainId))
      throw new MissingCustomChainIdError();
    if (!isNullish(transaction.chainId) && transaction.chainId !== transaction.common.customChain.chainId)
      throw new ChainIdMismatchError({
        txChainId: transaction.chainId,
        customChainId: transaction.common.customChain.chainId
      });
  }
};
var validateChainInfo = (transaction) => {
  if (!isNullish(transaction.common) && !isNullish(transaction.chain) && !isNullish(transaction.hardfork)) {
    throw new CommonOrChainAndHardforkError();
  }
  if (!isNullish(transaction.chain) && isNullish(transaction.hardfork) || !isNullish(transaction.hardfork) && isNullish(transaction.chain))
    throw new MissingChainOrHardforkError({
      chain: transaction.chain,
      hardfork: transaction.hardfork
    });
};
var validateBaseChain = (transaction) => {
  if (!isNullish(transaction.common)) {
    if (!isNullish(transaction.common.baseChain)) {
      if (!isNullish(transaction.chain) && transaction.chain !== transaction.common.baseChain) {
        throw new ChainMismatchError({
          txChain: transaction.chain,
          baseChain: transaction.common.baseChain
        });
      }
    }
  }
};
var validateHardfork = (transaction) => {
  if (!isNullish(transaction.common)) {
    if (!isNullish(transaction.common.hardfork)) {
      if (!isNullish(transaction.hardfork) && transaction.hardfork !== transaction.common.hardfork) {
        throw new HardforkMismatchError({
          txHardfork: transaction.hardfork,
          commonHardfork: transaction.common.hardfork
        });
      }
    }
  }
};
var validateLegacyGas = (transaction) => {
  if (isNullish(transaction.gas) || !isUInt(transaction.gas) || isNullish(transaction.gasPrice) || !isUInt(transaction.gasPrice))
    throw new InvalidGasOrGasPrice({
      gas: transaction.gas,
      gasPrice: transaction.gasPrice
    });
  if (!isNullish(transaction.maxFeePerGas) || !isNullish(transaction.maxPriorityFeePerGas))
    throw new UnsupportedFeeMarketError({
      maxFeePerGas: transaction.maxFeePerGas,
      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas
    });
};
var validateFeeMarketGas = (transaction) => {
  if (!isNullish(transaction.gasPrice) && transaction.type === "0x2")
    throw new Eip1559GasPriceError(transaction.gasPrice);
  if (transaction.type === "0x0" || transaction.type === "0x1")
    throw new UnsupportedFeeMarketError({
      maxFeePerGas: transaction.maxFeePerGas,
      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas
    });
  if (isNullish(transaction.maxFeePerGas) || !isUInt(transaction.maxFeePerGas) || isNullish(transaction.maxPriorityFeePerGas) || !isUInt(transaction.maxPriorityFeePerGas))
    throw new InvalidMaxPriorityFeePerGasOrMaxFeePerGas({
      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,
      maxFeePerGas: transaction.maxFeePerGas
    });
};
var validateGas = (transaction) => {
  const gasPresent = !isNullish(transaction.gas) || !isNullish(transaction.gasLimit);
  const legacyGasPresent = gasPresent && !isNullish(transaction.gasPrice);
  const feeMarketGasPresent = gasPresent && !isNullish(transaction.maxPriorityFeePerGas) && !isNullish(transaction.maxFeePerGas);
  if (!legacyGasPresent && !feeMarketGasPresent)
    throw new MissingGasError({
      gas: transaction.gas,
      gasPrice: transaction.gasPrice,
      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,
      maxFeePerGas: transaction.maxFeePerGas
    });
  if (legacyGasPresent && feeMarketGasPresent)
    throw new TransactionGasMismatchError({
      gas: transaction.gas,
      gasPrice: transaction.gasPrice,
      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,
      maxFeePerGas: transaction.maxFeePerGas
    });
  (legacyGasPresent ? validateLegacyGas : validateFeeMarketGas)(transaction);
  (!isNullish(transaction.type) && transaction.type > "0x1" ? validateFeeMarketGas : validateLegacyGas)(transaction);
};
var validateTransactionForSigning = (transaction, overrideMethod) => {
  if (!isNullish(overrideMethod)) {
    overrideMethod(transaction);
    return;
  }
  if (typeof transaction !== "object" || isNullish(transaction))
    throw new InvalidTransactionObjectError(transaction);
  validateCustomChainInfo(transaction);
  validateChainInfo(transaction);
  validateBaseChain(transaction);
  validateHardfork(transaction);
  const formattedTransaction = formatTransaction(transaction, ETH_DATA_FORMAT);
  validateGas(formattedTransaction);
  if (isNullish(formattedTransaction.nonce) || isNullish(formattedTransaction.chainId) || formattedTransaction.nonce.startsWith("-") || formattedTransaction.chainId.startsWith("-"))
    throw new InvalidNonceOrChainIdError({
      nonce: transaction.nonce,
      chainId: transaction.chainId
    });
};

// node_modules/web3-eth/lib/esm/utils/prepare_transaction_for_signing.js
init_shim();
var __awaiter56 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getEthereumjsTxDataFromTransaction = (transaction) => {
  var _a16, _b;
  return {
    nonce: transaction.nonce,
    gasPrice: transaction.gasPrice,
    gasLimit: (_a16 = transaction.gasLimit) !== null && _a16 !== void 0 ? _a16 : transaction.gas,
    to: transaction.to,
    value: transaction.value,
    data: (_b = transaction.data) !== null && _b !== void 0 ? _b : transaction.input,
    type: transaction.type,
    chainId: transaction.chainId,
    accessList: transaction.accessList,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,
    maxFeePerGas: transaction.maxFeePerGas
  };
};
var getEthereumjsTransactionOptions = (transaction, web3Context) => {
  var _a16, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
  const hasTransactionSigningOptions = !isNullish(transaction.chain) && !isNullish(transaction.hardfork) || !isNullish(transaction.common);
  let common;
  if (!hasTransactionSigningOptions) {
    if (web3Context.defaultCommon) {
      common = web3Context.defaultCommon;
      if (isNullish(common.hardfork))
        common.hardfork = (_a16 = transaction.hardfork) !== null && _a16 !== void 0 ? _a16 : web3Context.defaultHardfork;
      if (isNullish(common.baseChain))
        common.baseChain = web3Context.defaultChain;
    } else {
      common = Common.custom({
        name: "custom-network",
        chainId: toNumber2(transaction.chainId),
        networkId: !isNullish(transaction.networkId) ? toNumber2(transaction.networkId) : void 0,
        defaultHardfork: (_b = transaction.hardfork) !== null && _b !== void 0 ? _b : web3Context.defaultHardfork
      }, {
        baseChain: web3Context.defaultChain
      });
    }
  } else {
    const name2 = (_f = (_e = (_d = (_c = transaction === null || transaction === void 0 ? void 0 : transaction.common) === null || _c === void 0 ? void 0 : _c.customChain) === null || _d === void 0 ? void 0 : _d.name) !== null && _e !== void 0 ? _e : transaction.chain) !== null && _f !== void 0 ? _f : "custom-network";
    const chainId = toNumber2((_j = (_h = (_g = transaction === null || transaction === void 0 ? void 0 : transaction.common) === null || _g === void 0 ? void 0 : _g.customChain) === null || _h === void 0 ? void 0 : _h.chainId) !== null && _j !== void 0 ? _j : transaction === null || transaction === void 0 ? void 0 : transaction.chainId);
    const networkId = toNumber2((_m = (_l = (_k = transaction === null || transaction === void 0 ? void 0 : transaction.common) === null || _k === void 0 ? void 0 : _k.customChain) === null || _l === void 0 ? void 0 : _l.networkId) !== null && _m !== void 0 ? _m : transaction === null || transaction === void 0 ? void 0 : transaction.networkId);
    const defaultHardfork = (_q = (_p = (_o = transaction === null || transaction === void 0 ? void 0 : transaction.common) === null || _o === void 0 ? void 0 : _o.hardfork) !== null && _p !== void 0 ? _p : transaction === null || transaction === void 0 ? void 0 : transaction.hardfork) !== null && _q !== void 0 ? _q : web3Context.defaultHardfork;
    const baseChain = (_t = (_s = (_r = transaction.common) === null || _r === void 0 ? void 0 : _r.baseChain) !== null && _s !== void 0 ? _s : transaction.chain) !== null && _t !== void 0 ? _t : web3Context.defaultChain;
    if (chainId && networkId && name2) {
      common = Common.custom({
        name: name2,
        chainId,
        networkId,
        defaultHardfork
      }, {
        baseChain
      });
    }
  }
  return { common };
};
var prepareTransactionForSigning = (transaction, web3Context, privateKey, fillGasPrice = false, fillGasLimit = true) => __awaiter56(void 0, void 0, void 0, function* () {
  const populatedTransaction = yield transactionBuilder({
    transaction,
    web3Context,
    privateKey,
    fillGasPrice,
    fillGasLimit
  });
  const formattedTransaction = formatTransaction(populatedTransaction, ETH_DATA_FORMAT);
  validateTransactionForSigning(formattedTransaction);
  return TransactionFactory.fromTxData(getEthereumjsTxDataFromTransaction(formattedTransaction), getEthereumjsTransactionOptions(formattedTransaction, web3Context));
});

// node_modules/web3-eth-contract/lib/esm/index.js
var esm_exports13 = {};
__export(esm_exports13, {
  Contract: () => Contract,
  LogsSubscription: () => LogsSubscription2,
  decodeEventABI: () => decodeEventABI,
  decodeMethodReturn: () => decodeMethodReturn,
  default: () => esm_default3,
  encodeEventABI: () => encodeEventABI,
  encodeMethodABI: () => encodeMethodABI
});
init_shim();

// node_modules/web3-eth-contract/lib/esm/contract.js
init_shim();

// node_modules/web3-eth-contract/node_modules/web3-core/lib/esm/index.js
init_shim();

// node_modules/web3-eth-contract/node_modules/web3-core/lib/esm/web3_config.js
init_shim();

// node_modules/web3-eth-contract/node_modules/web3-utils/lib/esm/index.js
init_shim();

// node_modules/web3-eth-contract/node_modules/web3-utils/lib/esm/converters.js
init_shim();

// node_modules/web3-eth-contract/node_modules/ethereum-cryptography/esm/keccak.js
init_shim();
init_sha3();

// node_modules/web3-eth-contract/node_modules/ethereum-cryptography/esm/utils.js
init_shim();
init_assert();
init_utils();
init_utils();
var assertBool7 = assert_default.bool;
var assertBytes7 = assert_default.bytes;
function bytesToUtf86(data) {
  if (!(data instanceof Uint8Array)) {
    throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
  }
  return new TextDecoder().decode(data);
}
function wrapHash7(hash) {
  return (msg) => {
    assert_default.bytes(msg);
    return hash(msg);
  };
}
var crypto9 = (() => {
  const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
  return {
    node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
    web: webCrypto
  };
})();

// node_modules/web3-eth-contract/node_modules/ethereum-cryptography/esm/keccak.js
var keccak2247 = wrapHash7(keccak_224);
var keccak2567 = (() => {
  const k = wrapHash7(keccak_256);
  k.create = keccak_256.create;
  return k;
})();
var keccak3847 = wrapHash7(keccak_384);
var keccak5127 = wrapHash7(keccak_512);

// node_modules/web3-eth-contract/node_modules/web3-utils/lib/esm/converters.js
var ethUnitMap6 = {
  noether: BigInt(0),
  wei: BigInt(1),
  kwei: BigInt(1e3),
  Kwei: BigInt(1e3),
  babbage: BigInt(1e3),
  femtoether: BigInt(1e3),
  mwei: BigInt(1e6),
  Mwei: BigInt(1e6),
  lovelace: BigInt(1e6),
  picoether: BigInt(1e6),
  gwei: BigInt(1e9),
  Gwei: BigInt(1e9),
  shannon: BigInt(1e9),
  nanoether: BigInt(1e9),
  nano: BigInt(1e9),
  szabo: BigInt(1e12),
  microether: BigInt(1e12),
  micro: BigInt(1e12),
  finney: BigInt(1e15),
  milliether: BigInt(1e15),
  milli: BigInt(1e15),
  ether: BigInt("1000000000000000000"),
  kether: BigInt("1000000000000000000000"),
  grand: BigInt("1000000000000000000000"),
  mether: BigInt("1000000000000000000000000"),
  gether: BigInt("1000000000000000000000000000"),
  tether: BigInt("1000000000000000000000000000000")
};
var bytesToUint8Array6 = (data) => {
  validator.validate(["bytes"], [data]);
  if (data instanceof Uint8Array) {
    return data;
  }
  if (Array.isArray(data)) {
    return new Uint8Array(data);
  }
  if (typeof data === "string") {
    return utils_exports.hexToUint8Array(data);
  }
  throw new InvalidBytesError(data);
};
var { uint8ArrayToHexString: uint8ArrayToHexString7 } = utils_exports;
var bytesToHex7 = (bytes) => uint8ArrayToHexString7(bytesToUint8Array6(bytes));
var hexToBytes7 = (bytes) => {
  if (typeof bytes === "string" && bytes.slice(0, 2).toLowerCase() !== "0x") {
    return bytesToUint8Array6(`0x${bytes}`);
  }
  return bytesToUint8Array6(bytes);
};
var hexToNumber6 = (value) => {
  validator.validate(["hex"], [value]);
  return utils_exports.hexToNumber(value);
};
var numberToHex7 = (value, hexstrict) => {
  if (typeof value !== "bigint")
    validator.validate(["int"], [value]);
  let updatedValue = utils_exports.numberToHex(value);
  if (hexstrict) {
    if (!updatedValue.startsWith("-") && updatedValue.length % 2 === 1) {
      updatedValue = "0x0".concat(updatedValue.slice(2));
    } else if (updatedValue.length % 2 === 0 && updatedValue.startsWith("-"))
      updatedValue = "-0x0".concat(updatedValue.slice(3));
  }
  return updatedValue;
};
var hexToNumberString4 = (data) => hexToNumber6(data).toString();
var utf8ToHex6 = (str) => {
  validator.validate(["string"], [str]);
  let strWithoutNullCharacter = str.replace(/^(?:\u0000)/, "");
  strWithoutNullCharacter = strWithoutNullCharacter.replace(/(?:\u0000)$/, "");
  return bytesToHex7(new TextEncoder().encode(strWithoutNullCharacter));
};
var fromUtf85 = utf8ToHex6;
var hexToUtf85 = (str) => bytesToUtf86(hexToBytes7(str));
var toUtf84 = (input) => {
  if (typeof input === "string") {
    return hexToUtf85(input);
  }
  validator.validate(["bytes"], [input]);
  return bytesToUtf86(input);
};
var utf8ToBytes7 = utf8ToBytes;
var toHex6 = (value, returnType) => {
  if (typeof value === "string" && isAddress(value)) {
    return returnType ? "address" : `0x${value.toLowerCase().replace(/^0x/i, "")}`;
  }
  if (typeof value === "boolean") {
    return returnType ? "bool" : value ? "0x01" : "0x00";
  }
  if (typeof value === "number") {
    return returnType ? value < 0 ? "int256" : "uint256" : numberToHex7(value);
  }
  if (typeof value === "bigint") {
    return returnType ? "bigint" : numberToHex7(value);
  }
  if (typeof value === "object" && !!value) {
    return returnType ? "string" : utf8ToHex6(JSON.stringify(value));
  }
  if (typeof value === "string") {
    if (value.startsWith("-0x") || value.startsWith("-0X")) {
      return returnType ? "int256" : numberToHex7(value);
    }
    if (isHexStrict(value)) {
      return returnType ? "bytes" : value;
    }
    if (isHex(value) && !isInt(value)) {
      return returnType ? "bytes" : `0x${value}`;
    }
    if (!Number.isFinite(value)) {
      return returnType ? "string" : utf8ToHex6(value);
    }
  }
  throw new HexProcessingError(value);
};
var toNumber6 = (value) => {
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "bigint") {
    return value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER ? Number(value) : value;
  }
  if (typeof value === "string" && isHexStrict(value)) {
    return hexToNumber6(value);
  }
  try {
    return toNumber6(BigInt(value));
  } catch (_a16) {
    throw new InvalidNumberError(value);
  }
};
var toBigInt6 = (value) => {
  if (typeof value === "number") {
    return BigInt(value);
  }
  if (typeof value === "bigint") {
    return value;
  }
  if (typeof value === "string" && isHex(value)) {
    if (value.startsWith("-")) {
      return -BigInt(value.substring(1));
    }
    return BigInt(value);
  }
  throw new InvalidNumberError(value);
};
var toChecksumAddress6 = (address) => {
  if (!isAddress(address, false)) {
    throw new InvalidAddressError(address);
  }
  const lowerCaseAddress = address.toLowerCase().replace(/^0x/i, "");
  const hash = utils_exports.uint8ArrayToHexString(keccak2567(utf8ToBytes7(lowerCaseAddress)));
  if (isNullish(hash) || hash === "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470")
    return "";
  let checksumAddress = "0x";
  const addressHash = hash.replace(/^0x/i, "");
  for (let i = 0; i < lowerCaseAddress.length; i += 1) {
    if (parseInt(addressHash[i], 16) > 7) {
      checksumAddress += lowerCaseAddress[i].toUpperCase();
    } else {
      checksumAddress += lowerCaseAddress[i];
    }
  }
  return checksumAddress;
};

// node_modules/web3-eth-contract/node_modules/web3-utils/lib/esm/event_emitter.js
init_shim();
var import_events11 = __toESM(require_events(), 1);
var __awaiter57 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var wrapFunction6 = (fn) => (params) => fn(params.detail);
var EventEmitterAtBrowser6 = class extends EventTarget {
  constructor() {
    super(...arguments);
    this._listeners = {};
    this.maxListeners = Number.MAX_SAFE_INTEGER;
  }
  on(eventName, fn) {
    this.addEventListener(eventName, fn);
    return this;
  }
  once(eventName, fn) {
    const onceCallback = (params) => __awaiter57(this, void 0, void 0, function* () {
      this.off(eventName, onceCallback);
      yield fn(params);
    });
    return this.on(eventName, onceCallback);
  }
  off(eventName, fn) {
    this.removeEventListener(eventName, fn);
    return this;
  }
  emit(eventName, params) {
    const event = new CustomEvent(eventName, { detail: params });
    return super.dispatchEvent(event);
  }
  listenerCount(eventName) {
    const eventListeners = this._listeners[eventName];
    return eventListeners ? eventListeners.length : 0;
  }
  listeners(eventName) {
    return this._listeners[eventName].map((value) => value[0]) || [];
  }
  eventNames() {
    return Object.keys(this._listeners);
  }
  removeAllListeners() {
    Object.keys(this._listeners).forEach((event) => {
      this._listeners[event].forEach((listener) => {
        super.removeEventListener(event, listener[1]);
      });
    });
    this._listeners = {};
    return this;
  }
  setMaxListeners(maxListeners) {
    this.maxListeners = maxListeners;
    return this;
  }
  getMaxListeners() {
    return this.maxListeners;
  }
  addEventListener(eventName, fn) {
    const wrappedFn = wrapFunction6(fn);
    super.addEventListener(eventName, wrappedFn);
    if (!this._listeners[eventName]) {
      this._listeners[eventName] = [];
    }
    this._listeners[eventName].push([fn, wrappedFn]);
  }
  removeEventListener(eventName, fn) {
    const eventListeners = this._listeners[eventName];
    if (eventListeners) {
      const index = eventListeners.findIndex((item) => item[0] === fn);
      if (index !== -1) {
        super.removeEventListener(eventName, eventListeners[index][1]);
        eventListeners.splice(index, 1);
      }
    }
  }
};
var EventEmitterType6;
if (typeof window === "undefined") {
  EventEmitterType6 = import_events11.EventEmitter;
} else {
  EventEmitterType6 = EventEmitterAtBrowser6;
}
var EventEmitter10 = class extends EventEmitterType6 {
};

// node_modules/web3-eth-contract/node_modules/web3-utils/lib/esm/validation.js
init_shim();
var isHexStrict5 = isHexStrict;
var isAddress5 = isAddress;
var isNullish7 = isNullish;

// node_modules/web3-eth-contract/node_modules/web3-utils/lib/esm/formatter.js
init_shim();

// node_modules/web3-eth-contract/node_modules/web3-utils/lib/esm/objects.js
init_shim();
var isIterable4 = (item) => typeof item === "object" && !isNullish(item) && !Array.isArray(item) && !(item instanceof TypedArray);
var mergeDeep6 = (destination, ...sources) => {
  const result = destination;
  if (!isIterable4(result)) {
    return result;
  }
  for (const src of sources) {
    for (const key in src) {
      if (isIterable4(src[key])) {
        if (!result[key]) {
          result[key] = {};
        }
        mergeDeep6(result[key], src[key]);
      } else if (!isNullish(src[key]) && Object.hasOwnProperty.call(src, key)) {
        if (Array.isArray(src[key]) || src[key] instanceof TypedArray) {
          result[key] = src[key].slice(0);
        } else {
          result[key] = src[key];
        }
      }
    }
  }
  return result;
};

// node_modules/web3-eth-contract/node_modules/web3-utils/lib/esm/string_manipulation.js
init_shim();
var padLeft7 = (value, characterAmount, sign6 = "0") => {
  if (typeof value === "string") {
    if (!isHexStrict(value)) {
      return value.padStart(characterAmount, sign6);
    }
    return utils_exports.padLeft(value, characterAmount, sign6);
  }
  validator.validate(["int"], [value]);
  return utils_exports.padLeft(value, characterAmount, sign6);
};
var leftPad6 = padLeft7;

// node_modules/web3-eth-contract/node_modules/web3-utils/lib/esm/uint8array.js
init_shim();
function uint8ArrayConcat6(...parts) {
  const length = parts.reduce((prev, part) => {
    const agg = prev + part.length;
    return agg;
  }, 0);
  const result = new Uint8Array(length);
  let offset = 0;
  for (const part of parts) {
    result.set(part, offset);
    offset += part.length;
  }
  return result;
}

// node_modules/web3-eth-contract/node_modules/web3-utils/lib/esm/formatter.js
var { parseBaseType: parseBaseType7 } = utils_exports;
var isDataFormat2 = (dataFormat) => typeof dataFormat === "object" && !isNullish(dataFormat) && "number" in dataFormat && "bytes" in dataFormat;
var findSchemaByDataPath4 = (schema, dataPath, oneOfPath = []) => {
  let result = Object.assign({}, schema);
  let previousDataPath;
  for (const dataPart of dataPath) {
    if (result.oneOf && previousDataPath) {
      const path = oneOfPath.find(function(element) {
        return this === element[0];
      }, previousDataPath !== null && previousDataPath !== void 0 ? previousDataPath : "");
      if (path && path[0] === previousDataPath) {
        result = result.oneOf[path[1]];
      }
    }
    if (!result.properties && !result.items) {
      return void 0;
    }
    if (result.properties) {
      result = result.properties[dataPart];
    } else if (result.items && result.items.properties) {
      const node = result.items.properties;
      if (!node) {
        return void 0;
      }
      result = node[dataPart];
    } else if (result.items && isObject(result.items)) {
      result = result.items;
    } else if (result.items && Array.isArray(result.items)) {
      result = result.items[parseInt(dataPart, 10)];
    }
    if (result && dataPart)
      previousDataPath = dataPart;
  }
  return result;
};
var convertScalarValue4 = (value, ethType, format5) => {
  try {
    const { baseType, baseTypeSize } = parseBaseType7(ethType);
    if (baseType === "int" || baseType === "uint") {
      switch (format5.number) {
        case FMT_NUMBER.NUMBER:
          return Number(toBigInt6(value));
        case FMT_NUMBER.HEX:
          return numberToHex7(toBigInt6(value));
        case FMT_NUMBER.STR:
          return toBigInt6(value).toString();
        case FMT_NUMBER.BIGINT:
          return toBigInt6(value);
        default:
          throw new FormatterError(`Invalid format: ${String(format5.number)}`);
      }
    }
    if (baseType === "bytes") {
      let paddedValue;
      if (baseTypeSize) {
        if (typeof value === "string")
          paddedValue = padLeft7(value, baseTypeSize * 2);
        else if (value instanceof Uint8Array) {
          paddedValue = uint8ArrayConcat6(new Uint8Array(baseTypeSize - value.length), value);
        }
      } else {
        paddedValue = value;
      }
      switch (format5.bytes) {
        case FMT_BYTES.HEX:
          return bytesToHex7(bytesToUint8Array6(paddedValue));
        case FMT_BYTES.UINT8ARRAY:
          return bytesToUint8Array6(paddedValue);
        default:
          throw new FormatterError(`Invalid format: ${String(format5.bytes)}`);
      }
    }
  } catch (error) {
    return value;
  }
  return value;
};
var convert4 = (data, schema, dataPath, format5, oneOfPath = []) => {
  var _a16, _b;
  if (!isObject(data) && !Array.isArray(data)) {
    return convertScalarValue4(data, schema === null || schema === void 0 ? void 0 : schema.format, format5);
  }
  const object = data;
  for (const [key, value] of Object.entries(object)) {
    dataPath.push(key);
    const schemaProp = findSchemaByDataPath4(schema, dataPath, oneOfPath);
    if (isNullish(schemaProp)) {
      delete object[key];
      dataPath.pop();
      continue;
    }
    if (isObject(value)) {
      convert4(value, schema, dataPath, format5);
      dataPath.pop();
      continue;
    }
    if (Array.isArray(value)) {
      let _schemaProp = schemaProp;
      if ((schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.oneOf) !== void 0) {
        schemaProp.oneOf.forEach((oneOfSchemaProp, index) => {
          var _a17, _b2;
          if (!Array.isArray(schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.items) && (typeof value[0] === "object" && ((_a17 = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _a17 === void 0 ? void 0 : _a17.type) === "object" || typeof value[0] === "string" && ((_b2 = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _b2 === void 0 ? void 0 : _b2.type) !== "object")) {
            _schemaProp = oneOfSchemaProp;
            oneOfPath.push([key, index]);
          }
        });
      }
      if (isNullish(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {
        delete object[key];
        dataPath.pop();
        continue;
      }
      if (isObject(_schemaProp.items) && !isNullish(_schemaProp.items.format)) {
        for (let i = 0; i < value.length; i += 1) {
          object[key][i] = convertScalarValue4(
            value[i],
            (_a16 = _schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) === null || _a16 === void 0 ? void 0 : _a16.format,
            format5
          );
        }
        dataPath.pop();
        continue;
      }
      if (!Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) && ((_b = _schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) === null || _b === void 0 ? void 0 : _b.type) === "object") {
        for (const arrObject of value) {
          convert4(arrObject, schema, dataPath, format5, oneOfPath);
        }
        dataPath.pop();
        continue;
      }
      if (Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {
        for (let i = 0; i < value.length; i += 1) {
          object[key][i] = convertScalarValue4(value[i], _schemaProp.items[i].format, format5);
        }
        dataPath.pop();
        continue;
      }
    }
    object[key] = convertScalarValue4(value, schemaProp.format, format5);
    dataPath.pop();
  }
  return object;
};
var format4 = (schema, data, returnFormat) => {
  let dataToParse;
  if (isObject(data)) {
    dataToParse = mergeDeep6({}, data);
  } else if (Array.isArray(data)) {
    dataToParse = [...data];
  } else {
    dataToParse = data;
  }
  const jsonSchema = isObject(schema) ? schema : utils_exports.ethAbiToJsonSchema(schema);
  if (!jsonSchema.properties && !jsonSchema.items && !jsonSchema.format) {
    throw new FormatterError("Invalid json schema for formatting");
  }
  return convert4(dataToParse, jsonSchema, [], returnFormat);
};

// node_modules/web3-eth-contract/node_modules/web3-utils/lib/esm/hash.js
init_shim();
var SHA3_EMPTY_BYTES6 = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
var sha36 = (data) => {
  let updatedData;
  if (typeof data === "string") {
    if (data.startsWith("0x") && isHexStrict(data)) {
      updatedData = hexToBytes7(data);
    } else {
      updatedData = utf8ToBytes(data);
    }
  } else {
    updatedData = data;
  }
  const hash = bytesToHex7(keccak2567(updatedData));
  return hash === SHA3_EMPTY_BYTES6 ? void 0 : hash;
};
var sha3Raw6 = (data) => {
  const hash = sha36(data);
  if (isNullish(hash)) {
    return SHA3_EMPTY_BYTES6;
  }
  return hash;
};
var keccak256Wrapper4 = (data) => {
  let processedData;
  if (typeof data === "bigint" || typeof data === "number") {
    processedData = utf8ToBytes(data.toString());
  } else if (Array.isArray(data)) {
    processedData = new Uint8Array(data);
  } else if (typeof data === "string" && !isHexStrict(data)) {
    processedData = utf8ToBytes(data);
  } else {
    processedData = bytesToUint8Array6(data);
  }
  return bytesToHex7(keccak2567(processedData));
};

// node_modules/web3-eth-contract/node_modules/web3-utils/lib/esm/random.js
init_shim();

// node_modules/web3-eth-contract/node_modules/ethereum-cryptography/esm/random.js
init_shim();
init_utils();
function getRandomBytesSync6(bytes) {
  return randomBytes(bytes);
}

// node_modules/web3-eth-contract/node_modules/web3-utils/lib/esm/random.js
var randomBytes7 = (size) => getRandomBytesSync6(size);

// node_modules/web3-eth-contract/node_modules/web3-utils/lib/esm/promise_helpers.js
init_shim();
function isPromise4(object) {
  return (typeof object === "object" || typeof object === "function") && typeof object.then === "function";
}

// node_modules/web3-eth-contract/node_modules/web3-utils/lib/esm/json_rpc.js
var json_rpc_exports6 = {};
__export(json_rpc_exports6, {
  isBatchRequest: () => isBatchRequest6,
  isBatchResponse: () => isBatchResponse6,
  isResponseRpcError: () => isResponseRpcError6,
  isResponseWithError: () => isResponseWithError7,
  isResponseWithNotification: () => isResponseWithNotification6,
  isResponseWithResult: () => isResponseWithResult6,
  isSubscriptionResult: () => isSubscriptionResult6,
  isValidResponse: () => isValidResponse6,
  setRequestIdStart: () => setRequestIdStart6,
  toBatchPayload: () => toBatchPayload6,
  toPayload: () => toPayload6,
  validateResponse: () => validateResponse6
});
init_shim();

// node_modules/web3-eth-contract/node_modules/web3-utils/lib/esm/uuid.js
init_shim();
var uuidV46 = () => {
  const bytes = randomBytes7(16);
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 63 | 128;
  const hexString = bytesToHex7(bytes);
  return [
    hexString.substring(2, 10),
    hexString.substring(10, 14),
    hexString.substring(14, 18),
    hexString.substring(18, 22),
    hexString.substring(22, 34)
  ].join("-");
};

// node_modules/web3-eth-contract/node_modules/web3-utils/lib/esm/json_rpc.js
var isResponseRpcError6 = (rpcError) => {
  const errorCode = rpcError.error.code;
  return rpcErrorsMap.has(errorCode) || errorCode >= -32099 && errorCode <= -32e3;
};
var isResponseWithResult6 = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && "result" in response && isNullish(response.error) && (typeof response.id === "number" || typeof response.id === "string");
var isResponseWithError7 = (response) => !Array.isArray(response) && response.jsonrpc === "2.0" && !!response && isNullish(response.result) && "error" in response && (typeof response.id === "number" || typeof response.id === "string");
var isResponseWithNotification6 = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && !isNullish(response.params) && !isNullish(response.method);
var isSubscriptionResult6 = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && "id" in response && "result" in response;
var validateResponse6 = (response) => isResponseWithResult6(response) || isResponseWithError7(response);
var isValidResponse6 = (response) => Array.isArray(response) ? response.every(validateResponse6) : validateResponse6(response);
var isBatchResponse6 = (response) => Array.isArray(response) && response.length > 0 && isValidResponse6(response);
var requestIdSeed6;
var setRequestIdStart6 = (start) => {
  requestIdSeed6 = start;
};
var toPayload6 = (request) => {
  var _a16, _b, _c, _d;
  if (typeof requestIdSeed6 !== "undefined") {
    requestIdSeed6 += 1;
  }
  return {
    jsonrpc: (_a16 = request.jsonrpc) !== null && _a16 !== void 0 ? _a16 : "2.0",
    id: (_c = (_b = request.id) !== null && _b !== void 0 ? _b : requestIdSeed6) !== null && _c !== void 0 ? _c : uuidV46(),
    method: request.method,
    params: (_d = request.params) !== null && _d !== void 0 ? _d : void 0
  };
};
var toBatchPayload6 = (requests) => requests.map((request) => toPayload6(request));
var isBatchRequest6 = (request) => Array.isArray(request) && request.length > 0;

// node_modules/web3-eth-contract/node_modules/web3-utils/lib/esm/web3_deferred_promise.js
init_shim();
var __awaiter58 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a10;
var Web3DeferredPromise6 = class {
  constructor({ timeout, eagerStart, timeoutMessage } = {
    timeout: 0,
    eagerStart: false,
    timeoutMessage: "DeferredPromise timed out"
  }) {
    this[_a10] = "Promise";
    this._state = "pending";
    this._promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
    this._timeoutMessage = timeoutMessage;
    this._timeoutInterval = timeout;
    if (eagerStart) {
      this.startTimer();
    }
  }
  get state() {
    return this._state;
  }
  then(onfulfilled, onrejected) {
    return __awaiter58(this, void 0, void 0, function* () {
      return this._promise.then(onfulfilled, onrejected);
    });
  }
  catch(onrejected) {
    return __awaiter58(this, void 0, void 0, function* () {
      return this._promise.catch(onrejected);
    });
  }
  finally(onfinally) {
    return __awaiter58(this, void 0, void 0, function* () {
      return this._promise.finally(onfinally);
    });
  }
  resolve(value) {
    this._resolve(value);
    this._state = "fulfilled";
    this._clearTimeout();
  }
  reject(reason) {
    this._reject(reason);
    this._state = "rejected";
    this._clearTimeout();
  }
  startTimer() {
    if (this._timeoutInterval && this._timeoutInterval > 0) {
      this._timeoutId = setTimeout(this._checkTimeout.bind(this), this._timeoutInterval);
    }
  }
  _checkTimeout() {
    if (this._state === "pending" && this._timeoutId) {
      this.reject(new OperationTimeoutError(this._timeoutMessage));
    }
  }
  _clearTimeout() {
    if (this._timeoutId) {
      clearTimeout(this._timeoutId);
    }
  }
};
_a10 = Symbol.toStringTag;

// node_modules/web3-eth-contract/node_modules/web3-utils/lib/esm/chunk_response_parser.js
init_shim();
var ChunkResponseParser6 = class {
  constructor(eventEmitter, autoReconnect) {
    this.eventEmitter = eventEmitter;
    this.autoReconnect = autoReconnect;
  }
  clearQueues() {
    if (typeof this._clearQueues === "function") {
      this._clearQueues();
    }
  }
  onError(clearQueues) {
    this._clearQueues = clearQueues;
  }
  parseResponse(data) {
    const returnValues = [];
    const dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
    dechunkedData.forEach((_chunkData) => {
      let chunkData = _chunkData;
      if (this.lastChunk) {
        chunkData = this.lastChunk + chunkData;
      }
      let result;
      try {
        result = JSON.parse(chunkData);
      } catch (e) {
        this.lastChunk = chunkData;
        if (this.lastChunkTimeout) {
          clearTimeout(this.lastChunkTimeout);
        }
        this.lastChunkTimeout = setTimeout(() => {
          if (this.autoReconnect)
            return;
          this.clearQueues();
          this.eventEmitter.emit("error", new InvalidResponseError({
            id: 1,
            jsonrpc: "2.0",
            error: { code: 2, message: "Chunk timeout" }
          }));
        }, 1e3 * 15);
        return;
      }
      clearTimeout(this.lastChunkTimeout);
      this.lastChunk = void 0;
      if (result)
        returnValues.push(result);
    });
    return returnValues;
  }
};

// node_modules/web3-eth-contract/node_modules/web3-utils/lib/esm/web3_eip1193_provider.js
init_shim();
var import_events12 = __toESM(require_events(), 1);
var __awaiter59 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Eip1193Provider6 = class extends Web3BaseProvider {
  constructor() {
    super(...arguments);
    this._eventEmitter = new import_events12.EventEmitter();
    this._chainId = "";
    this._accounts = [];
  }
  _getChainId() {
    var _a16;
    return __awaiter59(this, void 0, void 0, function* () {
      const data = yield this.request(toPayload6({
        method: "eth_chainId",
        params: []
      }));
      return (_a16 = data === null || data === void 0 ? void 0 : data.result) !== null && _a16 !== void 0 ? _a16 : "";
    });
  }
  _getAccounts() {
    var _a16;
    return __awaiter59(this, void 0, void 0, function* () {
      const data = yield this.request(toPayload6({
        method: "eth_accounts",
        params: []
      }));
      return (_a16 = data === null || data === void 0 ? void 0 : data.result) !== null && _a16 !== void 0 ? _a16 : [];
    });
  }
  _onConnect() {
    Promise.all([
      this._getChainId().then((chainId) => {
        if (chainId !== this._chainId) {
          this._chainId = chainId;
          this._eventEmitter.emit("chainChanged", this._chainId);
        }
      }).catch((err) => {
        console.error(err);
      }),
      this._getAccounts().then((accounts) => {
        if (!(this._accounts.length === accounts.length && accounts.every((v) => accounts.includes(v)))) {
          this._accounts = accounts;
          this._onAccountsChanged();
        }
      }).catch((err) => {
        console.error(err);
      })
    ]).then(() => this._eventEmitter.emit("connect", {
      chainId: this._chainId
    })).catch((err) => {
      console.error(err);
    });
  }
  _onDisconnect(code, data) {
    this._eventEmitter.emit("disconnect", new EIP1193ProviderRpcError(code, data));
  }
  _onAccountsChanged() {
    this._eventEmitter.emit("accountsChanged", this._accounts);
  }
};

// node_modules/web3-eth-contract/node_modules/web3-utils/lib/esm/socket_provider.js
init_shim();
var __awaiter60 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_RECONNECTION_OPTIONS4 = {
  autoReconnect: true,
  delay: 5e3,
  maxAttempts: 5
};
var NORMAL_CLOSE_CODE4 = 1e3;
var SocketProvider4 = class extends Eip1193Provider6 {
  constructor(socketPath, socketOptions, reconnectOptions) {
    super();
    this._connectionStatus = "connecting";
    this._onMessageHandler = this._onMessage.bind(this);
    this._onOpenHandler = this._onConnect.bind(this);
    this._onCloseHandler = this._onCloseEvent.bind(this);
    this._onErrorHandler = this._onError.bind(this);
    if (!this._validateProviderPath(socketPath))
      throw new InvalidClientError(socketPath);
    this._socketPath = socketPath;
    this._socketOptions = socketOptions;
    this._reconnectOptions = Object.assign(Object.assign({}, DEFAULT_RECONNECTION_OPTIONS4), reconnectOptions !== null && reconnectOptions !== void 0 ? reconnectOptions : {});
    this._pendingRequestsQueue = /* @__PURE__ */ new Map();
    this._sentRequestsQueue = /* @__PURE__ */ new Map();
    this._init();
    this.connect();
    this.chunkResponseParser = new ChunkResponseParser6(this._eventEmitter, this._reconnectOptions.autoReconnect);
    this.chunkResponseParser.onError(() => {
      this._clearQueues();
    });
    this.isReconnecting = false;
  }
  get SocketConnection() {
    return this._socketConnection;
  }
  _init() {
    this._reconnectAttempts = 0;
  }
  connect() {
    try {
      this._openSocketConnection();
      this._connectionStatus = "connecting";
      this._addSocketListeners();
    } catch (e) {
      if (!this.isReconnecting) {
        this._connectionStatus = "disconnected";
        if (e && e.message) {
          throw new ConnectionError(`Error while connecting to ${this._socketPath}. Reason: ${e.message}`);
        } else {
          throw new InvalidClientError(this._socketPath);
        }
      } else {
        setImmediate(() => {
          this._reconnect();
        });
      }
    }
  }
  _validateProviderPath(path) {
    return !!path;
  }
  supportsSubscriptions() {
    return true;
  }
  on(type, listener) {
    this._eventEmitter.on(type, listener);
  }
  once(type, listener) {
    this._eventEmitter.once(type, listener);
  }
  removeListener(type, listener) {
    this._eventEmitter.removeListener(type, listener);
  }
  _onDisconnect(code, data) {
    this._connectionStatus = "disconnected";
    super._onDisconnect(code, data);
  }
  disconnect(code, data) {
    const disconnectCode = code !== null && code !== void 0 ? code : NORMAL_CLOSE_CODE4;
    this._removeSocketListeners();
    if (this.getStatus() !== "disconnected") {
      this._closeSocketConnection(disconnectCode, data);
    }
    this._onDisconnect(disconnectCode, data);
  }
  removeAllListeners(type) {
    this._eventEmitter.removeAllListeners(type);
  }
  _onError(event) {
    if (this.isReconnecting) {
      this._reconnect();
    } else {
      this._eventEmitter.emit("error", event);
    }
  }
  reset() {
    this._sentRequestsQueue.clear();
    this._pendingRequestsQueue.clear();
    this._init();
    this._removeSocketListeners();
    this._addSocketListeners();
  }
  _reconnect() {
    if (this.isReconnecting) {
      return;
    }
    this.isReconnecting = true;
    if (this._sentRequestsQueue.size > 0) {
      this._sentRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new PendingRequestsOnReconnectingError());
        this._sentRequestsQueue.delete(key);
      });
    }
    if (this._reconnectAttempts < this._reconnectOptions.maxAttempts) {
      this._reconnectAttempts += 1;
      setTimeout(() => {
        this._removeSocketListeners();
        this.connect();
        this.isReconnecting = false;
      }, this._reconnectOptions.delay);
    } else {
      this.isReconnecting = false;
      this._clearQueues();
      this._removeSocketListeners();
      this._eventEmitter.emit("error", new MaxAttemptsReachedOnReconnectingError(this._reconnectOptions.maxAttempts));
    }
  }
  request(request) {
    return __awaiter60(this, void 0, void 0, function* () {
      if (isNullish7(this._socketConnection)) {
        throw new Error("Connection is undefined");
      }
      if (this.getStatus() === "disconnected") {
        this.connect();
      }
      const requestId = isBatchRequest6(request) ? request[0].id : request.id;
      if (!requestId) {
        throw new Web3WSProviderError("Request Id not defined");
      }
      if (this._sentRequestsQueue.has(requestId)) {
        throw new RequestAlreadySentError(requestId);
      }
      const deferredPromise = new Web3DeferredPromise6();
      deferredPromise.catch((error) => {
        this._eventEmitter.emit("error", error);
      });
      const reqItem = {
        payload: request,
        deferredPromise
      };
      if (this.getStatus() === "connecting") {
        this._pendingRequestsQueue.set(requestId, reqItem);
        return reqItem.deferredPromise;
      }
      this._sentRequestsQueue.set(requestId, reqItem);
      try {
        this._sendToSocket(reqItem.payload);
      } catch (error) {
        this._sentRequestsQueue.delete(requestId);
        this._eventEmitter.emit("error", error);
      }
      return deferredPromise;
    });
  }
  _onConnect() {
    this._connectionStatus = "connected";
    this._reconnectAttempts = 0;
    super._onConnect();
    this._sendPendingRequests();
  }
  _sendPendingRequests() {
    for (const [id, value] of this._pendingRequestsQueue.entries()) {
      this._sendToSocket(value.payload);
      this._pendingRequestsQueue.delete(id);
      this._sentRequestsQueue.set(id, value);
    }
  }
  _onMessage(event) {
    const responses = this._parseResponses(event);
    if (isNullish7(responses) || responses.length === 0) {
      return;
    }
    for (const response of responses) {
      if (isResponseWithNotification6(response) && response.method.endsWith("_subscription")) {
        this._eventEmitter.emit("message", response);
        return;
      }
      const requestId = isBatchResponse6(response) ? response[0].id : response.id;
      const requestItem = this._sentRequestsQueue.get(requestId);
      if (!requestItem) {
        return;
      }
      if (isBatchResponse6(response) || isResponseWithResult6(response) || isResponseWithError7(response)) {
        this._eventEmitter.emit("message", response);
        requestItem.deferredPromise.resolve(response);
      }
      this._sentRequestsQueue.delete(requestId);
    }
  }
  _clearQueues(event) {
    if (this._pendingRequestsQueue.size > 0) {
      this._pendingRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new ConnectionNotOpenError(event));
        this._pendingRequestsQueue.delete(key);
      });
    }
    if (this._sentRequestsQueue.size > 0) {
      this._sentRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new ConnectionNotOpenError(event));
        this._sentRequestsQueue.delete(key);
      });
    }
    this._removeSocketListeners();
  }
};

// node_modules/web3-eth-contract/node_modules/web3-core/lib/esm/web3_event_emitter.js
init_shim();
var Web3EventEmitter4 = class {
  constructor() {
    this._emitter = new EventEmitter10();
  }
  on(eventName, fn) {
    this._emitter.on(eventName, fn);
  }
  once(eventName, fn) {
    this._emitter.once(eventName, fn);
  }
  off(eventName, fn) {
    this._emitter.off(eventName, fn);
  }
  emit(eventName, params) {
    this._emitter.emit(eventName, params);
  }
  listenerCount(eventName) {
    return this._emitter.listenerCount(eventName);
  }
  listeners(eventName) {
    return this._emitter.listeners(eventName);
  }
  eventNames() {
    return this._emitter.eventNames();
  }
  removeAllListeners() {
    return this._emitter.removeAllListeners();
  }
  setMaxListenerWarningThreshold(maxListenersWarningThreshold) {
    this._emitter.setMaxListeners(maxListenersWarningThreshold);
  }
  getMaxListeners() {
    return this._emitter.getMaxListeners();
  }
};

// node_modules/web3-eth-contract/node_modules/web3-core/lib/esm/web3_config.js
var Web3ConfigEvent4;
(function(Web3ConfigEvent7) {
  Web3ConfigEvent7["CONFIG_CHANGE"] = "CONFIG_CHANGE";
})(Web3ConfigEvent4 || (Web3ConfigEvent4 = {}));
var Web3Config4 = class extends Web3EventEmitter4 {
  constructor(options) {
    super();
    this.config = {
      handleRevert: false,
      defaultAccount: void 0,
      defaultBlock: "latest",
      transactionBlockTimeout: 50,
      transactionConfirmationBlocks: 24,
      transactionPollingInterval: 1e3,
      transactionPollingTimeout: 750 * 1e3,
      transactionReceiptPollingInterval: void 0,
      transactionSendTimeout: 750 * 1e3,
      transactionConfirmationPollingInterval: void 0,
      blockHeaderTimeout: 10,
      maxListenersWarningThreshold: 100,
      contractDataInputFill: "input",
      defaultNetworkId: void 0,
      defaultChain: "mainnet",
      defaultHardfork: "london",
      defaultCommon: void 0,
      defaultTransactionType: "0x2",
      defaultMaxPriorityFeePerGas: toHex6(25e8),
      enableExperimentalFeatures: {
        useSubscriptionWhenCheckingBlockTimeout: false,
        useRpcCallSpecification: false
      },
      transactionBuilder: void 0,
      transactionTypeParser: void 0
    };
    this.setConfig(options !== null && options !== void 0 ? options : {});
  }
  setConfig(options) {
    Object.assign(this.config, options);
  }
  get handleRevert() {
    return this.config.handleRevert;
  }
  set handleRevert(val) {
    this._triggerConfigChange("handleRevert", val);
    this.config.handleRevert = val;
  }
  get contractDataInputFill() {
    return this.config.contractDataInputFill;
  }
  set contractDataInputFill(val) {
    this._triggerConfigChange("contractDataInputFill", val);
    this.config.contractDataInputFill = val;
  }
  get defaultAccount() {
    return this.config.defaultAccount;
  }
  set defaultAccount(val) {
    this._triggerConfigChange("defaultAccount", val);
    this.config.defaultAccount = val;
  }
  get defaultBlock() {
    return this.config.defaultBlock;
  }
  set defaultBlock(val) {
    this._triggerConfigChange("defaultBlock", val);
    this.config.defaultBlock = val;
  }
  get transactionSendTimeout() {
    return this.config.transactionSendTimeout;
  }
  set transactionSendTimeout(val) {
    this._triggerConfigChange("transactionSendTimeout", val);
    this.config.transactionSendTimeout = val;
  }
  get transactionBlockTimeout() {
    return this.config.transactionBlockTimeout;
  }
  set transactionBlockTimeout(val) {
    this._triggerConfigChange("transactionBlockTimeout", val);
    this.config.transactionBlockTimeout = val;
  }
  get transactionConfirmationBlocks() {
    return this.config.transactionConfirmationBlocks;
  }
  set transactionConfirmationBlocks(val) {
    this._triggerConfigChange("transactionConfirmationBlocks", val);
    this.config.transactionConfirmationBlocks = val;
  }
  get transactionPollingInterval() {
    return this.config.transactionPollingInterval;
  }
  set transactionPollingInterval(val) {
    this._triggerConfigChange("transactionPollingInterval", val);
    this.config.transactionPollingInterval = val;
    this.transactionReceiptPollingInterval = val;
    this.transactionConfirmationPollingInterval = val;
  }
  get transactionPollingTimeout() {
    return this.config.transactionPollingTimeout;
  }
  set transactionPollingTimeout(val) {
    this._triggerConfigChange("transactionPollingTimeout", val);
    this.config.transactionPollingTimeout = val;
  }
  get transactionReceiptPollingInterval() {
    return this.config.transactionReceiptPollingInterval;
  }
  set transactionReceiptPollingInterval(val) {
    this._triggerConfigChange("transactionReceiptPollingInterval", val);
    this.config.transactionReceiptPollingInterval = val;
  }
  get transactionConfirmationPollingInterval() {
    return this.config.transactionConfirmationPollingInterval;
  }
  set transactionConfirmationPollingInterval(val) {
    this._triggerConfigChange("transactionConfirmationPollingInterval", val);
    this.config.transactionConfirmationPollingInterval = val;
  }
  get blockHeaderTimeout() {
    return this.config.blockHeaderTimeout;
  }
  set blockHeaderTimeout(val) {
    this._triggerConfigChange("blockHeaderTimeout", val);
    this.config.blockHeaderTimeout = val;
  }
  get enableExperimentalFeatures() {
    return this.config.enableExperimentalFeatures;
  }
  set enableExperimentalFeatures(val) {
    this._triggerConfigChange("enableExperimentalFeatures", val);
    this.config.enableExperimentalFeatures = val;
  }
  get maxListenersWarningThreshold() {
    return this.config.maxListenersWarningThreshold;
  }
  set maxListenersWarningThreshold(val) {
    this._triggerConfigChange("maxListenersWarningThreshold", val);
    this.setMaxListenerWarningThreshold(val);
    this.config.maxListenersWarningThreshold = val;
  }
  get defaultNetworkId() {
    return this.config.defaultNetworkId;
  }
  set defaultNetworkId(val) {
    this._triggerConfigChange("defaultNetworkId", val);
    this.config.defaultNetworkId = val;
  }
  get defaultChain() {
    return this.config.defaultChain;
  }
  set defaultChain(val) {
    if (!isNullish7(this.config.defaultCommon) && !isNullish7(this.config.defaultCommon.baseChain) && val !== this.config.defaultCommon.baseChain)
      throw new ConfigChainMismatchError(this.config.defaultChain, val);
    this._triggerConfigChange("defaultChain", val);
    this.config.defaultChain = val;
  }
  get defaultHardfork() {
    return this.config.defaultHardfork;
  }
  set defaultHardfork(val) {
    if (!isNullish7(this.config.defaultCommon) && !isNullish7(this.config.defaultCommon.hardfork) && val !== this.config.defaultCommon.hardfork)
      throw new ConfigHardforkMismatchError(this.config.defaultCommon.hardfork, val);
    this._triggerConfigChange("defaultHardfork", val);
    this.config.defaultHardfork = val;
  }
  get defaultCommon() {
    return this.config.defaultCommon;
  }
  set defaultCommon(val) {
    if (!isNullish7(this.config.defaultHardfork) && !isNullish7(val) && !isNullish7(val.hardfork) && this.config.defaultHardfork !== val.hardfork)
      throw new ConfigHardforkMismatchError(this.config.defaultHardfork, val.hardfork);
    if (!isNullish7(this.config.defaultChain) && !isNullish7(val) && !isNullish7(val.baseChain) && this.config.defaultChain !== val.baseChain)
      throw new ConfigChainMismatchError(this.config.defaultChain, val.baseChain);
    this._triggerConfigChange("defaultCommon", val);
    this.config.defaultCommon = val;
  }
  get defaultTransactionType() {
    return this.config.defaultTransactionType;
  }
  set defaultTransactionType(val) {
    this._triggerConfigChange("defaultTransactionType", val);
    this.config.defaultTransactionType = val;
  }
  get defaultMaxPriorityFeePerGas() {
    return this.config.defaultMaxPriorityFeePerGas;
  }
  set defaultMaxPriorityFeePerGas(val) {
    this._triggerConfigChange("defaultMaxPriorityFeePerGas", val);
    this.config.defaultMaxPriorityFeePerGas = val;
  }
  get transactionBuilder() {
    return this.config.transactionBuilder;
  }
  set transactionBuilder(val) {
    this._triggerConfigChange("transactionBuilder", val);
    this.config.transactionBuilder = val;
  }
  get transactionTypeParser() {
    return this.config.transactionTypeParser;
  }
  set transactionTypeParser(val) {
    this._triggerConfigChange("transactionTypeParser", val);
    this.config.transactionTypeParser = val;
  }
  _triggerConfigChange(config, newValue) {
    this.emit(Web3ConfigEvent4.CONFIG_CHANGE, {
      name: config,
      oldValue: this.config[config],
      newValue
    });
  }
};

// node_modules/web3-eth-contract/node_modules/web3-core/lib/esm/web3_request_manager.js
init_shim();

// node_modules/web3-eth-contract/node_modules/web3-providers-http/lib/esm/index.js
init_shim();
var import_cross_fetch4 = __toESM(require_browser_ponyfill4());
var __awaiter61 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var HttpProvider4 = class extends Web3BaseProvider {
  constructor(clientUrl, httpProviderOptions) {
    super();
    if (!HttpProvider4.validateClientUrl(clientUrl))
      throw new InvalidClientError(clientUrl);
    this.clientUrl = clientUrl;
    this.httpProviderOptions = httpProviderOptions;
  }
  static validateClientUrl(clientUrl) {
    return typeof clientUrl === "string" ? /^http(s)?:\/\//i.test(clientUrl) : false;
  }
  getStatus() {
    throw new MethodNotImplementedError();
  }
  supportsSubscriptions() {
    return false;
  }
  request(payload, requestOptions) {
    var _a16;
    return __awaiter61(this, void 0, void 0, function* () {
      const providerOptionsCombined = Object.assign(Object.assign({}, (_a16 = this.httpProviderOptions) === null || _a16 === void 0 ? void 0 : _a16.providerOptions), requestOptions);
      const response = yield (0, import_cross_fetch4.default)(this.clientUrl, Object.assign(Object.assign({}, providerOptionsCombined), { method: "POST", headers: Object.assign(Object.assign({}, providerOptionsCombined.headers), { "Content-Type": "application/json" }), body: JSON.stringify(payload) }));
      if (!response.ok)
        throw new ResponseError(yield response.json());
      return yield response.json();
    });
  }
  on() {
    throw new MethodNotImplementedError();
  }
  removeListener() {
    throw new MethodNotImplementedError();
  }
  once() {
    throw new MethodNotImplementedError();
  }
  removeAllListeners() {
    throw new MethodNotImplementedError();
  }
  connect() {
    throw new MethodNotImplementedError();
  }
  disconnect() {
    throw new MethodNotImplementedError();
  }
  reset() {
    throw new MethodNotImplementedError();
  }
  reconnect() {
    throw new MethodNotImplementedError();
  }
};

// node_modules/web3-eth-contract/node_modules/web3-providers-ws/lib/esm/index.js
init_shim();

// node_modules/web3-eth-contract/node_modules/isomorphic-ws/browser.js
init_shim();
var ws4 = null;
if (typeof WebSocket !== "undefined") {
  ws4 = WebSocket;
} else if (typeof MozWebSocket !== "undefined") {
  ws4 = MozWebSocket;
} else if (typeof _global !== "undefined") {
  ws4 = _global.WebSocket || _global.MozWebSocket;
} else if (typeof window !== "undefined") {
  ws4 = window.WebSocket || window.MozWebSocket;
} else if (typeof self !== "undefined") {
  ws4 = self.WebSocket || self.MozWebSocket;
}
var browser_default4 = ws4;

// node_modules/web3-eth-contract/node_modules/web3-providers-ws/lib/esm/index.js
var WebSocketProvider4 = class extends SocketProvider4 {
  constructor(socketPath, socketOptions, reconnectOptions) {
    super(socketPath, socketOptions, reconnectOptions);
  }
  _validateProviderPath(providerUrl) {
    return typeof providerUrl === "string" ? /^ws(s)?:\/\//i.test(providerUrl) : false;
  }
  getStatus() {
    if (this._socketConnection && !isNullish7(this._socketConnection)) {
      switch (this._socketConnection.readyState) {
        case this._socketConnection.CONNECTING: {
          return "connecting";
        }
        case this._socketConnection.OPEN: {
          return "connected";
        }
        default: {
          return "disconnected";
        }
      }
    }
    return "disconnected";
  }
  _openSocketConnection() {
    this._socketConnection = new browser_default4(this._socketPath, void 0, this._socketOptions && Object.keys(this._socketOptions).length === 0 ? void 0 : this._socketOptions);
  }
  _closeSocketConnection(code, data) {
    var _a16;
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.close(code, data);
  }
  _sendToSocket(payload) {
    var _a16;
    if (this.getStatus() === "disconnected") {
      throw new ConnectionNotOpenError();
    }
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.send(JSON.stringify(payload));
  }
  _parseResponses(event) {
    return this.chunkResponseParser.parseResponse(event.data);
  }
  _addSocketListeners() {
    var _a16, _b, _c, _d;
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.addEventListener("open", this._onOpenHandler);
    (_b = this._socketConnection) === null || _b === void 0 ? void 0 : _b.addEventListener("message", this._onMessageHandler);
    (_c = this._socketConnection) === null || _c === void 0 ? void 0 : _c.addEventListener("close", (e) => this._onCloseHandler(e));
    (_d = this._socketConnection) === null || _d === void 0 ? void 0 : _d.addEventListener("error", this._onErrorHandler);
  }
  _removeSocketListeners() {
    var _a16, _b, _c;
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.removeEventListener("message", this._onMessageHandler);
    (_b = this._socketConnection) === null || _b === void 0 ? void 0 : _b.removeEventListener("open", this._onOpenHandler);
    (_c = this._socketConnection) === null || _c === void 0 ? void 0 : _c.removeEventListener("close", this._onCloseHandler);
  }
  _onCloseEvent(event) {
    var _a16;
    if (this._reconnectOptions.autoReconnect && (![1e3, 1001].includes(event.code) || !event.wasClean)) {
      this._reconnect();
      return;
    }
    this._clearQueues(event);
    this._removeSocketListeners();
    this._onDisconnect(event.code, event.reason);
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.removeEventListener("error", this._onErrorHandler);
  }
};

// node_modules/web3-eth-contract/node_modules/web3-core/lib/esm/utils.js
init_shim();
var isWeb3Provider4 = (provider) => Web3BaseProvider.isWeb3Provider(provider);
var isMetaMaskProvider4 = (provider) => typeof provider !== "string" && "request" in provider && provider.request.constructor.name === "AsyncFunction" && "isMetaMask" in provider && provider.isMetaMask;
var isLegacyRequestProvider4 = (provider) => typeof provider !== "string" && "request" in provider && provider.request.constructor.name === "Function";
var isEIP1193Provider4 = (provider) => typeof provider !== "string" && "request" in provider && provider.request.constructor.name === "AsyncFunction";
var isLegacySendProvider4 = (provider) => typeof provider !== "string" && "send" in provider;
var isLegacySendAsyncProvider4 = (provider) => typeof provider !== "string" && "sendAsync" in provider;
var isSupportedProvider4 = (provider) => provider && (isWeb3Provider4(provider) || isEIP1193Provider4(provider) || isLegacyRequestProvider4(provider) || isLegacySendAsyncProvider4(provider) || isLegacySendProvider4(provider));
var isSupportSubscriptions4 = (provider) => {
  if (provider && "supportsSubscriptions" in provider) {
    return provider.supportsSubscriptions();
  }
  if (provider && typeof provider !== "string" && "on" in provider) {
    return true;
  }
  return false;
};

// node_modules/web3-eth-contract/node_modules/web3-core/lib/esm/web3_request_manager.js
var __awaiter62 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3RequestManagerEvent4;
(function(Web3RequestManagerEvent7) {
  Web3RequestManagerEvent7["PROVIDER_CHANGED"] = "PROVIDER_CHANGED";
  Web3RequestManagerEvent7["BEFORE_PROVIDER_CHANGE"] = "BEFORE_PROVIDER_CHANGE";
})(Web3RequestManagerEvent4 || (Web3RequestManagerEvent4 = {}));
var availableProviders4 = {
  HttpProvider: HttpProvider4,
  WebsocketProvider: WebSocketProvider4
};
var metamaskPayload4 = (payload) => {
  var _a16;
  if (Array.isArray(payload.params)) {
    const params = payload.params[0];
    if (params.input && !params.data) {
      return Object.assign(Object.assign({}, payload), { params: [Object.assign(Object.assign({}, params), { data: (_a16 = params.data) !== null && _a16 !== void 0 ? _a16 : params.input })] });
    }
  }
  return payload;
};
var Web3RequestManager4 = class extends Web3EventEmitter4 {
  constructor(provider, useRpcCallSpecification) {
    super();
    if (!isNullish7(provider)) {
      this.setProvider(provider);
    }
    this.useRpcCallSpecification = useRpcCallSpecification;
  }
  static get providers() {
    return availableProviders4;
  }
  get provider() {
    return this._provider;
  }
  get providers() {
    return availableProviders4;
  }
  setProvider(provider) {
    let newProvider;
    if (provider && typeof provider === "string" && this.providers) {
      if (/^http(s)?:\/\//i.test(provider)) {
        newProvider = new this.providers.HttpProvider(provider);
      } else if (/^ws(s)?:\/\//i.test(provider)) {
        newProvider = new this.providers.WebsocketProvider(provider);
      } else {
        throw new ProviderError(`Can't autodetect provider for "${provider}"`);
      }
    } else if (isNullish7(provider)) {
      newProvider = void 0;
    } else {
      newProvider = provider;
    }
    this.emit(Web3RequestManagerEvent4.BEFORE_PROVIDER_CHANGE, this._provider);
    this._provider = newProvider;
    this.emit(Web3RequestManagerEvent4.PROVIDER_CHANGED, this._provider);
    return true;
  }
  send(request) {
    return __awaiter62(this, void 0, void 0, function* () {
      const response = yield this._sendRequest(request);
      if (json_rpc_exports6.isResponseWithResult(response)) {
        return response.result;
      }
      throw new ResponseError(response);
    });
  }
  sendBatch(request) {
    return __awaiter62(this, void 0, void 0, function* () {
      const response = yield this._sendRequest(request);
      return response;
    });
  }
  _sendRequest(request) {
    return __awaiter62(this, void 0, void 0, function* () {
      const { provider } = this;
      if (isNullish7(provider)) {
        throw new ProviderError("Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.");
      }
      let payload = json_rpc_exports6.isBatchRequest(request) ? json_rpc_exports6.toBatchPayload(request) : json_rpc_exports6.toPayload(request);
      if (isMetaMaskProvider4(provider)) {
        if (payload.method === "eth_sendTransaction") {
          if (!json_rpc_exports6.isBatchRequest(payload)) {
            payload = metamaskPayload4(payload);
          } else {
            payload = payload.map((p) => metamaskPayload4(p));
          }
        }
      }
      if (isWeb3Provider4(provider)) {
        let response;
        try {
          response = yield provider.request(payload);
        } catch (error) {
          response = error;
        }
        return this._processJsonRpcResponse(payload, response, { legacy: false, error: false });
      }
      if (isEIP1193Provider4(provider)) {
        return provider.request(payload).then((res) => this._processJsonRpcResponse(payload, res, {
          legacy: true,
          error: false
        })).catch((error) => this._processJsonRpcResponse(payload, error, { legacy: true, error: true }));
      }
      if (isLegacyRequestProvider4(provider)) {
        return new Promise((resolve, reject) => {
          const rejectWithError = (err) => reject(this._processJsonRpcResponse(payload, err, {
            legacy: true,
            error: true
          }));
          const resolveWithResponse = (response) => resolve(this._processJsonRpcResponse(payload, response, {
            legacy: true,
            error: false
          }));
          const result = provider.request(
            payload,
            (err, response) => {
              if (err) {
                return rejectWithError(err);
              }
              return resolveWithResponse(response);
            }
          );
          if (isPromise4(result)) {
            const responsePromise = result;
            responsePromise.then(resolveWithResponse).catch(rejectWithError);
          }
        });
      }
      if (isLegacySendProvider4(provider)) {
        return new Promise((resolve, reject) => {
          provider.send(payload, (err, response) => {
            if (err) {
              return reject(this._processJsonRpcResponse(payload, err, {
                legacy: true,
                error: true
              }));
            }
            if (isNullish7(response)) {
              throw new ResponseError("", 'Got a "nullish" response from provider.');
            }
            return resolve(this._processJsonRpcResponse(payload, response, {
              legacy: true,
              error: false
            }));
          });
        });
      }
      if (isLegacySendAsyncProvider4(provider)) {
        return provider.sendAsync(payload).then((response) => this._processJsonRpcResponse(payload, response, { legacy: true, error: false })).catch((error) => this._processJsonRpcResponse(payload, error, {
          legacy: true,
          error: true
        }));
      }
      throw new ProviderError("Provider does not have a request or send method to use.");
    });
  }
  _processJsonRpcResponse(payload, response, { legacy, error }) {
    if (isNullish7(response)) {
      return this._buildResponse(
        payload,
        null,
        error
      );
    }
    if (json_rpc_exports6.isResponseWithError(response)) {
      if (this.useRpcCallSpecification && isResponseRpcError6(response)) {
        const rpcErrorResponse = response;
        if (rpcErrorsMap.get(rpcErrorResponse.error.code)) {
          const Err = rpcErrorsMap.get(rpcErrorResponse.error.code).error;
          throw new Err(rpcErrorResponse);
        } else {
          throw new RpcError(rpcErrorResponse);
        }
      } else if (!Web3RequestManager4._isReverted(response)) {
        throw new InvalidResponseError(response, payload);
      }
    }
    if (json_rpc_exports6.isResponseWithResult(response)) {
      return response;
    }
    if (response instanceof Error) {
      Web3RequestManager4._isReverted(response);
      throw response;
    }
    if (!legacy && json_rpc_exports6.isBatchRequest(payload) && json_rpc_exports6.isBatchResponse(response)) {
      return response;
    }
    if (legacy && !error && json_rpc_exports6.isBatchRequest(payload)) {
      return response;
    }
    if (legacy && error && json_rpc_exports6.isBatchRequest(payload)) {
      throw response;
    }
    if (legacy && !json_rpc_exports6.isResponseWithError(response) && !json_rpc_exports6.isResponseWithResult(response)) {
      return this._buildResponse(payload, response, error);
    }
    if (json_rpc_exports6.isBatchRequest(payload) && !Array.isArray(response)) {
      throw new ResponseError(response, "Got normal response for a batch request.");
    }
    if (!json_rpc_exports6.isBatchRequest(payload) && Array.isArray(response)) {
      throw new ResponseError(response, "Got batch response for a normal request.");
    }
    if ((json_rpc_exports6.isResponseWithError(response) || json_rpc_exports6.isResponseWithResult(response)) && !json_rpc_exports6.isBatchRequest(payload)) {
      if (response.id && payload.id !== response.id) {
        throw new InvalidResponseError(response);
      }
    }
    throw new ResponseError(response, "Invalid response");
  }
  static _isReverted(response) {
    let error;
    if (json_rpc_exports6.isResponseWithError(response)) {
      error = response.error;
    } else if (response instanceof Error) {
      error = response;
    }
    if (error === null || error === void 0 ? void 0 : error.message.includes("revert"))
      throw new ContractExecutionError(error);
    return false;
  }
  _buildResponse(payload, response, error) {
    const res = {
      jsonrpc: "2.0",
      id: json_rpc_exports6.isBatchRequest(payload) ? payload[0].id : "id" in payload ? payload.id : null
    };
    if (error) {
      return Object.assign(Object.assign({}, res), { error: response });
    }
    return Object.assign(Object.assign({}, res), { result: response });
  }
};

// node_modules/web3-eth-contract/node_modules/web3-core/lib/esm/web3_subscription_manager.js
init_shim();
var __awaiter63 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3SubscriptionManager4 = class {
  constructor(requestManager, registeredSubscriptions2, tolerateUnlinkedSubscription = false) {
    this.requestManager = requestManager;
    this.registeredSubscriptions = registeredSubscriptions2;
    this.tolerateUnlinkedSubscription = tolerateUnlinkedSubscription;
    this._subscriptions = /* @__PURE__ */ new Map();
    this.requestManager.on(Web3RequestManagerEvent4.BEFORE_PROVIDER_CHANGE, () => __awaiter63(this, void 0, void 0, function* () {
      yield this.unsubscribe();
    }));
    this.requestManager.on(Web3RequestManagerEvent4.PROVIDER_CHANGED, () => {
      this.clear();
      this.listenToProviderEvents();
    });
    this.listenToProviderEvents();
  }
  listenToProviderEvents() {
    const providerAsWebProvider = this.requestManager.provider;
    if (!this.requestManager.provider || typeof (providerAsWebProvider === null || providerAsWebProvider === void 0 ? void 0 : providerAsWebProvider.supportsSubscriptions) === "function" && !(providerAsWebProvider === null || providerAsWebProvider === void 0 ? void 0 : providerAsWebProvider.supportsSubscriptions())) {
      return;
    }
    if (typeof this.requestManager.provider.on === "function") {
      if (typeof this.requestManager.provider.request === "function") {
        this.requestManager.provider.on(
          "message",
          (message) => this.messageListener(message)
        );
      } else {
        providerAsWebProvider.on("data", (data) => this.messageListener(data));
      }
    }
  }
  messageListener(data) {
    var _a16, _b, _c;
    if (!data) {
      throw new SubscriptionError("Should not call messageListener with no data. Type was");
    }
    const subscriptionId = ((_a16 = data.params) === null || _a16 === void 0 ? void 0 : _a16.subscription) || ((_b = data.data) === null || _b === void 0 ? void 0 : _b.subscription) || ((_c = data.id) === null || _c === void 0 ? void 0 : _c.toString(16));
    if (subscriptionId) {
      const sub = this._subscriptions.get(subscriptionId);
      sub === null || sub === void 0 ? void 0 : sub.processSubscriptionData(data);
    }
  }
  subscribe(name2, args, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter63(this, void 0, void 0, function* () {
      const Klass = this.registeredSubscriptions[name2];
      if (!Klass) {
        throw new SubscriptionError("Invalid subscription type");
      }
      const subscription = new Klass(args !== null && args !== void 0 ? args : void 0, {
        subscriptionManager: this,
        returnFormat
      });
      yield this.addSubscription(subscription);
      return subscription;
    });
  }
  get subscriptions() {
    return this._subscriptions;
  }
  addSubscription(sub) {
    return __awaiter63(this, void 0, void 0, function* () {
      if (!this.requestManager.provider) {
        throw new ProviderError("Provider not available");
      }
      if (!this.supportsSubscriptions()) {
        throw new SubscriptionError("The current provider does not support subscriptions");
      }
      if (sub.id && this._subscriptions.has(sub.id)) {
        throw new SubscriptionError(`Subscription with id "${sub.id}" already exists`);
      }
      yield sub.sendSubscriptionRequest();
      if (isNullish7(sub.id)) {
        throw new SubscriptionError("Subscription is not subscribed yet.");
      }
      this._subscriptions.set(sub.id, sub);
      return sub.id;
    });
  }
  removeSubscription(sub) {
    return __awaiter63(this, void 0, void 0, function* () {
      const { id } = sub;
      if (isNullish7(id)) {
        throw new SubscriptionError("Subscription is not subscribed yet. Or, had already been unsubscribed but not through the Subscription Manager.");
      }
      if (!this._subscriptions.has(id) && !this.tolerateUnlinkedSubscription) {
        throw new SubscriptionError(`Subscription with id "${id.toString()}" does not exists`);
      }
      yield sub.sendUnsubscribeRequest();
      this._subscriptions.delete(id);
      return id;
    });
  }
  unsubscribe(condition) {
    return __awaiter63(this, void 0, void 0, function* () {
      const result = [];
      for (const [id, sub] of this.subscriptions.entries()) {
        if (!condition || typeof condition === "function" && condition({ id, sub })) {
          result.push(this.removeSubscription(sub));
        }
      }
      return Promise.all(result);
    });
  }
  clear() {
    this._subscriptions.clear();
  }
  supportsSubscriptions() {
    return isNullish7(this.requestManager.provider) ? false : isSupportSubscriptions4(this.requestManager.provider);
  }
};

// node_modules/web3-eth-contract/node_modules/web3-core/lib/esm/web3_subscriptions.js
init_shim();
var __awaiter64 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3Subscription3 = class extends Web3EventEmitter4 {
  constructor(args, options) {
    var _a16;
    super();
    this.args = args;
    const { requestManager } = options;
    const { subscriptionManager } = options;
    if (requestManager && subscriptionManager) {
      throw new SubscriptionError("Only requestManager or subscriptionManager should be provided at Subscription constructor");
    }
    if (!requestManager && !subscriptionManager) {
      throw new SubscriptionError("Either requestManager or subscriptionManager should be provided at Subscription constructor");
    }
    if (requestManager) {
      this._subscriptionManager = new Web3SubscriptionManager4(requestManager, {}, true);
    } else {
      this._subscriptionManager = subscriptionManager;
    }
    this._returnFormat = (_a16 = options === null || options === void 0 ? void 0 : options.returnFormat) !== null && _a16 !== void 0 ? _a16 : DEFAULT_RETURN_FORMAT;
  }
  get id() {
    return this._id;
  }
  get lastBlock() {
    return this._lastBlock;
  }
  subscribe() {
    return __awaiter64(this, void 0, void 0, function* () {
      return this._subscriptionManager.addSubscription(this);
    });
  }
  processSubscriptionData(data) {
    var _a16, _b;
    if (data === null || data === void 0 ? void 0 : data.data) {
      this._processSubscriptionResult((_b = (_a16 = data === null || data === void 0 ? void 0 : data.data) === null || _a16 === void 0 ? void 0 : _a16.result) !== null && _b !== void 0 ? _b : data === null || data === void 0 ? void 0 : data.data);
    } else if (data && json_rpc_exports6.isResponseWithNotification(data)) {
      this._processSubscriptionResult(data === null || data === void 0 ? void 0 : data.params.result);
    }
  }
  sendSubscriptionRequest() {
    return __awaiter64(this, void 0, void 0, function* () {
      this._id = yield this._subscriptionManager.requestManager.send({
        method: "eth_subscribe",
        params: this._buildSubscriptionParams()
      });
      this.emit("connected", this._id);
      return this._id;
    });
  }
  get returnFormat() {
    return this._returnFormat;
  }
  get subscriptionManager() {
    return this._subscriptionManager;
  }
  resubscribe() {
    return __awaiter64(this, void 0, void 0, function* () {
      yield this.unsubscribe();
      yield this.subscribe();
    });
  }
  unsubscribe() {
    return __awaiter64(this, void 0, void 0, function* () {
      if (!this.id) {
        return;
      }
      yield this._subscriptionManager.removeSubscription(this);
    });
  }
  sendUnsubscribeRequest() {
    return __awaiter64(this, void 0, void 0, function* () {
      yield this._subscriptionManager.requestManager.send({
        method: "eth_unsubscribe",
        params: [this.id]
      });
      this._id = void 0;
    });
  }
  formatSubscriptionResult(data) {
    return data;
  }
  _processSubscriptionResult(data) {
    this.emit("data", this.formatSubscriptionResult(data));
  }
  _processSubscriptionError(error) {
    this.emit("error", error);
  }
  _buildSubscriptionParams() {
    throw new Error("Implement in the child class");
  }
};

// node_modules/web3-eth-contract/node_modules/web3-core/lib/esm/web3_context.js
init_shim();

// node_modules/web3-eth-contract/node_modules/web3-core/lib/esm/web3_batch_request.js
init_shim();
var __awaiter65 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_BATCH_REQUEST_TIMEOUT4 = 1e3;
var Web3BatchRequest4 = class {
  constructor(requestManager) {
    this._requestManager = requestManager;
    this._requests = /* @__PURE__ */ new Map();
  }
  get requests() {
    return [...this._requests.values()].map((r) => r.payload);
  }
  add(request) {
    const payload = json_rpc_exports6.toPayload(request);
    const promise = new Web3DeferredPromise6();
    this._requests.set(payload.id, { payload, promise });
    return promise;
  }
  execute(options) {
    var _a16;
    return __awaiter65(this, void 0, void 0, function* () {
      if (this.requests.length === 0) {
        return Promise.resolve([]);
      }
      const request = new Web3DeferredPromise6({
        timeout: (_a16 = options === null || options === void 0 ? void 0 : options.timeout) !== null && _a16 !== void 0 ? _a16 : DEFAULT_BATCH_REQUEST_TIMEOUT4,
        eagerStart: true,
        timeoutMessage: "Batch request timeout"
      });
      this._processBatchRequest(request).catch((err) => request.reject(err));
      request.catch((err) => {
        if (err instanceof OperationTimeoutError) {
          this._abortAllRequests("Batch request timeout");
        }
        request.reject(err);
      });
      return request;
    });
  }
  _processBatchRequest(promise) {
    var _a16, _b;
    return __awaiter65(this, void 0, void 0, function* () {
      const response = yield this._requestManager.sendBatch([...this._requests.values()].map((r) => r.payload));
      if (response.length !== this._requests.size) {
        this._abortAllRequests("Invalid batch response");
        throw new ResponseError(response, `Batch request size mismatch the results size. Requests: ${this._requests.size}, Responses: ${response.length}`);
      }
      const requestIds = this.requests.map((r) => r.id).map(Number).sort((a, b) => a - b);
      const responseIds = response.map((r) => r.id).map(Number).sort((a, b) => a - b);
      if (JSON.stringify(requestIds) !== JSON.stringify(responseIds)) {
        this._abortAllRequests("Invalid batch response");
        throw new ResponseError(response, `Batch request mismatch the results. Requests: [${requestIds.join()}], Responses: [${responseIds.join()}]`);
      }
      for (const res of response) {
        if (json_rpc_exports6.isResponseWithResult(res)) {
          (_a16 = this._requests.get(res.id)) === null || _a16 === void 0 ? void 0 : _a16.promise.resolve(res.result);
        } else if (json_rpc_exports6.isResponseWithError(res)) {
          (_b = this._requests.get(res.id)) === null || _b === void 0 ? void 0 : _b.promise.reject(res.error);
        }
      }
      promise.resolve(response);
    });
  }
  _abortAllRequests(msg) {
    for (const { promise } of this._requests.values()) {
      promise.reject(new OperationAbortError(msg));
    }
  }
};

// node_modules/web3-eth-contract/node_modules/web3-core/lib/esm/web3_context.js
var __awaiter66 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3Context4 = class extends Web3Config4 {
  constructor(providerOrContext) {
    var _a16;
    super();
    this.providers = Web3RequestManager4.providers;
    if (isNullish7(providerOrContext) || typeof providerOrContext === "string" && providerOrContext.trim() !== "" || isSupportedProvider4(providerOrContext)) {
      this._requestManager = new Web3RequestManager4(providerOrContext);
      this._subscriptionManager = new Web3SubscriptionManager4(this._requestManager, {});
      return;
    }
    const { config, provider, requestManager, subscriptionManager, registeredSubscriptions: registeredSubscriptions2, accountProvider, wallet } = providerOrContext;
    this.setConfig(config !== null && config !== void 0 ? config : {});
    this._requestManager = requestManager !== null && requestManager !== void 0 ? requestManager : new Web3RequestManager4(provider, (_a16 = config === null || config === void 0 ? void 0 : config.enableExperimentalFeatures) === null || _a16 === void 0 ? void 0 : _a16.useSubscriptionWhenCheckingBlockTimeout);
    if (subscriptionManager) {
      this._subscriptionManager = subscriptionManager;
    } else {
      this._subscriptionManager = new Web3SubscriptionManager4(this.requestManager, registeredSubscriptions2 !== null && registeredSubscriptions2 !== void 0 ? registeredSubscriptions2 : {});
    }
    if (accountProvider) {
      this._accountProvider = accountProvider;
    }
    if (wallet) {
      this._wallet = wallet;
    }
  }
  get requestManager() {
    return this._requestManager;
  }
  get subscriptionManager() {
    return this._subscriptionManager;
  }
  get wallet() {
    return this._wallet;
  }
  get accountProvider() {
    return this._accountProvider;
  }
  static fromContextObject(...args) {
    return new this(...args.reverse());
  }
  getContextObject() {
    var _a16;
    return {
      config: this.config,
      provider: this.provider,
      requestManager: this.requestManager,
      subscriptionManager: this.subscriptionManager,
      registeredSubscriptions: (_a16 = this.subscriptionManager) === null || _a16 === void 0 ? void 0 : _a16.registeredSubscriptions,
      providers: this.providers,
      wallet: this.wallet,
      accountProvider: this.accountProvider
    };
  }
  use(ContextRef, ...args) {
    const newContextChild = new ContextRef(...[...args, this.getContextObject()]);
    this.on(Web3ConfigEvent4.CONFIG_CHANGE, (event) => {
      newContextChild.setConfig({ [event.name]: event.newValue });
    });
    return newContextChild;
  }
  link(parentContext) {
    this.setConfig(parentContext.config);
    this._requestManager = parentContext.requestManager;
    this.provider = parentContext.provider;
    this._subscriptionManager = parentContext.subscriptionManager;
    this._wallet = parentContext.wallet;
    this._accountProvider = parentContext._accountProvider;
    parentContext.on(Web3ConfigEvent4.CONFIG_CHANGE, (event) => {
      this.setConfig({ [event.name]: event.newValue });
    });
  }
  registerPlugin(plugin) {
    if (this[plugin.pluginNamespace] !== void 0)
      throw new ExistingPluginNamespaceError(plugin.pluginNamespace);
    const _pluginObject = {
      [plugin.pluginNamespace]: plugin
    };
    _pluginObject[plugin.pluginNamespace].link(this);
    Object.assign(this, _pluginObject);
  }
  get provider() {
    return this.currentProvider;
  }
  set provider(provider) {
    this.requestManager.setProvider(provider);
  }
  get currentProvider() {
    return this.requestManager.provider;
  }
  set currentProvider(provider) {
    this.requestManager.setProvider(provider);
  }
  get givenProvider() {
    return Web3Context4.givenProvider;
  }
  setProvider(provider) {
    this.provider = provider;
    return true;
  }
  get BatchRequest() {
    return Web3BatchRequest4.bind(void 0, this._requestManager);
  }
  extend(extendObj) {
    var _a16;
    if (extendObj.property && !this[extendObj.property])
      this[extendObj.property] = {};
    (_a16 = extendObj.methods) === null || _a16 === void 0 ? void 0 : _a16.forEach((element) => {
      const method = (...givenParams) => __awaiter66(this, void 0, void 0, function* () {
        return this.requestManager.send({
          method: element.call,
          params: givenParams
        });
      });
      if (extendObj.property)
        this[extendObj.property][element.name] = method;
      else
        this[element.name] = method;
    });
    return this;
  }
};
Web3Context4.providers = Web3RequestManager4.providers;

// node_modules/web3-eth-contract/node_modules/web3-core/lib/esm/types.js
init_shim();

// node_modules/web3-eth-contract/node_modules/web3-core/lib/esm/formatters.js
var formatters_exports4 = {};
__export(formatters_exports4, {
  inputAddressFormatter: () => inputAddressFormatter4,
  inputBlockNumberFormatter: () => inputBlockNumberFormatter4,
  inputCallFormatter: () => inputCallFormatter4,
  inputDefaultBlockNumberFormatter: () => inputDefaultBlockNumberFormatter4,
  inputLogFormatter: () => inputLogFormatter4,
  inputPostFormatter: () => inputPostFormatter4,
  inputSignFormatter: () => inputSignFormatter4,
  inputStorageKeysFormatter: () => inputStorageKeysFormatter4,
  inputTopicFormatter: () => inputTopicFormatter4,
  inputTransactionFormatter: () => inputTransactionFormatter4,
  outputBigIntegerFormatter: () => outputBigIntegerFormatter4,
  outputBlockFormatter: () => outputBlockFormatter4,
  outputLogFormatter: () => outputLogFormatter4,
  outputPostFormatter: () => outputPostFormatter4,
  outputProofFormatter: () => outputProofFormatter4,
  outputSyncingFormatter: () => outputSyncingFormatter4,
  outputTransactionFormatter: () => outputTransactionFormatter4,
  outputTransactionReceiptFormatter: () => outputTransactionReceiptFormatter4,
  txInputOptionsFormatter: () => txInputOptionsFormatter4
});
init_shim();

// node_modules/web3-eth-contract/node_modules/web3-eth-iban/lib/esm/index.js
init_shim();

// node_modules/web3-eth-contract/node_modules/web3-eth-iban/lib/esm/iban.js
init_shim();
var Iban4 = class {
  constructor(iban) {
    this.toAddress = () => {
      if (this.isDirect()) {
        const base36 = this._iban.slice(4);
        const parsedBigInt = Iban4._parseInt(base36, 36);
        const paddedBigInt = leftPad6(parsedBigInt, 40);
        return toChecksumAddress6(paddedBigInt);
      }
      throw new Error("Iban is indirect and cannot be converted. Must be length of 34 or 35");
    };
    if (Iban4.isIndirect(iban) || Iban4.isDirect(iban)) {
      this._iban = iban;
    } else {
      throw new Error("Invalid IBAN was provided");
    }
  }
  static isDirect(iban) {
    return iban.length === 34 || iban.length === 35;
  }
  isDirect() {
    return Iban4.isDirect(this._iban);
  }
  static isIndirect(iban) {
    return iban.length === 20;
  }
  isIndirect() {
    return Iban4.isIndirect(this._iban);
  }
  static isValid(iban) {
    return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(iban) && Iban4._mod9710(Iban4._iso13616Prepare(iban)) === 1;
  }
  isValid() {
    return Iban4.isValid(this._iban);
  }
  static fromBban(bban) {
    const countryCode = "XE";
    const remainder = this._mod9710(this._iso13616Prepare(`${countryCode}00${bban}`));
    const checkDigit = `0${(98 - remainder).toString()}`.slice(-2);
    return new Iban4(`${countryCode}${checkDigit}${bban}`);
  }
  static createIndirect(options) {
    return Iban4.fromBban(`ETH${options.institution}${options.identifier}`);
  }
  static fromAddress(address) {
    if (!isAddress(address)) {
      throw new InvalidAddressError(address);
    }
    const num = BigInt(hexToNumber6(address));
    const base36 = num.toString(36);
    const padded = leftPad6(base36, 15);
    return Iban4.fromBban(padded.toUpperCase());
  }
  static toIban(address) {
    return Iban4.fromAddress(address).toString();
  }
  client() {
    return this.isIndirect() ? this._iban.slice(11) : "";
  }
  checksum() {
    return this._iban.slice(2, 4);
  }
  institution() {
    return this.isIndirect() ? this._iban.slice(7, 11) : "";
  }
  toString() {
    return this._iban;
  }
};
Iban4._iso13616Prepare = (iban) => {
  const A = "A".charCodeAt(0);
  const Z = "Z".charCodeAt(0);
  const upperIban = iban.toUpperCase();
  const modifiedIban = `${upperIban.slice(4)}${upperIban.slice(0, 4)}`;
  return modifiedIban.split("").map((n) => {
    const code = n.charCodeAt(0);
    if (code >= A && code <= Z) {
      return code - A + 10;
    }
    return n;
  }).join("");
};
Iban4._parseInt = (str, base2) => [...str].reduce((acc, curr) => BigInt(parseInt(curr, base2)) + BigInt(base2) * acc, BigInt(0));
Iban4._mod9710 = (iban) => {
  let remainder = iban;
  let block;
  while (remainder.length > 2) {
    block = remainder.slice(0, 9);
    remainder = `${(parseInt(block, 10) % 97).toString()}${remainder.slice(block.length)}`;
  }
  return parseInt(remainder, 10) % 97;
};
Iban4.toAddress = (iban) => {
  const ibanObject = new Iban4(iban);
  return ibanObject.toAddress();
};

// node_modules/web3-eth-contract/node_modules/web3-eth-iban/lib/esm/types.js
init_shim();

// node_modules/web3-eth-contract/node_modules/web3-core/lib/esm/formatters.js
var inputStorageKeysFormatter4 = (keys) => keys.map((num) => numberToHex7(num));
var outputProofFormatter4 = (proof) => ({
  address: toChecksumAddress6(proof.address),
  nonce: hexToNumberString4(proof.nonce),
  balance: hexToNumberString4(proof.balance)
});
var outputBigIntegerFormatter4 = (number) => toNumber6(number);
var inputBlockNumberFormatter4 = (blockNumber) => {
  if (isNullish(blockNumber)) {
    return void 0;
  }
  if (typeof blockNumber === "string" && isBlockTag(blockNumber)) {
    return blockNumber;
  }
  if (blockNumber === "genesis") {
    return "0x0";
  }
  if (typeof blockNumber === "string" && isHexStrict5(blockNumber)) {
    return blockNumber.toLowerCase();
  }
  return numberToHex7(blockNumber);
};
var inputDefaultBlockNumberFormatter4 = (blockNumber, defaultBlock) => {
  if (!blockNumber) {
    return inputBlockNumberFormatter4(defaultBlock);
  }
  return inputBlockNumberFormatter4(blockNumber);
};
var inputAddressFormatter4 = (address) => {
  if (Iban4.isValid(address) && Iban4.isDirect(address)) {
    const iban = new Iban4(address);
    return iban.toAddress().toLowerCase();
  }
  if (isAddress5(address)) {
    return `0x${address.toLowerCase().replace("0x", "")}`;
  }
  throw new FormatterError(`Provided address ${address} is invalid, the capitalization checksum test failed, or it's an indirect IBAN address which can't be converted.`);
};
var txInputOptionsFormatter4 = (options) => {
  var _a16;
  const modifiedOptions = Object.assign({}, options);
  if (options.to) {
    modifiedOptions.to = inputAddressFormatter4(options.to);
  }
  if (options.data && options.input) {
    throw new FormatterError(`You can't have "data" and "input" as properties of transactions at the same time, please use either "data" or "input" instead.`);
  }
  if (!options.input && options.data) {
    modifiedOptions.input = options.data;
    delete modifiedOptions.data;
  }
  if (options.input && !options.input.startsWith("0x")) {
    modifiedOptions.input = `0x${options.input}`;
  }
  if (modifiedOptions.input && !isHexStrict5(modifiedOptions.input)) {
    throw new FormatterError("The input field must be HEX encoded data.");
  }
  if (options.gas || options.gasLimit) {
    modifiedOptions.gas = toNumber6((_a16 = options.gas) !== null && _a16 !== void 0 ? _a16 : options.gasLimit);
  }
  if (options.maxPriorityFeePerGas || options.maxFeePerGas) {
    delete modifiedOptions.gasPrice;
  }
  ["gasPrice", "gas", "value", "maxPriorityFeePerGas", "maxFeePerGas", "nonce", "chainId"].filter((key) => !isNullish(modifiedOptions[key])).forEach((key) => {
    modifiedOptions[key] = numberToHex7(modifiedOptions[key]);
  });
  return modifiedOptions;
};
var inputCallFormatter4 = (options, defaultAccount) => {
  var _a16;
  const opts = txInputOptionsFormatter4(options);
  const from = (_a16 = opts.from) !== null && _a16 !== void 0 ? _a16 : defaultAccount;
  if (from) {
    opts.from = inputAddressFormatter4(from);
  }
  return opts;
};
var inputTransactionFormatter4 = (options, defaultAccount) => {
  var _a16;
  const opts = txInputOptionsFormatter4(options);
  if (!(typeof opts.from === "number") && !(!!opts.from && typeof opts.from === "object")) {
    opts.from = (_a16 = opts.from) !== null && _a16 !== void 0 ? _a16 : defaultAccount;
    if (!options.from && !(typeof options.from === "number")) {
      throw new FormatterError('The send transactions "from" field must be defined!');
    }
    opts.from = inputAddressFormatter4(options.from);
  }
  return opts;
};
var inputSignFormatter4 = (data) => isHexStrict5(data) ? data : utf8ToHex6(data);
var outputTransactionFormatter4 = (tx) => {
  const modifiedTx = Object.assign({}, tx);
  if (tx.blockNumber) {
    modifiedTx.blockNumber = hexToNumber6(tx.blockNumber);
  }
  if (tx.transactionIndex) {
    modifiedTx.transactionIndex = hexToNumber6(tx.transactionIndex);
  }
  modifiedTx.nonce = hexToNumber6(tx.nonce);
  modifiedTx.gas = hexToNumber6(tx.gas);
  if (tx.gasPrice) {
    modifiedTx.gasPrice = outputBigIntegerFormatter4(tx.gasPrice);
  }
  if (tx.maxFeePerGas) {
    modifiedTx.maxFeePerGas = outputBigIntegerFormatter4(tx.maxFeePerGas);
  }
  if (tx.maxPriorityFeePerGas) {
    modifiedTx.maxPriorityFeePerGas = outputBigIntegerFormatter4(tx.maxPriorityFeePerGas);
  }
  if (tx.type) {
    modifiedTx.type = hexToNumber6(tx.type);
  }
  modifiedTx.value = outputBigIntegerFormatter4(tx.value);
  if (tx.to && isAddress5(tx.to)) {
    modifiedTx.to = toChecksumAddress6(tx.to);
  } else {
    modifiedTx.to = void 0;
  }
  if (tx.from) {
    modifiedTx.from = toChecksumAddress6(tx.from);
  }
  return modifiedTx;
};
var inputTopicFormatter4 = (topic) => {
  if (isNullish(topic))
    return null;
  const value = String(topic);
  return isHex(value) ? value : fromUtf85(value);
};
var inputLogFormatter4 = (filter) => {
  var _a16;
  const val = isNullish(filter) ? {} : mergeDeep6({}, filter);
  if (isNullish(val.fromBlock)) {
    val.fromBlock = BlockTags.LATEST;
  }
  val.fromBlock = inputBlockNumberFormatter4(val.fromBlock);
  if (!isNullish(val.toBlock)) {
    val.toBlock = inputBlockNumberFormatter4(val.toBlock);
  }
  val.topics = (_a16 = val.topics) !== null && _a16 !== void 0 ? _a16 : [];
  val.topics = val.topics.map((topic) => Array.isArray(topic) ? topic.map(inputTopicFormatter4) : inputTopicFormatter4(topic));
  if (val.address) {
    val.address = Array.isArray(val.address) ? val.address.map((addr) => inputAddressFormatter4(addr)) : inputAddressFormatter4(val.address);
  }
  return val;
};
var outputLogFormatter4 = (log) => {
  const modifiedLog = Object.assign({}, log);
  const logIndex = typeof log.logIndex === "string" ? log.logIndex : numberToHex7(log.logIndex);
  if (typeof log.blockHash === "string" && typeof log.transactionHash === "string") {
    const shaId = sha3Raw6(`${log.blockHash.replace("0x", "")}${log.transactionHash.replace("0x", "")}${logIndex.replace("0x", "")}`);
    modifiedLog.id = `log_${shaId.replace("0x", "").slice(0, 8)}`;
  } else if (!log.id) {
    modifiedLog.id = void 0;
  }
  if (log.blockNumber && isHexStrict5(log.blockNumber)) {
    modifiedLog.blockNumber = hexToNumber6(log.blockNumber);
  }
  if (log.transactionIndex && isHexStrict5(log.transactionIndex)) {
    modifiedLog.transactionIndex = hexToNumber6(log.transactionIndex);
  }
  if (log.logIndex && isHexStrict5(log.logIndex)) {
    modifiedLog.logIndex = hexToNumber6(log.logIndex);
  }
  if (log.address) {
    modifiedLog.address = toChecksumAddress6(log.address);
  }
  return modifiedLog;
};
var outputTransactionReceiptFormatter4 = (receipt) => {
  if (typeof receipt !== "object") {
    throw new FormatterError(`Received receipt is invalid: ${String(receipt)}`);
  }
  const modifiedReceipt = Object.assign({}, receipt);
  if (receipt.blockNumber) {
    modifiedReceipt.blockNumber = hexToNumber6(receipt.blockNumber);
  }
  if (receipt.transactionIndex) {
    modifiedReceipt.transactionIndex = hexToNumber6(receipt.transactionIndex);
  }
  modifiedReceipt.cumulativeGasUsed = hexToNumber6(receipt.cumulativeGasUsed);
  modifiedReceipt.gasUsed = hexToNumber6(receipt.gasUsed);
  if (receipt.logs && Array.isArray(receipt.logs)) {
    modifiedReceipt.logs = receipt.logs.map(outputLogFormatter4);
  }
  if (receipt.effectiveGasPrice) {
    modifiedReceipt.effectiveGasPrice = hexToNumber6(receipt.effectiveGasPrice);
  }
  if (receipt.contractAddress) {
    modifiedReceipt.contractAddress = toChecksumAddress6(receipt.contractAddress);
  }
  if (receipt.status) {
    modifiedReceipt.status = Boolean(parseInt(receipt.status, 10));
  }
  return modifiedReceipt;
};
var outputBlockFormatter4 = (block) => {
  const modifiedBlock = Object.assign({}, block);
  modifiedBlock.gasLimit = hexToNumber6(block.gasLimit);
  modifiedBlock.gasUsed = hexToNumber6(block.gasUsed);
  modifiedBlock.size = hexToNumber6(block.size);
  modifiedBlock.timestamp = hexToNumber6(block.timestamp);
  if (block.number) {
    modifiedBlock.number = hexToNumber6(block.number);
  }
  if (block.difficulty) {
    modifiedBlock.difficulty = outputBigIntegerFormatter4(block.difficulty);
  }
  if (block.totalDifficulty) {
    modifiedBlock.totalDifficulty = outputBigIntegerFormatter4(block.totalDifficulty);
  }
  if (block.transactions && Array.isArray(block.transactions)) {
    modifiedBlock.transactions = block.transactions.map(outputTransactionFormatter4);
  }
  if (block.miner) {
    modifiedBlock.miner = toChecksumAddress6(block.miner);
  }
  if (block.baseFeePerGas) {
    modifiedBlock.baseFeePerGas = outputBigIntegerFormatter4(block.baseFeePerGas);
  }
  return modifiedBlock;
};
var inputPostFormatter4 = (post) => {
  var _a16;
  const modifiedPost = Object.assign({}, post);
  if (post.ttl) {
    modifiedPost.ttl = numberToHex7(post.ttl);
  }
  if (post.workToProve) {
    modifiedPost.workToProve = numberToHex7(post.workToProve);
  }
  if (post.priority) {
    modifiedPost.priority = numberToHex7(post.priority);
  }
  if (post.topics && !Array.isArray(post.topics)) {
    modifiedPost.topics = post.topics ? [post.topics] : [];
  }
  modifiedPost.topics = (_a16 = modifiedPost.topics) === null || _a16 === void 0 ? void 0 : _a16.map((topic) => topic.startsWith("0x") ? topic : fromUtf85(topic));
  return modifiedPost;
};
var outputPostFormatter4 = (post) => {
  var _a16;
  const modifiedPost = Object.assign({}, post);
  if (post.expiry) {
    modifiedPost.expiry = hexToNumber6(post.expiry);
  }
  if (post.sent) {
    modifiedPost.sent = hexToNumber6(post.sent);
  }
  if (post.ttl) {
    modifiedPost.ttl = hexToNumber6(post.ttl);
  }
  if (post.workProved) {
    modifiedPost.workProved = hexToNumber6(post.workProved);
  }
  if (!post.topics) {
    modifiedPost.topics = [];
  }
  modifiedPost.topics = (_a16 = modifiedPost.topics) === null || _a16 === void 0 ? void 0 : _a16.map(toUtf84);
  return modifiedPost;
};
var outputSyncingFormatter4 = (result) => {
  const modifiedResult = Object.assign({}, result);
  modifiedResult.startingBlock = hexToNumber6(result.startingBlock);
  modifiedResult.currentBlock = hexToNumber6(result.currentBlock);
  modifiedResult.highestBlock = hexToNumber6(result.highestBlock);
  if (result.knownStates) {
    modifiedResult.knownStates = hexToNumber6(result.knownStates);
  }
  if (result.pulledStates) {
    modifiedResult.pulledStates = hexToNumber6(result.pulledStates);
  }
  return modifiedResult;
};

// node_modules/web3-eth-contract/node_modules/web3-core/lib/esm/web3_promi_event.js
init_shim();
var _a11;
_a11 = Symbol.toStringTag;

// node_modules/web3-eth-contract/lib/esm/encoding.js
init_shim();
var encodeEventABI = ({ address }, event, options) => {
  var _a16, _b;
  const topics = options === null || options === void 0 ? void 0 : options.topics;
  const filter = (_a16 = options === null || options === void 0 ? void 0 : options.filter) !== null && _a16 !== void 0 ? _a16 : {};
  const opts = {};
  if (!isNullish7(options === null || options === void 0 ? void 0 : options.fromBlock)) {
    opts.fromBlock = format4(blockSchema.properties.number, options === null || options === void 0 ? void 0 : options.fromBlock, {
      number: FMT_NUMBER.HEX,
      bytes: FMT_BYTES.HEX
    });
  }
  if (!isNullish7(options === null || options === void 0 ? void 0 : options.toBlock)) {
    opts.toBlock = format4(blockSchema.properties.number, options === null || options === void 0 ? void 0 : options.toBlock, {
      number: FMT_NUMBER.HEX,
      bytes: FMT_BYTES.HEX
    });
  }
  if (topics && Array.isArray(topics)) {
    opts.topics = [...topics];
  } else {
    opts.topics = [];
    if (event && !event.anonymous && ![ALL_EVENTS, "allEvents"].includes(event.name)) {
      opts.topics.push((_b = event.signature) !== null && _b !== void 0 ? _b : encodeEventSignature(jsonInterfaceMethodToString(event)));
    }
    if (![ALL_EVENTS, "allEvents"].includes(event.name) && event.inputs) {
      for (const input of event.inputs) {
        if (!input.indexed) {
          continue;
        }
        const value = filter[input.name];
        if (!value) {
          opts.topics.push(null);
          continue;
        }
        if (Array.isArray(value)) {
          opts.topics.push(value.map((v) => encodeParameter(input.type, v)));
        } else if (input.type === "string") {
          opts.topics.push(keccak256Wrapper4(value));
        } else {
          opts.topics.push(encodeParameter(input.type, value));
        }
      }
    }
  }
  if (!opts.topics.length)
    delete opts.topics;
  if (address) {
    opts.address = address.toLowerCase();
  }
  return opts;
};
var encodeMethodABI = (abi, args, deployData) => {
  const inputLength = Array.isArray(abi.inputs) ? abi.inputs.length : 0;
  if (inputLength !== args.length) {
    throw new Web3ContractError(`The number of arguments is not matching the methods required number. You need to pass ${inputLength} arguments.`);
  }
  const params = encodeParameters2(Array.isArray(abi.inputs) ? abi.inputs : [], args).replace("0x", "");
  if (isAbiConstructorFragment(abi)) {
    if (!deployData)
      throw new Web3ContractError("The contract has no contract data option set. This is necessary to append the constructor parameters.");
    if (!deployData.startsWith("0x")) {
      return `0x${deployData}${params}`;
    }
    return `${deployData}${params}`;
  }
  return `${encodeFunctionSignature(abi)}${params}`;
};
var decodeMethodReturn = (abi, returnValues) => {
  if (abi.type === "constructor") {
    return returnValues;
  }
  if (!returnValues) {
    return null;
  }
  const value = returnValues.length >= 2 ? returnValues.slice(2) : returnValues;
  if (!abi.outputs) {
    return null;
  }
  const result = decodeParameters2([...abi.outputs], value);
  if (result.__length__ === 1) {
    return result[0];
  }
  return result;
};

// node_modules/web3-eth-contract/lib/esm/log_subscription.js
init_shim();
var LogsSubscription2 = class extends Web3Subscription3 {
  constructor(args, options) {
    super(args, options);
    this.address = args.address;
    this.topics = args.topics;
    this.abi = args.abi;
    this.jsonInterface = args.jsonInterface;
  }
  _buildSubscriptionParams() {
    return ["logs", { address: this.address, topics: this.topics }];
  }
  formatSubscriptionResult(data) {
    return decodeEventABI(this.abi, data, this.jsonInterface, super.returnFormat);
  }
};

// node_modules/web3-eth-contract/lib/esm/utils.js
init_shim();
var dataInputEncodeMethodHelper = (txParams, abi, params, dataInputFill) => {
  var _a16, _b;
  const tx = {};
  if (!isNullish7(txParams.data) || dataInputFill === "both") {
    tx.data = encodeMethodABI(abi, params, (_a16 = txParams.data) !== null && _a16 !== void 0 ? _a16 : txParams.input);
  }
  if (!isNullish7(txParams.input) || dataInputFill === "both") {
    tx.input = encodeMethodABI(abi, params, (_b = txParams.input) !== null && _b !== void 0 ? _b : txParams.data);
  }
  if (isNullish7(tx.input) && isNullish7(tx.data)) {
    tx[dataInputFill] = encodeMethodABI(abi, params);
  }
  return { data: tx.data, input: tx.input };
};
var getSendTxParams = ({ abi, params, options, contractOptions }) => {
  var _a16, _b, _c;
  const deploymentCall = (_c = (_b = (_a16 = options === null || options === void 0 ? void 0 : options.input) !== null && _a16 !== void 0 ? _a16 : options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : contractOptions.input) !== null && _c !== void 0 ? _c : contractOptions.data;
  if (!deploymentCall && !(options === null || options === void 0 ? void 0 : options.to) && !contractOptions.address) {
    throw new Web3ContractError("Contract address not specified");
  }
  if (!(options === null || options === void 0 ? void 0 : options.from) && !contractOptions.from) {
    throw new Web3ContractError('Contract "from" address not specified');
  }
  let txParams = mergeDeep6({
    to: contractOptions.address,
    gas: contractOptions.gas,
    gasPrice: contractOptions.gasPrice,
    from: contractOptions.from,
    input: contractOptions.input,
    maxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,
    maxFeePerGas: contractOptions.maxFeePerGas,
    data: contractOptions.data
  }, options);
  const dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options === null || options === void 0 ? void 0 : options.dataInputFill);
  txParams = Object.assign(Object.assign({}, txParams), { data: dataInput.data, input: dataInput.input });
  return txParams;
};
var getEthTxCallParams = ({ abi, params, options, contractOptions }) => {
  if (!(options === null || options === void 0 ? void 0 : options.to) && !contractOptions.address) {
    throw new Web3ContractError("Contract address not specified");
  }
  let txParams = mergeDeep6({
    to: contractOptions.address,
    gas: contractOptions.gas,
    gasPrice: contractOptions.gasPrice,
    from: contractOptions.from,
    input: contractOptions.input,
    maxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,
    maxFeePerGas: contractOptions.maxFeePerGas,
    data: contractOptions.data
  }, options);
  const dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options === null || options === void 0 ? void 0 : options.dataInputFill);
  txParams = Object.assign(Object.assign({}, txParams), { data: dataInput.data, input: dataInput.input });
  return txParams;
};
var getEstimateGasParams = ({ abi, params, options, contractOptions }) => {
  let txParams = mergeDeep6({
    to: contractOptions.address,
    gas: contractOptions.gas,
    gasPrice: contractOptions.gasPrice,
    from: contractOptions.from,
    input: contractOptions.input,
    data: contractOptions.data
  }, options);
  const dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options === null || options === void 0 ? void 0 : options.dataInputFill);
  txParams = Object.assign(Object.assign({}, txParams), { data: dataInput.data, input: dataInput.input });
  return txParams;
};
var isContractInitOptions = (options) => typeof options === "object" && !isNullish7(options) && [
  "input",
  "data",
  "from",
  "gas",
  "gasPrice",
  "gasLimit",
  "address",
  "jsonInterface",
  "syncWithContext",
  "dataInputFill"
].some((key) => key in options);
var isWeb3ContractContext = (options) => typeof options === "object" && !isNullish7(options) && !isContractInitOptions(options);
var getCreateAccessListParams = ({ abi, params, options, contractOptions }) => {
  if (!(options === null || options === void 0 ? void 0 : options.to) && !contractOptions.address) {
    throw new Web3ContractError("Contract address not specified");
  }
  if (!(options === null || options === void 0 ? void 0 : options.from) && !contractOptions.from) {
    throw new Web3ContractError('Contract "from" address not specified');
  }
  let txParams = mergeDeep6({
    to: contractOptions.address,
    gas: contractOptions.gas,
    gasPrice: contractOptions.gasPrice,
    from: contractOptions.from,
    input: contractOptions.input,
    maxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,
    maxFeePerGas: contractOptions.maxFeePerGas,
    data: contractOptions.data
  }, options);
  const dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options === null || options === void 0 ? void 0 : options.dataInputFill);
  txParams = Object.assign(Object.assign({}, txParams), { data: dataInput.data, input: dataInput.input });
  return txParams;
};

// node_modules/web3-eth-contract/lib/esm/contract.js
var __awaiter67 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var contractSubscriptions = {
  logs: LogsSubscription2,
  newHeads: NewHeadsSubscription,
  newBlockHeaders: NewHeadsSubscription
};
var Contract = class extends Web3Context4 {
  constructor(jsonInterface, addressOrOptionsOrContext, optionsOrContextOrReturnFormat, contextOrReturnFormat, returnFormat) {
    var _a16, _b, _c;
    const options = isContractInitOptions(addressOrOptionsOrContext) ? addressOrOptionsOrContext : isContractInitOptions(optionsOrContextOrReturnFormat) ? optionsOrContextOrReturnFormat : void 0;
    let contractContext;
    if (isWeb3ContractContext(addressOrOptionsOrContext)) {
      contractContext = addressOrOptionsOrContext;
    } else if (isWeb3ContractContext(optionsOrContextOrReturnFormat)) {
      contractContext = optionsOrContextOrReturnFormat;
    } else {
      contractContext = contextOrReturnFormat;
    }
    let provider;
    if (typeof addressOrOptionsOrContext === "object" && "provider" in addressOrOptionsOrContext) {
      provider = addressOrOptionsOrContext.provider;
    } else if (typeof optionsOrContextOrReturnFormat === "object" && "provider" in optionsOrContextOrReturnFormat) {
      provider = optionsOrContextOrReturnFormat.provider;
    } else if (typeof contextOrReturnFormat === "object" && "provider" in contextOrReturnFormat) {
      provider = contextOrReturnFormat.provider;
    } else {
      provider = Contract.givenProvider;
    }
    super(Object.assign(Object.assign({}, contractContext), { provider, registeredSubscriptions: contractSubscriptions }));
    this.syncWithContext = false;
    this._functions = {};
    if (!isNullish(options) && !isNullish(options.data) && !isNullish(options.input) && this.config.contractDataInputFill !== "both")
      throw new ContractTransactionDataAndInputError({
        data: options.data,
        input: options.input
      });
    this._overloadedMethodAbis = /* @__PURE__ */ new Map();
    const returnDataFormat = isDataFormat2(contextOrReturnFormat) ? contextOrReturnFormat : isDataFormat2(optionsOrContextOrReturnFormat) ? optionsOrContextOrReturnFormat : returnFormat !== null && returnFormat !== void 0 ? returnFormat : DEFAULT_RETURN_FORMAT;
    const address = typeof addressOrOptionsOrContext === "string" ? addressOrOptionsOrContext : void 0;
    if (this.config.contractDataInputFill === "both") {
      this._dataInputFill = this.config.contractDataInputFill;
    } else {
      this._dataInputFill = (_a16 = options === null || options === void 0 ? void 0 : options.dataInputFill) !== null && _a16 !== void 0 ? _a16 : this.config.contractDataInputFill;
    }
    this._parseAndSetJsonInterface(jsonInterface, returnDataFormat);
    if (!isNullish(address)) {
      this._parseAndSetAddress(address, returnDataFormat);
    }
    this.options = {
      address,
      jsonInterface: this._jsonInterface,
      gas: (_b = options === null || options === void 0 ? void 0 : options.gas) !== null && _b !== void 0 ? _b : options === null || options === void 0 ? void 0 : options.gasLimit,
      gasPrice: options === null || options === void 0 ? void 0 : options.gasPrice,
      from: options === null || options === void 0 ? void 0 : options.from,
      input: options === null || options === void 0 ? void 0 : options.input,
      data: options === null || options === void 0 ? void 0 : options.data
    };
    this.syncWithContext = (_c = options === null || options === void 0 ? void 0 : options.syncWithContext) !== null && _c !== void 0 ? _c : false;
    if (contractContext instanceof Web3Context4) {
      this.subscribeToContextEvents(contractContext);
    }
    Object.defineProperty(this.options, "address", {
      set: (value) => this._parseAndSetAddress(value, returnDataFormat),
      get: () => this._address
    });
    Object.defineProperty(this.options, "jsonInterface", {
      set: (value) => this._parseAndSetJsonInterface(value, returnDataFormat),
      get: () => this._jsonInterface
    });
  }
  get events() {
    return this._events;
  }
  get methods() {
    return this._methods;
  }
  clone() {
    let newContract;
    if (this.options.address) {
      newContract = new Contract([...this._jsonInterface, ...this._errorsInterface], this.options.address, {
        gas: this.options.gas,
        gasPrice: this.options.gasPrice,
        from: this.options.from,
        input: this.options.input,
        data: this.options.data,
        provider: this.currentProvider,
        syncWithContext: this.syncWithContext,
        dataInputFill: this._dataInputFill
      }, this.getContextObject());
    } else {
      newContract = new Contract([...this._jsonInterface, ...this._errorsInterface], {
        gas: this.options.gas,
        gasPrice: this.options.gasPrice,
        from: this.options.from,
        input: this.options.input,
        data: this.options.data,
        provider: this.currentProvider,
        syncWithContext: this.syncWithContext,
        dataInputFill: this._dataInputFill
      }, this.getContextObject());
    }
    if (this.context)
      newContract.subscribeToContextEvents(this.context);
    return newContract;
  }
  deploy(deployOptions) {
    var _a16, _b, _c;
    let abi = this._jsonInterface.find((j) => j.type === "constructor");
    if (!abi) {
      abi = {
        type: "constructor",
        inputs: [],
        stateMutability: ""
      };
    }
    const _input = format4({ format: "bytes" }, (_a16 = deployOptions === null || deployOptions === void 0 ? void 0 : deployOptions.input) !== null && _a16 !== void 0 ? _a16 : this.options.input, DEFAULT_RETURN_FORMAT);
    const _data = format4({ format: "bytes" }, (_b = deployOptions === null || deployOptions === void 0 ? void 0 : deployOptions.data) !== null && _b !== void 0 ? _b : this.options.data, DEFAULT_RETURN_FORMAT);
    if ((!_input || _input.trim() === "0x") && (!_data || _data.trim() === "0x")) {
      throw new Web3ContractError("contract creation without any data provided.");
    }
    const args = (_c = deployOptions === null || deployOptions === void 0 ? void 0 : deployOptions.arguments) !== null && _c !== void 0 ? _c : [];
    const contractOptions = Object.assign(Object.assign({}, this.options), { input: _input, data: _data });
    const deployData = _input !== null && _input !== void 0 ? _input : _data;
    return {
      arguments: args,
      send: (options) => {
        const modifiedOptions = Object.assign({}, options);
        return this._contractMethodDeploySend(abi, args, modifiedOptions, contractOptions);
      },
      estimateGas: (options, returnFormat = DEFAULT_RETURN_FORMAT) => __awaiter67(this, void 0, void 0, function* () {
        const modifiedOptions = Object.assign({}, options);
        return this._contractMethodEstimateGas({
          abi,
          params: args,
          returnFormat,
          options: modifiedOptions,
          contractOptions
        });
      }),
      encodeABI: () => encodeMethodABI(abi, args, format4({ format: "bytes" }, deployData, DEFAULT_RETURN_FORMAT))
    };
  }
  getPastEvents(param1, param2, param3) {
    var _a16;
    return __awaiter67(this, void 0, void 0, function* () {
      const eventName = typeof param1 === "string" ? param1 : ALL_EVENTS;
      const options = typeof param1 !== "string" && !isDataFormat2(param1) ? param1 : !isDataFormat2(param2) ? param2 : {};
      const returnFormat = isDataFormat2(param1) ? param1 : isDataFormat2(param2) ? param2 : param3 !== null && param3 !== void 0 ? param3 : DEFAULT_RETURN_FORMAT;
      const abi = eventName === "allEvents" || eventName === ALL_EVENTS ? ALL_EVENTS_ABI : this._jsonInterface.find((j) => "name" in j && j.name === eventName);
      if (!abi) {
        throw new Web3ContractError(`Event ${eventName} not found.`);
      }
      const { fromBlock, toBlock, topics, address } = encodeEventABI(this.options, abi, options !== null && options !== void 0 ? options : {});
      const logs = yield getLogs2(this, { fromBlock, toBlock, topics, address }, returnFormat);
      const decodedLogs = logs.map((log) => typeof log === "string" ? log : decodeEventABI(abi, log, this._jsonInterface, returnFormat));
      const filter = (_a16 = options === null || options === void 0 ? void 0 : options.filter) !== null && _a16 !== void 0 ? _a16 : {};
      const filterKeys = Object.keys(filter);
      if (filterKeys.length > 0) {
        return decodedLogs.filter((log) => {
          if (typeof log === "string")
            return true;
          return filterKeys.every((key) => {
            var _a17;
            if (Array.isArray(filter[key])) {
              return filter[key].some((v) => String(log.returnValues[key]).toUpperCase() === String(v).toUpperCase());
            }
            const inputAbi = (_a17 = abi.inputs) === null || _a17 === void 0 ? void 0 : _a17.filter((input) => input.name === key)[0];
            if ((inputAbi === null || inputAbi === void 0 ? void 0 : inputAbi.indexed) && inputAbi.type === "string") {
              const hashedIndexedString = keccak256Wrapper4(filter[key]);
              if (hashedIndexedString === String(log.returnValues[key]))
                return true;
            }
            return String(log.returnValues[key]).toUpperCase() === String(filter[key]).toUpperCase();
          });
        });
      }
      return decodedLogs;
    });
  }
  _parseAndSetAddress(value, returnFormat = DEFAULT_RETURN_FORMAT) {
    this._address = value ? toChecksumAddress6(format4({ format: "address" }, value, returnFormat)) : value;
  }
  _parseAndSetJsonInterface(abis, returnFormat = DEFAULT_RETURN_FORMAT) {
    var _a16, _b, _c, _d, _e;
    this._functions = {};
    this._methods = {};
    this._events = {};
    let result = [];
    const functionsAbi = abis.filter((abi) => abi.type !== "error");
    const errorsAbi = abis.filter((abi) => isAbiErrorFragment(abi));
    for (const a of functionsAbi) {
      const abi = Object.assign(Object.assign({}, a), { signature: "" });
      if (isAbiFunctionFragment(abi)) {
        const methodName = jsonInterfaceMethodToString(abi);
        const methodSignature = encodeFunctionSignature(methodName);
        abi.signature = methodSignature;
        abi.constant = (_b = (_a16 = abi.stateMutability === "view") !== null && _a16 !== void 0 ? _a16 : abi.stateMutability === "pure") !== null && _b !== void 0 ? _b : abi.constant;
        abi.payable = (_c = abi.stateMutability === "payable") !== null && _c !== void 0 ? _c : abi.payable;
        this._overloadedMethodAbis.set(abi.name, [
          ...(_d = this._overloadedMethodAbis.get(abi.name)) !== null && _d !== void 0 ? _d : [],
          abi
        ]);
        const abiFragment = (_e = this._overloadedMethodAbis.get(abi.name)) !== null && _e !== void 0 ? _e : [];
        const contractMethod = this._createContractMethod(abiFragment, errorsAbi);
        this._functions[methodName] = {
          signature: methodSignature,
          method: contractMethod
        };
        this._methods[abi.name] = this._functions[methodName].method;
        this._methods[methodName] = this._functions[methodName].method;
        this._methods[methodSignature] = this._functions[methodName].method;
      } else if (isAbiEventFragment(abi)) {
        const eventName = jsonInterfaceMethodToString(abi);
        const eventSignature = encodeEventSignature(eventName);
        const event = this._createContractEvent(abi, returnFormat);
        abi.signature = eventSignature;
        if (!(eventName in this._events) || abi.name === "bound") {
          this._events[eventName] = event;
        }
        this._events[abi.name] = event;
        this._events[eventSignature] = event;
      }
      result = [...result, abi];
    }
    this._events.allEvents = this._createContractEvent(ALL_EVENTS_ABI, returnFormat);
    this._jsonInterface = [...result];
    this._errorsInterface = errorsAbi;
  }
  _getAbiParams(abi, params) {
    var _a16;
    try {
      return utils_exports.transformJsonDataToAbiFormat((_a16 = abi.inputs) !== null && _a16 !== void 0 ? _a16 : [], params);
    } catch (error) {
      throw new Web3ContractError(`Invalid parameters for method ${abi.name}: ${error.message}`);
    }
  }
  _createContractMethod(abiArr, errorsAbis) {
    const abi = abiArr[abiArr.length - 1];
    return (...params) => {
      var _a16, _b;
      let abiParams;
      const abis = (_a16 = this._overloadedMethodAbis.get(abi.name)) !== null && _a16 !== void 0 ? _a16 : [];
      let methodAbi = abis[0];
      const internalErrorsAbis = errorsAbis;
      const arrayOfAbis = abis.filter((_abi) => {
        var _a17;
        return ((_a17 = _abi.inputs) !== null && _a17 !== void 0 ? _a17 : []).length === params.length;
      });
      if (abis.length === 1 || arrayOfAbis.length === 0) {
        abiParams = this._getAbiParams(methodAbi, params);
        validator.validate((_b = abi.inputs) !== null && _b !== void 0 ? _b : [], abiParams);
      } else {
        const errors = [];
        for (const _abi of arrayOfAbis) {
          try {
            abiParams = this._getAbiParams(_abi, params);
            validator.validate(_abi.inputs, abiParams);
            methodAbi = _abi;
            break;
          } catch (e) {
            errors.push(e);
          }
        }
        if (errors.length === arrayOfAbis.length) {
          throw new Web3ValidatorError(errors);
        }
      }
      const methods = {
        arguments: abiParams,
        call: (options, block) => __awaiter67(this, void 0, void 0, function* () {
          return this._contractMethodCall(methodAbi, abiParams, internalErrorsAbis, options, block);
        }),
        send: (options) => this._contractMethodSend(methodAbi, abiParams, internalErrorsAbis, options),
        estimateGas: (options, returnFormat = DEFAULT_RETURN_FORMAT) => __awaiter67(this, void 0, void 0, function* () {
          return this._contractMethodEstimateGas({
            abi: methodAbi,
            params: abiParams,
            returnFormat,
            options
          });
        }),
        encodeABI: () => encodeMethodABI(methodAbi, abiParams),
        createAccessList: (options, block) => __awaiter67(this, void 0, void 0, function* () {
          return this._contractMethodCreateAccessList(methodAbi, abiParams, internalErrorsAbis, options, block);
        })
      };
      if (methodAbi.stateMutability === "payable") {
        return methods;
      }
      return methods;
    };
  }
  _contractMethodCall(abi, params, errorsAbi, options, block) {
    var _a16;
    return __awaiter67(this, void 0, void 0, function* () {
      const tx = getEthTxCallParams({
        abi,
        params,
        options: Object.assign(Object.assign({}, options), { dataInputFill: this._dataInputFill }),
        contractOptions: Object.assign(Object.assign({}, this.options), { from: (_a16 = this.options.from) !== null && _a16 !== void 0 ? _a16 : this.config.defaultAccount })
      });
      try {
        const result = yield call2(this, tx, block, DEFAULT_RETURN_FORMAT);
        return decodeMethodReturn(abi, result);
      } catch (error) {
        if (error instanceof ContractExecutionError) {
          decodeContractErrorData(errorsAbi, error.innerError);
        }
        throw error;
      }
    });
  }
  _contractMethodCreateAccessList(abi, params, errorsAbi, options, block) {
    var _a16;
    return __awaiter67(this, void 0, void 0, function* () {
      const tx = getCreateAccessListParams({
        abi,
        params,
        options: Object.assign(Object.assign({}, options), { dataInputFill: this.config.contractDataInputFill }),
        contractOptions: Object.assign(Object.assign({}, this.options), { from: (_a16 = this.options.from) !== null && _a16 !== void 0 ? _a16 : this.config.defaultAccount })
      });
      try {
        return createAccessList2(this, tx, block, DEFAULT_RETURN_FORMAT);
      } catch (error) {
        if (error instanceof ContractExecutionError) {
          decodeContractErrorData(errorsAbi, error.innerError);
        }
        throw error;
      }
    });
  }
  _contractMethodSend(abi, params, errorsAbi, options, contractOptions) {
    var _a16, _b;
    let modifiedContractOptions = contractOptions !== null && contractOptions !== void 0 ? contractOptions : this.options;
    modifiedContractOptions = Object.assign(Object.assign({}, modifiedContractOptions), { input: void 0, from: (_b = (_a16 = modifiedContractOptions.from) !== null && _a16 !== void 0 ? _a16 : this.defaultAccount) !== null && _b !== void 0 ? _b : void 0 });
    const tx = getSendTxParams({
      abi,
      params,
      options: Object.assign(Object.assign({}, options), { dataInputFill: this.config.contractDataInputFill }),
      contractOptions: modifiedContractOptions
    });
    const transactionToSend = sendTransaction3(this, tx, DEFAULT_RETURN_FORMAT, {
      checkRevertBeforeSending: false,
      contractAbi: this._jsonInterface
    });
    void transactionToSend.on("error", (error) => {
      if (error instanceof ContractExecutionError) {
        decodeContractErrorData(errorsAbi, error.innerError);
      }
    });
    return transactionToSend;
  }
  _contractMethodDeploySend(abi, params, options, contractOptions) {
    var _a16, _b;
    let modifiedContractOptions = contractOptions !== null && contractOptions !== void 0 ? contractOptions : this.options;
    modifiedContractOptions = Object.assign(Object.assign({}, modifiedContractOptions), { from: (_b = (_a16 = modifiedContractOptions.from) !== null && _a16 !== void 0 ? _a16 : this.defaultAccount) !== null && _b !== void 0 ? _b : void 0 });
    const tx = getSendTxParams({
      abi,
      params,
      options: Object.assign(Object.assign({}, options), { dataInputFill: this.config.contractDataInputFill }),
      contractOptions: modifiedContractOptions
    });
    return sendTransaction3(this, tx, DEFAULT_RETURN_FORMAT, {
      transactionResolver: (receipt) => {
        if (receipt.status === BigInt(0)) {
          throw new Web3ContractError("code couldn't be stored", receipt);
        }
        const newContract = this.clone();
        newContract.options.address = receipt.contractAddress;
        return newContract;
      },
      contractAbi: this._jsonInterface,
      checkRevertBeforeSending: false
    });
  }
  _contractMethodEstimateGas({ abi, params, returnFormat, options, contractOptions }) {
    return __awaiter67(this, void 0, void 0, function* () {
      const tx = getEstimateGasParams({
        abi,
        params,
        options: Object.assign(Object.assign({}, options), { dataInputFill: this.config.contractDataInputFill }),
        contractOptions: contractOptions !== null && contractOptions !== void 0 ? contractOptions : this.options
      });
      return estimateGas2(this, tx, BlockTags.LATEST, returnFormat);
    });
  }
  _createContractEvent(abi, returnFormat = DEFAULT_RETURN_FORMAT) {
    return (...params) => {
      var _a16;
      const { topics, fromBlock } = encodeEventABI(this.options, abi, params[0]);
      const sub = new LogsSubscription2({
        address: this.options.address,
        topics,
        abi,
        jsonInterface: this._jsonInterface
      }, {
        subscriptionManager: this.subscriptionManager,
        returnFormat
      });
      if (!isNullish(fromBlock)) {
        this.getPastEvents(abi.name, { fromBlock, topics }, returnFormat).then((logs) => {
          logs.forEach((log) => sub.emit("data", log));
        }).catch((error) => {
          sub.emit("error", new SubscriptionError("Failed to get past events.", error));
        });
      }
      (_a16 = this.subscriptionManager) === null || _a16 === void 0 ? void 0 : _a16.addSubscription(sub).catch((error) => {
        sub.emit("error", new SubscriptionError("Failed to subscribe.", error));
      });
      return sub;
    };
  }
  subscribeToContextEvents(context) {
    const contractThis = this;
    this.context = context;
    if (contractThis.syncWithContext) {
      context.on(Web3ConfigEvent4.CONFIG_CHANGE, (event) => {
        contractThis.setConfig({ [event.name]: event.newValue });
      });
    }
  }
};

// node_modules/web3-eth-contract/lib/esm/types.js
init_shim();

// node_modules/web3-eth-contract/lib/esm/index.js
var esm_default3 = Contract;

// node_modules/web3-eth-ens/lib/esm/index.js
var esm_exports14 = {};
__export(esm_exports14, {
  ENS: () => ENS,
  registryAddresses: () => registryAddresses
});
init_shim();

// node_modules/web3-eth-ens/lib/esm/config.js
init_shim();
var interfaceIds = {
  addr: "0x3b3b57de",
  name: "0x691f3431",
  abi: "0x2203ab56",
  pubkey: "0xc8690233",
  text: "0x59d1d43c",
  contenthash: "0xbc1c58d1"
};
var methodsInInterface = {
  setAddr: "addr",
  addr: "addr",
  setPubkey: "pubkey",
  pubkey: "pubkey",
  setContenthash: "contenthash",
  contenthash: "contenthash"
};
var registryAddresses = {
  main: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  goerli: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
};
var networkIds = {
  "0x1": "main",
  "0x5": "goerli"
};

// node_modules/web3-eth-ens/lib/esm/ens.js
init_shim();

// node_modules/web3-eth-ens/node_modules/web3-core/lib/esm/index.js
init_shim();

// node_modules/web3-eth-ens/node_modules/web3-core/lib/esm/web3_config.js
init_shim();

// node_modules/web3-eth-ens/node_modules/web3-utils/lib/esm/index.js
init_shim();

// node_modules/web3-eth-ens/node_modules/web3-utils/lib/esm/converters.js
init_shim();

// node_modules/web3-eth-ens/node_modules/ethereum-cryptography/esm/keccak.js
init_shim();
init_sha3();

// node_modules/web3-eth-ens/node_modules/ethereum-cryptography/esm/utils.js
init_shim();
init_assert();
init_utils();
init_utils();
var assertBool8 = assert_default.bool;
var assertBytes8 = assert_default.bytes;
function bytesToUtf87(data) {
  if (!(data instanceof Uint8Array)) {
    throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
  }
  return new TextDecoder().decode(data);
}
function wrapHash8(hash) {
  return (msg) => {
    assert_default.bytes(msg);
    return hash(msg);
  };
}
var crypto10 = (() => {
  const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
  return {
    node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
    web: webCrypto
  };
})();

// node_modules/web3-eth-ens/node_modules/ethereum-cryptography/esm/keccak.js
var keccak2248 = wrapHash8(keccak_224);
var keccak2568 = (() => {
  const k = wrapHash8(keccak_256);
  k.create = keccak_256.create;
  return k;
})();
var keccak3848 = wrapHash8(keccak_384);
var keccak5128 = wrapHash8(keccak_512);

// node_modules/web3-eth-ens/node_modules/web3-utils/lib/esm/converters.js
var ethUnitMap7 = {
  noether: BigInt(0),
  wei: BigInt(1),
  kwei: BigInt(1e3),
  Kwei: BigInt(1e3),
  babbage: BigInt(1e3),
  femtoether: BigInt(1e3),
  mwei: BigInt(1e6),
  Mwei: BigInt(1e6),
  lovelace: BigInt(1e6),
  picoether: BigInt(1e6),
  gwei: BigInt(1e9),
  Gwei: BigInt(1e9),
  shannon: BigInt(1e9),
  nanoether: BigInt(1e9),
  nano: BigInt(1e9),
  szabo: BigInt(1e12),
  microether: BigInt(1e12),
  micro: BigInt(1e12),
  finney: BigInt(1e15),
  milliether: BigInt(1e15),
  milli: BigInt(1e15),
  ether: BigInt("1000000000000000000"),
  kether: BigInt("1000000000000000000000"),
  grand: BigInt("1000000000000000000000"),
  mether: BigInt("1000000000000000000000000"),
  gether: BigInt("1000000000000000000000000000"),
  tether: BigInt("1000000000000000000000000000000")
};
var bytesToUint8Array7 = (data) => {
  validator.validate(["bytes"], [data]);
  if (data instanceof Uint8Array) {
    return data;
  }
  if (Array.isArray(data)) {
    return new Uint8Array(data);
  }
  if (typeof data === "string") {
    return utils_exports.hexToUint8Array(data);
  }
  throw new InvalidBytesError(data);
};
var { uint8ArrayToHexString: uint8ArrayToHexString8 } = utils_exports;
var bytesToHex8 = (bytes) => uint8ArrayToHexString8(bytesToUint8Array7(bytes));
var hexToBytes8 = (bytes) => {
  if (typeof bytes === "string" && bytes.slice(0, 2).toLowerCase() !== "0x") {
    return bytesToUint8Array7(`0x${bytes}`);
  }
  return bytesToUint8Array7(bytes);
};
var hexToNumber7 = (value) => {
  validator.validate(["hex"], [value]);
  return utils_exports.hexToNumber(value);
};
var numberToHex8 = (value, hexstrict) => {
  if (typeof value !== "bigint")
    validator.validate(["int"], [value]);
  let updatedValue = utils_exports.numberToHex(value);
  if (hexstrict) {
    if (!updatedValue.startsWith("-") && updatedValue.length % 2 === 1) {
      updatedValue = "0x0".concat(updatedValue.slice(2));
    } else if (updatedValue.length % 2 === 0 && updatedValue.startsWith("-"))
      updatedValue = "-0x0".concat(updatedValue.slice(3));
  }
  return updatedValue;
};
var hexToNumberString5 = (data) => hexToNumber7(data).toString();
var utf8ToHex7 = (str) => {
  validator.validate(["string"], [str]);
  let strWithoutNullCharacter = str.replace(/^(?:\u0000)/, "");
  strWithoutNullCharacter = strWithoutNullCharacter.replace(/(?:\u0000)$/, "");
  return bytesToHex8(new TextEncoder().encode(strWithoutNullCharacter));
};
var fromUtf86 = utf8ToHex7;
var hexToUtf86 = (str) => bytesToUtf87(hexToBytes8(str));
var toUtf85 = (input) => {
  if (typeof input === "string") {
    return hexToUtf86(input);
  }
  validator.validate(["bytes"], [input]);
  return bytesToUtf87(input);
};
var utf8ToBytes8 = utf8ToBytes;
var toHex7 = (value, returnType) => {
  if (typeof value === "string" && isAddress(value)) {
    return returnType ? "address" : `0x${value.toLowerCase().replace(/^0x/i, "")}`;
  }
  if (typeof value === "boolean") {
    return returnType ? "bool" : value ? "0x01" : "0x00";
  }
  if (typeof value === "number") {
    return returnType ? value < 0 ? "int256" : "uint256" : numberToHex8(value);
  }
  if (typeof value === "bigint") {
    return returnType ? "bigint" : numberToHex8(value);
  }
  if (typeof value === "object" && !!value) {
    return returnType ? "string" : utf8ToHex7(JSON.stringify(value));
  }
  if (typeof value === "string") {
    if (value.startsWith("-0x") || value.startsWith("-0X")) {
      return returnType ? "int256" : numberToHex8(value);
    }
    if (isHexStrict(value)) {
      return returnType ? "bytes" : value;
    }
    if (isHex(value) && !isInt(value)) {
      return returnType ? "bytes" : `0x${value}`;
    }
    if (!Number.isFinite(value)) {
      return returnType ? "string" : utf8ToHex7(value);
    }
  }
  throw new HexProcessingError(value);
};
var toNumber7 = (value) => {
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "bigint") {
    return value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER ? Number(value) : value;
  }
  if (typeof value === "string" && isHexStrict(value)) {
    return hexToNumber7(value);
  }
  try {
    return toNumber7(BigInt(value));
  } catch (_a16) {
    throw new InvalidNumberError(value);
  }
};
var toChecksumAddress7 = (address) => {
  if (!isAddress(address, false)) {
    throw new InvalidAddressError(address);
  }
  const lowerCaseAddress = address.toLowerCase().replace(/^0x/i, "");
  const hash = utils_exports.uint8ArrayToHexString(keccak2568(utf8ToBytes8(lowerCaseAddress)));
  if (isNullish(hash) || hash === "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470")
    return "";
  let checksumAddress = "0x";
  const addressHash = hash.replace(/^0x/i, "");
  for (let i = 0; i < lowerCaseAddress.length; i += 1) {
    if (parseInt(addressHash[i], 16) > 7) {
      checksumAddress += lowerCaseAddress[i].toUpperCase();
    } else {
      checksumAddress += lowerCaseAddress[i];
    }
  }
  return checksumAddress;
};

// node_modules/web3-eth-ens/node_modules/web3-utils/lib/esm/event_emitter.js
init_shim();
var import_events13 = __toESM(require_events(), 1);
var __awaiter68 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var wrapFunction7 = (fn) => (params) => fn(params.detail);
var EventEmitterAtBrowser7 = class extends EventTarget {
  constructor() {
    super(...arguments);
    this._listeners = {};
    this.maxListeners = Number.MAX_SAFE_INTEGER;
  }
  on(eventName, fn) {
    this.addEventListener(eventName, fn);
    return this;
  }
  once(eventName, fn) {
    const onceCallback = (params) => __awaiter68(this, void 0, void 0, function* () {
      this.off(eventName, onceCallback);
      yield fn(params);
    });
    return this.on(eventName, onceCallback);
  }
  off(eventName, fn) {
    this.removeEventListener(eventName, fn);
    return this;
  }
  emit(eventName, params) {
    const event = new CustomEvent(eventName, { detail: params });
    return super.dispatchEvent(event);
  }
  listenerCount(eventName) {
    const eventListeners = this._listeners[eventName];
    return eventListeners ? eventListeners.length : 0;
  }
  listeners(eventName) {
    return this._listeners[eventName].map((value) => value[0]) || [];
  }
  eventNames() {
    return Object.keys(this._listeners);
  }
  removeAllListeners() {
    Object.keys(this._listeners).forEach((event) => {
      this._listeners[event].forEach((listener) => {
        super.removeEventListener(event, listener[1]);
      });
    });
    this._listeners = {};
    return this;
  }
  setMaxListeners(maxListeners) {
    this.maxListeners = maxListeners;
    return this;
  }
  getMaxListeners() {
    return this.maxListeners;
  }
  addEventListener(eventName, fn) {
    const wrappedFn = wrapFunction7(fn);
    super.addEventListener(eventName, wrappedFn);
    if (!this._listeners[eventName]) {
      this._listeners[eventName] = [];
    }
    this._listeners[eventName].push([fn, wrappedFn]);
  }
  removeEventListener(eventName, fn) {
    const eventListeners = this._listeners[eventName];
    if (eventListeners) {
      const index = eventListeners.findIndex((item) => item[0] === fn);
      if (index !== -1) {
        super.removeEventListener(eventName, eventListeners[index][1]);
        eventListeners.splice(index, 1);
      }
    }
  }
};
var EventEmitterType7;
if (typeof window === "undefined") {
  EventEmitterType7 = import_events13.EventEmitter;
} else {
  EventEmitterType7 = EventEmitterAtBrowser7;
}
var EventEmitter12 = class extends EventEmitterType7 {
};

// node_modules/web3-eth-ens/node_modules/web3-utils/lib/esm/validation.js
init_shim();
var isHexStrict6 = isHexStrict;
var isAddress6 = isAddress;
var isNullish8 = isNullish;

// node_modules/web3-eth-ens/node_modules/web3-utils/lib/esm/formatter.js
init_shim();

// node_modules/web3-eth-ens/node_modules/web3-utils/lib/esm/objects.js
init_shim();
var isIterable5 = (item) => typeof item === "object" && !isNullish(item) && !Array.isArray(item) && !(item instanceof TypedArray);
var mergeDeep7 = (destination, ...sources) => {
  const result = destination;
  if (!isIterable5(result)) {
    return result;
  }
  for (const src of sources) {
    for (const key in src) {
      if (isIterable5(src[key])) {
        if (!result[key]) {
          result[key] = {};
        }
        mergeDeep7(result[key], src[key]);
      } else if (!isNullish(src[key]) && Object.hasOwnProperty.call(src, key)) {
        if (Array.isArray(src[key]) || src[key] instanceof TypedArray) {
          result[key] = src[key].slice(0);
        } else {
          result[key] = src[key];
        }
      }
    }
  }
  return result;
};

// node_modules/web3-eth-ens/node_modules/web3-utils/lib/esm/string_manipulation.js
init_shim();
var padLeft8 = (value, characterAmount, sign6 = "0") => {
  if (typeof value === "string") {
    if (!isHexStrict(value)) {
      return value.padStart(characterAmount, sign6);
    }
    return utils_exports.padLeft(value, characterAmount, sign6);
  }
  validator.validate(["int"], [value]);
  return utils_exports.padLeft(value, characterAmount, sign6);
};
var leftPad7 = padLeft8;

// node_modules/web3-eth-ens/node_modules/web3-utils/lib/esm/uint8array.js
init_shim();

// node_modules/web3-eth-ens/node_modules/web3-utils/lib/esm/formatter.js
var { parseBaseType: parseBaseType8 } = utils_exports;

// node_modules/web3-eth-ens/node_modules/web3-utils/lib/esm/hash.js
init_shim();
var SHA3_EMPTY_BYTES7 = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
var sha37 = (data) => {
  let updatedData;
  if (typeof data === "string") {
    if (data.startsWith("0x") && isHexStrict(data)) {
      updatedData = hexToBytes8(data);
    } else {
      updatedData = utf8ToBytes(data);
    }
  } else {
    updatedData = data;
  }
  const hash = bytesToHex8(keccak2568(updatedData));
  return hash === SHA3_EMPTY_BYTES7 ? void 0 : hash;
};
var sha3Raw7 = (data) => {
  const hash = sha37(data);
  if (isNullish(hash)) {
    return SHA3_EMPTY_BYTES7;
  }
  return hash;
};

// node_modules/web3-eth-ens/node_modules/web3-utils/lib/esm/random.js
init_shim();

// node_modules/web3-eth-ens/node_modules/ethereum-cryptography/esm/random.js
init_shim();
init_utils();
function getRandomBytesSync7(bytes) {
  return randomBytes(bytes);
}

// node_modules/web3-eth-ens/node_modules/web3-utils/lib/esm/random.js
var randomBytes8 = (size) => getRandomBytesSync7(size);

// node_modules/web3-eth-ens/node_modules/web3-utils/lib/esm/promise_helpers.js
init_shim();
function isPromise5(object) {
  return (typeof object === "object" || typeof object === "function") && typeof object.then === "function";
}

// node_modules/web3-eth-ens/node_modules/web3-utils/lib/esm/json_rpc.js
var json_rpc_exports7 = {};
__export(json_rpc_exports7, {
  isBatchRequest: () => isBatchRequest7,
  isBatchResponse: () => isBatchResponse7,
  isResponseRpcError: () => isResponseRpcError7,
  isResponseWithError: () => isResponseWithError8,
  isResponseWithNotification: () => isResponseWithNotification7,
  isResponseWithResult: () => isResponseWithResult7,
  isSubscriptionResult: () => isSubscriptionResult7,
  isValidResponse: () => isValidResponse7,
  setRequestIdStart: () => setRequestIdStart7,
  toBatchPayload: () => toBatchPayload7,
  toPayload: () => toPayload7,
  validateResponse: () => validateResponse7
});
init_shim();

// node_modules/web3-eth-ens/node_modules/web3-utils/lib/esm/uuid.js
init_shim();
var uuidV47 = () => {
  const bytes = randomBytes8(16);
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 63 | 128;
  const hexString = bytesToHex8(bytes);
  return [
    hexString.substring(2, 10),
    hexString.substring(10, 14),
    hexString.substring(14, 18),
    hexString.substring(18, 22),
    hexString.substring(22, 34)
  ].join("-");
};

// node_modules/web3-eth-ens/node_modules/web3-utils/lib/esm/json_rpc.js
var isResponseRpcError7 = (rpcError) => {
  const errorCode = rpcError.error.code;
  return rpcErrorsMap.has(errorCode) || errorCode >= -32099 && errorCode <= -32e3;
};
var isResponseWithResult7 = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && "result" in response && isNullish(response.error) && (typeof response.id === "number" || typeof response.id === "string");
var isResponseWithError8 = (response) => !Array.isArray(response) && response.jsonrpc === "2.0" && !!response && isNullish(response.result) && "error" in response && (typeof response.id === "number" || typeof response.id === "string");
var isResponseWithNotification7 = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && !isNullish(response.params) && !isNullish(response.method);
var isSubscriptionResult7 = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && "id" in response && "result" in response;
var validateResponse7 = (response) => isResponseWithResult7(response) || isResponseWithError8(response);
var isValidResponse7 = (response) => Array.isArray(response) ? response.every(validateResponse7) : validateResponse7(response);
var isBatchResponse7 = (response) => Array.isArray(response) && response.length > 0 && isValidResponse7(response);
var requestIdSeed7;
var setRequestIdStart7 = (start) => {
  requestIdSeed7 = start;
};
var toPayload7 = (request) => {
  var _a16, _b, _c, _d;
  if (typeof requestIdSeed7 !== "undefined") {
    requestIdSeed7 += 1;
  }
  return {
    jsonrpc: (_a16 = request.jsonrpc) !== null && _a16 !== void 0 ? _a16 : "2.0",
    id: (_c = (_b = request.id) !== null && _b !== void 0 ? _b : requestIdSeed7) !== null && _c !== void 0 ? _c : uuidV47(),
    method: request.method,
    params: (_d = request.params) !== null && _d !== void 0 ? _d : void 0
  };
};
var toBatchPayload7 = (requests) => requests.map((request) => toPayload7(request));
var isBatchRequest7 = (request) => Array.isArray(request) && request.length > 0;

// node_modules/web3-eth-ens/node_modules/web3-utils/lib/esm/web3_deferred_promise.js
init_shim();
var __awaiter69 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a12;
var Web3DeferredPromise7 = class {
  constructor({ timeout, eagerStart, timeoutMessage } = {
    timeout: 0,
    eagerStart: false,
    timeoutMessage: "DeferredPromise timed out"
  }) {
    this[_a12] = "Promise";
    this._state = "pending";
    this._promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
    this._timeoutMessage = timeoutMessage;
    this._timeoutInterval = timeout;
    if (eagerStart) {
      this.startTimer();
    }
  }
  get state() {
    return this._state;
  }
  then(onfulfilled, onrejected) {
    return __awaiter69(this, void 0, void 0, function* () {
      return this._promise.then(onfulfilled, onrejected);
    });
  }
  catch(onrejected) {
    return __awaiter69(this, void 0, void 0, function* () {
      return this._promise.catch(onrejected);
    });
  }
  finally(onfinally) {
    return __awaiter69(this, void 0, void 0, function* () {
      return this._promise.finally(onfinally);
    });
  }
  resolve(value) {
    this._resolve(value);
    this._state = "fulfilled";
    this._clearTimeout();
  }
  reject(reason) {
    this._reject(reason);
    this._state = "rejected";
    this._clearTimeout();
  }
  startTimer() {
    if (this._timeoutInterval && this._timeoutInterval > 0) {
      this._timeoutId = setTimeout(this._checkTimeout.bind(this), this._timeoutInterval);
    }
  }
  _checkTimeout() {
    if (this._state === "pending" && this._timeoutId) {
      this.reject(new OperationTimeoutError(this._timeoutMessage));
    }
  }
  _clearTimeout() {
    if (this._timeoutId) {
      clearTimeout(this._timeoutId);
    }
  }
};
_a12 = Symbol.toStringTag;

// node_modules/web3-eth-ens/node_modules/web3-utils/lib/esm/chunk_response_parser.js
init_shim();
var ChunkResponseParser7 = class {
  constructor(eventEmitter, autoReconnect) {
    this.eventEmitter = eventEmitter;
    this.autoReconnect = autoReconnect;
  }
  clearQueues() {
    if (typeof this._clearQueues === "function") {
      this._clearQueues();
    }
  }
  onError(clearQueues) {
    this._clearQueues = clearQueues;
  }
  parseResponse(data) {
    const returnValues = [];
    const dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
    dechunkedData.forEach((_chunkData) => {
      let chunkData = _chunkData;
      if (this.lastChunk) {
        chunkData = this.lastChunk + chunkData;
      }
      let result;
      try {
        result = JSON.parse(chunkData);
      } catch (e) {
        this.lastChunk = chunkData;
        if (this.lastChunkTimeout) {
          clearTimeout(this.lastChunkTimeout);
        }
        this.lastChunkTimeout = setTimeout(() => {
          if (this.autoReconnect)
            return;
          this.clearQueues();
          this.eventEmitter.emit("error", new InvalidResponseError({
            id: 1,
            jsonrpc: "2.0",
            error: { code: 2, message: "Chunk timeout" }
          }));
        }, 1e3 * 15);
        return;
      }
      clearTimeout(this.lastChunkTimeout);
      this.lastChunk = void 0;
      if (result)
        returnValues.push(result);
    });
    return returnValues;
  }
};

// node_modules/web3-eth-ens/node_modules/web3-utils/lib/esm/web3_eip1193_provider.js
init_shim();
var import_events14 = __toESM(require_events(), 1);
var __awaiter70 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Eip1193Provider7 = class extends Web3BaseProvider {
  constructor() {
    super(...arguments);
    this._eventEmitter = new import_events14.EventEmitter();
    this._chainId = "";
    this._accounts = [];
  }
  _getChainId() {
    var _a16;
    return __awaiter70(this, void 0, void 0, function* () {
      const data = yield this.request(toPayload7({
        method: "eth_chainId",
        params: []
      }));
      return (_a16 = data === null || data === void 0 ? void 0 : data.result) !== null && _a16 !== void 0 ? _a16 : "";
    });
  }
  _getAccounts() {
    var _a16;
    return __awaiter70(this, void 0, void 0, function* () {
      const data = yield this.request(toPayload7({
        method: "eth_accounts",
        params: []
      }));
      return (_a16 = data === null || data === void 0 ? void 0 : data.result) !== null && _a16 !== void 0 ? _a16 : [];
    });
  }
  _onConnect() {
    Promise.all([
      this._getChainId().then((chainId) => {
        if (chainId !== this._chainId) {
          this._chainId = chainId;
          this._eventEmitter.emit("chainChanged", this._chainId);
        }
      }).catch((err) => {
        console.error(err);
      }),
      this._getAccounts().then((accounts) => {
        if (!(this._accounts.length === accounts.length && accounts.every((v) => accounts.includes(v)))) {
          this._accounts = accounts;
          this._onAccountsChanged();
        }
      }).catch((err) => {
        console.error(err);
      })
    ]).then(() => this._eventEmitter.emit("connect", {
      chainId: this._chainId
    })).catch((err) => {
      console.error(err);
    });
  }
  _onDisconnect(code, data) {
    this._eventEmitter.emit("disconnect", new EIP1193ProviderRpcError(code, data));
  }
  _onAccountsChanged() {
    this._eventEmitter.emit("accountsChanged", this._accounts);
  }
};

// node_modules/web3-eth-ens/node_modules/web3-utils/lib/esm/socket_provider.js
init_shim();
var __awaiter71 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_RECONNECTION_OPTIONS5 = {
  autoReconnect: true,
  delay: 5e3,
  maxAttempts: 5
};
var NORMAL_CLOSE_CODE5 = 1e3;
var SocketProvider5 = class extends Eip1193Provider7 {
  constructor(socketPath, socketOptions, reconnectOptions) {
    super();
    this._connectionStatus = "connecting";
    this._onMessageHandler = this._onMessage.bind(this);
    this._onOpenHandler = this._onConnect.bind(this);
    this._onCloseHandler = this._onCloseEvent.bind(this);
    this._onErrorHandler = this._onError.bind(this);
    if (!this._validateProviderPath(socketPath))
      throw new InvalidClientError(socketPath);
    this._socketPath = socketPath;
    this._socketOptions = socketOptions;
    this._reconnectOptions = Object.assign(Object.assign({}, DEFAULT_RECONNECTION_OPTIONS5), reconnectOptions !== null && reconnectOptions !== void 0 ? reconnectOptions : {});
    this._pendingRequestsQueue = /* @__PURE__ */ new Map();
    this._sentRequestsQueue = /* @__PURE__ */ new Map();
    this._init();
    this.connect();
    this.chunkResponseParser = new ChunkResponseParser7(this._eventEmitter, this._reconnectOptions.autoReconnect);
    this.chunkResponseParser.onError(() => {
      this._clearQueues();
    });
    this.isReconnecting = false;
  }
  get SocketConnection() {
    return this._socketConnection;
  }
  _init() {
    this._reconnectAttempts = 0;
  }
  connect() {
    try {
      this._openSocketConnection();
      this._connectionStatus = "connecting";
      this._addSocketListeners();
    } catch (e) {
      if (!this.isReconnecting) {
        this._connectionStatus = "disconnected";
        if (e && e.message) {
          throw new ConnectionError(`Error while connecting to ${this._socketPath}. Reason: ${e.message}`);
        } else {
          throw new InvalidClientError(this._socketPath);
        }
      } else {
        setImmediate(() => {
          this._reconnect();
        });
      }
    }
  }
  _validateProviderPath(path) {
    return !!path;
  }
  supportsSubscriptions() {
    return true;
  }
  on(type, listener) {
    this._eventEmitter.on(type, listener);
  }
  once(type, listener) {
    this._eventEmitter.once(type, listener);
  }
  removeListener(type, listener) {
    this._eventEmitter.removeListener(type, listener);
  }
  _onDisconnect(code, data) {
    this._connectionStatus = "disconnected";
    super._onDisconnect(code, data);
  }
  disconnect(code, data) {
    const disconnectCode = code !== null && code !== void 0 ? code : NORMAL_CLOSE_CODE5;
    this._removeSocketListeners();
    if (this.getStatus() !== "disconnected") {
      this._closeSocketConnection(disconnectCode, data);
    }
    this._onDisconnect(disconnectCode, data);
  }
  removeAllListeners(type) {
    this._eventEmitter.removeAllListeners(type);
  }
  _onError(event) {
    if (this.isReconnecting) {
      this._reconnect();
    } else {
      this._eventEmitter.emit("error", event);
    }
  }
  reset() {
    this._sentRequestsQueue.clear();
    this._pendingRequestsQueue.clear();
    this._init();
    this._removeSocketListeners();
    this._addSocketListeners();
  }
  _reconnect() {
    if (this.isReconnecting) {
      return;
    }
    this.isReconnecting = true;
    if (this._sentRequestsQueue.size > 0) {
      this._sentRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new PendingRequestsOnReconnectingError());
        this._sentRequestsQueue.delete(key);
      });
    }
    if (this._reconnectAttempts < this._reconnectOptions.maxAttempts) {
      this._reconnectAttempts += 1;
      setTimeout(() => {
        this._removeSocketListeners();
        this.connect();
        this.isReconnecting = false;
      }, this._reconnectOptions.delay);
    } else {
      this.isReconnecting = false;
      this._clearQueues();
      this._removeSocketListeners();
      this._eventEmitter.emit("error", new MaxAttemptsReachedOnReconnectingError(this._reconnectOptions.maxAttempts));
    }
  }
  request(request) {
    return __awaiter71(this, void 0, void 0, function* () {
      if (isNullish8(this._socketConnection)) {
        throw new Error("Connection is undefined");
      }
      if (this.getStatus() === "disconnected") {
        this.connect();
      }
      const requestId = isBatchRequest7(request) ? request[0].id : request.id;
      if (!requestId) {
        throw new Web3WSProviderError("Request Id not defined");
      }
      if (this._sentRequestsQueue.has(requestId)) {
        throw new RequestAlreadySentError(requestId);
      }
      const deferredPromise = new Web3DeferredPromise7();
      deferredPromise.catch((error) => {
        this._eventEmitter.emit("error", error);
      });
      const reqItem = {
        payload: request,
        deferredPromise
      };
      if (this.getStatus() === "connecting") {
        this._pendingRequestsQueue.set(requestId, reqItem);
        return reqItem.deferredPromise;
      }
      this._sentRequestsQueue.set(requestId, reqItem);
      try {
        this._sendToSocket(reqItem.payload);
      } catch (error) {
        this._sentRequestsQueue.delete(requestId);
        this._eventEmitter.emit("error", error);
      }
      return deferredPromise;
    });
  }
  _onConnect() {
    this._connectionStatus = "connected";
    this._reconnectAttempts = 0;
    super._onConnect();
    this._sendPendingRequests();
  }
  _sendPendingRequests() {
    for (const [id, value] of this._pendingRequestsQueue.entries()) {
      this._sendToSocket(value.payload);
      this._pendingRequestsQueue.delete(id);
      this._sentRequestsQueue.set(id, value);
    }
  }
  _onMessage(event) {
    const responses = this._parseResponses(event);
    if (isNullish8(responses) || responses.length === 0) {
      return;
    }
    for (const response of responses) {
      if (isResponseWithNotification7(response) && response.method.endsWith("_subscription")) {
        this._eventEmitter.emit("message", response);
        return;
      }
      const requestId = isBatchResponse7(response) ? response[0].id : response.id;
      const requestItem = this._sentRequestsQueue.get(requestId);
      if (!requestItem) {
        return;
      }
      if (isBatchResponse7(response) || isResponseWithResult7(response) || isResponseWithError8(response)) {
        this._eventEmitter.emit("message", response);
        requestItem.deferredPromise.resolve(response);
      }
      this._sentRequestsQueue.delete(requestId);
    }
  }
  _clearQueues(event) {
    if (this._pendingRequestsQueue.size > 0) {
      this._pendingRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new ConnectionNotOpenError(event));
        this._pendingRequestsQueue.delete(key);
      });
    }
    if (this._sentRequestsQueue.size > 0) {
      this._sentRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new ConnectionNotOpenError(event));
        this._sentRequestsQueue.delete(key);
      });
    }
    this._removeSocketListeners();
  }
};

// node_modules/web3-eth-ens/node_modules/web3-core/lib/esm/web3_event_emitter.js
init_shim();
var Web3EventEmitter5 = class {
  constructor() {
    this._emitter = new EventEmitter12();
  }
  on(eventName, fn) {
    this._emitter.on(eventName, fn);
  }
  once(eventName, fn) {
    this._emitter.once(eventName, fn);
  }
  off(eventName, fn) {
    this._emitter.off(eventName, fn);
  }
  emit(eventName, params) {
    this._emitter.emit(eventName, params);
  }
  listenerCount(eventName) {
    return this._emitter.listenerCount(eventName);
  }
  listeners(eventName) {
    return this._emitter.listeners(eventName);
  }
  eventNames() {
    return this._emitter.eventNames();
  }
  removeAllListeners() {
    return this._emitter.removeAllListeners();
  }
  setMaxListenerWarningThreshold(maxListenersWarningThreshold) {
    this._emitter.setMaxListeners(maxListenersWarningThreshold);
  }
  getMaxListeners() {
    return this._emitter.getMaxListeners();
  }
};

// node_modules/web3-eth-ens/node_modules/web3-core/lib/esm/web3_config.js
var Web3ConfigEvent5;
(function(Web3ConfigEvent7) {
  Web3ConfigEvent7["CONFIG_CHANGE"] = "CONFIG_CHANGE";
})(Web3ConfigEvent5 || (Web3ConfigEvent5 = {}));
var Web3Config5 = class extends Web3EventEmitter5 {
  constructor(options) {
    super();
    this.config = {
      handleRevert: false,
      defaultAccount: void 0,
      defaultBlock: "latest",
      transactionBlockTimeout: 50,
      transactionConfirmationBlocks: 24,
      transactionPollingInterval: 1e3,
      transactionPollingTimeout: 750 * 1e3,
      transactionReceiptPollingInterval: void 0,
      transactionSendTimeout: 750 * 1e3,
      transactionConfirmationPollingInterval: void 0,
      blockHeaderTimeout: 10,
      maxListenersWarningThreshold: 100,
      contractDataInputFill: "input",
      defaultNetworkId: void 0,
      defaultChain: "mainnet",
      defaultHardfork: "london",
      defaultCommon: void 0,
      defaultTransactionType: "0x2",
      defaultMaxPriorityFeePerGas: toHex7(25e8),
      enableExperimentalFeatures: {
        useSubscriptionWhenCheckingBlockTimeout: false,
        useRpcCallSpecification: false
      },
      transactionBuilder: void 0,
      transactionTypeParser: void 0
    };
    this.setConfig(options !== null && options !== void 0 ? options : {});
  }
  setConfig(options) {
    Object.assign(this.config, options);
  }
  get handleRevert() {
    return this.config.handleRevert;
  }
  set handleRevert(val) {
    this._triggerConfigChange("handleRevert", val);
    this.config.handleRevert = val;
  }
  get contractDataInputFill() {
    return this.config.contractDataInputFill;
  }
  set contractDataInputFill(val) {
    this._triggerConfigChange("contractDataInputFill", val);
    this.config.contractDataInputFill = val;
  }
  get defaultAccount() {
    return this.config.defaultAccount;
  }
  set defaultAccount(val) {
    this._triggerConfigChange("defaultAccount", val);
    this.config.defaultAccount = val;
  }
  get defaultBlock() {
    return this.config.defaultBlock;
  }
  set defaultBlock(val) {
    this._triggerConfigChange("defaultBlock", val);
    this.config.defaultBlock = val;
  }
  get transactionSendTimeout() {
    return this.config.transactionSendTimeout;
  }
  set transactionSendTimeout(val) {
    this._triggerConfigChange("transactionSendTimeout", val);
    this.config.transactionSendTimeout = val;
  }
  get transactionBlockTimeout() {
    return this.config.transactionBlockTimeout;
  }
  set transactionBlockTimeout(val) {
    this._triggerConfigChange("transactionBlockTimeout", val);
    this.config.transactionBlockTimeout = val;
  }
  get transactionConfirmationBlocks() {
    return this.config.transactionConfirmationBlocks;
  }
  set transactionConfirmationBlocks(val) {
    this._triggerConfigChange("transactionConfirmationBlocks", val);
    this.config.transactionConfirmationBlocks = val;
  }
  get transactionPollingInterval() {
    return this.config.transactionPollingInterval;
  }
  set transactionPollingInterval(val) {
    this._triggerConfigChange("transactionPollingInterval", val);
    this.config.transactionPollingInterval = val;
    this.transactionReceiptPollingInterval = val;
    this.transactionConfirmationPollingInterval = val;
  }
  get transactionPollingTimeout() {
    return this.config.transactionPollingTimeout;
  }
  set transactionPollingTimeout(val) {
    this._triggerConfigChange("transactionPollingTimeout", val);
    this.config.transactionPollingTimeout = val;
  }
  get transactionReceiptPollingInterval() {
    return this.config.transactionReceiptPollingInterval;
  }
  set transactionReceiptPollingInterval(val) {
    this._triggerConfigChange("transactionReceiptPollingInterval", val);
    this.config.transactionReceiptPollingInterval = val;
  }
  get transactionConfirmationPollingInterval() {
    return this.config.transactionConfirmationPollingInterval;
  }
  set transactionConfirmationPollingInterval(val) {
    this._triggerConfigChange("transactionConfirmationPollingInterval", val);
    this.config.transactionConfirmationPollingInterval = val;
  }
  get blockHeaderTimeout() {
    return this.config.blockHeaderTimeout;
  }
  set blockHeaderTimeout(val) {
    this._triggerConfigChange("blockHeaderTimeout", val);
    this.config.blockHeaderTimeout = val;
  }
  get enableExperimentalFeatures() {
    return this.config.enableExperimentalFeatures;
  }
  set enableExperimentalFeatures(val) {
    this._triggerConfigChange("enableExperimentalFeatures", val);
    this.config.enableExperimentalFeatures = val;
  }
  get maxListenersWarningThreshold() {
    return this.config.maxListenersWarningThreshold;
  }
  set maxListenersWarningThreshold(val) {
    this._triggerConfigChange("maxListenersWarningThreshold", val);
    this.setMaxListenerWarningThreshold(val);
    this.config.maxListenersWarningThreshold = val;
  }
  get defaultNetworkId() {
    return this.config.defaultNetworkId;
  }
  set defaultNetworkId(val) {
    this._triggerConfigChange("defaultNetworkId", val);
    this.config.defaultNetworkId = val;
  }
  get defaultChain() {
    return this.config.defaultChain;
  }
  set defaultChain(val) {
    if (!isNullish8(this.config.defaultCommon) && !isNullish8(this.config.defaultCommon.baseChain) && val !== this.config.defaultCommon.baseChain)
      throw new ConfigChainMismatchError(this.config.defaultChain, val);
    this._triggerConfigChange("defaultChain", val);
    this.config.defaultChain = val;
  }
  get defaultHardfork() {
    return this.config.defaultHardfork;
  }
  set defaultHardfork(val) {
    if (!isNullish8(this.config.defaultCommon) && !isNullish8(this.config.defaultCommon.hardfork) && val !== this.config.defaultCommon.hardfork)
      throw new ConfigHardforkMismatchError(this.config.defaultCommon.hardfork, val);
    this._triggerConfigChange("defaultHardfork", val);
    this.config.defaultHardfork = val;
  }
  get defaultCommon() {
    return this.config.defaultCommon;
  }
  set defaultCommon(val) {
    if (!isNullish8(this.config.defaultHardfork) && !isNullish8(val) && !isNullish8(val.hardfork) && this.config.defaultHardfork !== val.hardfork)
      throw new ConfigHardforkMismatchError(this.config.defaultHardfork, val.hardfork);
    if (!isNullish8(this.config.defaultChain) && !isNullish8(val) && !isNullish8(val.baseChain) && this.config.defaultChain !== val.baseChain)
      throw new ConfigChainMismatchError(this.config.defaultChain, val.baseChain);
    this._triggerConfigChange("defaultCommon", val);
    this.config.defaultCommon = val;
  }
  get defaultTransactionType() {
    return this.config.defaultTransactionType;
  }
  set defaultTransactionType(val) {
    this._triggerConfigChange("defaultTransactionType", val);
    this.config.defaultTransactionType = val;
  }
  get defaultMaxPriorityFeePerGas() {
    return this.config.defaultMaxPriorityFeePerGas;
  }
  set defaultMaxPriorityFeePerGas(val) {
    this._triggerConfigChange("defaultMaxPriorityFeePerGas", val);
    this.config.defaultMaxPriorityFeePerGas = val;
  }
  get transactionBuilder() {
    return this.config.transactionBuilder;
  }
  set transactionBuilder(val) {
    this._triggerConfigChange("transactionBuilder", val);
    this.config.transactionBuilder = val;
  }
  get transactionTypeParser() {
    return this.config.transactionTypeParser;
  }
  set transactionTypeParser(val) {
    this._triggerConfigChange("transactionTypeParser", val);
    this.config.transactionTypeParser = val;
  }
  _triggerConfigChange(config, newValue) {
    this.emit(Web3ConfigEvent5.CONFIG_CHANGE, {
      name: config,
      oldValue: this.config[config],
      newValue
    });
  }
};

// node_modules/web3-eth-ens/node_modules/web3-core/lib/esm/web3_request_manager.js
init_shim();

// node_modules/web3-eth-ens/node_modules/web3-providers-http/lib/esm/index.js
init_shim();
var import_cross_fetch5 = __toESM(require_browser_ponyfill5());
var __awaiter72 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var HttpProvider5 = class extends Web3BaseProvider {
  constructor(clientUrl, httpProviderOptions) {
    super();
    if (!HttpProvider5.validateClientUrl(clientUrl))
      throw new InvalidClientError(clientUrl);
    this.clientUrl = clientUrl;
    this.httpProviderOptions = httpProviderOptions;
  }
  static validateClientUrl(clientUrl) {
    return typeof clientUrl === "string" ? /^http(s)?:\/\//i.test(clientUrl) : false;
  }
  getStatus() {
    throw new MethodNotImplementedError();
  }
  supportsSubscriptions() {
    return false;
  }
  request(payload, requestOptions) {
    var _a16;
    return __awaiter72(this, void 0, void 0, function* () {
      const providerOptionsCombined = Object.assign(Object.assign({}, (_a16 = this.httpProviderOptions) === null || _a16 === void 0 ? void 0 : _a16.providerOptions), requestOptions);
      const response = yield (0, import_cross_fetch5.default)(this.clientUrl, Object.assign(Object.assign({}, providerOptionsCombined), { method: "POST", headers: Object.assign(Object.assign({}, providerOptionsCombined.headers), { "Content-Type": "application/json" }), body: JSON.stringify(payload) }));
      if (!response.ok)
        throw new ResponseError(yield response.json());
      return yield response.json();
    });
  }
  on() {
    throw new MethodNotImplementedError();
  }
  removeListener() {
    throw new MethodNotImplementedError();
  }
  once() {
    throw new MethodNotImplementedError();
  }
  removeAllListeners() {
    throw new MethodNotImplementedError();
  }
  connect() {
    throw new MethodNotImplementedError();
  }
  disconnect() {
    throw new MethodNotImplementedError();
  }
  reset() {
    throw new MethodNotImplementedError();
  }
  reconnect() {
    throw new MethodNotImplementedError();
  }
};

// node_modules/web3-eth-ens/node_modules/web3-providers-ws/lib/esm/index.js
init_shim();

// node_modules/web3-eth-ens/node_modules/isomorphic-ws/browser.js
init_shim();
var ws5 = null;
if (typeof WebSocket !== "undefined") {
  ws5 = WebSocket;
} else if (typeof MozWebSocket !== "undefined") {
  ws5 = MozWebSocket;
} else if (typeof _global !== "undefined") {
  ws5 = _global.WebSocket || _global.MozWebSocket;
} else if (typeof window !== "undefined") {
  ws5 = window.WebSocket || window.MozWebSocket;
} else if (typeof self !== "undefined") {
  ws5 = self.WebSocket || self.MozWebSocket;
}
var browser_default5 = ws5;

// node_modules/web3-eth-ens/node_modules/web3-providers-ws/lib/esm/index.js
var WebSocketProvider5 = class extends SocketProvider5 {
  constructor(socketPath, socketOptions, reconnectOptions) {
    super(socketPath, socketOptions, reconnectOptions);
  }
  _validateProviderPath(providerUrl) {
    return typeof providerUrl === "string" ? /^ws(s)?:\/\//i.test(providerUrl) : false;
  }
  getStatus() {
    if (this._socketConnection && !isNullish8(this._socketConnection)) {
      switch (this._socketConnection.readyState) {
        case this._socketConnection.CONNECTING: {
          return "connecting";
        }
        case this._socketConnection.OPEN: {
          return "connected";
        }
        default: {
          return "disconnected";
        }
      }
    }
    return "disconnected";
  }
  _openSocketConnection() {
    this._socketConnection = new browser_default5(this._socketPath, void 0, this._socketOptions && Object.keys(this._socketOptions).length === 0 ? void 0 : this._socketOptions);
  }
  _closeSocketConnection(code, data) {
    var _a16;
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.close(code, data);
  }
  _sendToSocket(payload) {
    var _a16;
    if (this.getStatus() === "disconnected") {
      throw new ConnectionNotOpenError();
    }
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.send(JSON.stringify(payload));
  }
  _parseResponses(event) {
    return this.chunkResponseParser.parseResponse(event.data);
  }
  _addSocketListeners() {
    var _a16, _b, _c, _d;
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.addEventListener("open", this._onOpenHandler);
    (_b = this._socketConnection) === null || _b === void 0 ? void 0 : _b.addEventListener("message", this._onMessageHandler);
    (_c = this._socketConnection) === null || _c === void 0 ? void 0 : _c.addEventListener("close", (e) => this._onCloseHandler(e));
    (_d = this._socketConnection) === null || _d === void 0 ? void 0 : _d.addEventListener("error", this._onErrorHandler);
  }
  _removeSocketListeners() {
    var _a16, _b, _c;
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.removeEventListener("message", this._onMessageHandler);
    (_b = this._socketConnection) === null || _b === void 0 ? void 0 : _b.removeEventListener("open", this._onOpenHandler);
    (_c = this._socketConnection) === null || _c === void 0 ? void 0 : _c.removeEventListener("close", this._onCloseHandler);
  }
  _onCloseEvent(event) {
    var _a16;
    if (this._reconnectOptions.autoReconnect && (![1e3, 1001].includes(event.code) || !event.wasClean)) {
      this._reconnect();
      return;
    }
    this._clearQueues(event);
    this._removeSocketListeners();
    this._onDisconnect(event.code, event.reason);
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.removeEventListener("error", this._onErrorHandler);
  }
};

// node_modules/web3-eth-ens/node_modules/web3-core/lib/esm/utils.js
init_shim();
var isWeb3Provider5 = (provider) => Web3BaseProvider.isWeb3Provider(provider);
var isMetaMaskProvider5 = (provider) => typeof provider !== "string" && "request" in provider && provider.request.constructor.name === "AsyncFunction" && "isMetaMask" in provider && provider.isMetaMask;
var isLegacyRequestProvider5 = (provider) => typeof provider !== "string" && "request" in provider && provider.request.constructor.name === "Function";
var isEIP1193Provider5 = (provider) => typeof provider !== "string" && "request" in provider && provider.request.constructor.name === "AsyncFunction";
var isLegacySendProvider5 = (provider) => typeof provider !== "string" && "send" in provider;
var isLegacySendAsyncProvider5 = (provider) => typeof provider !== "string" && "sendAsync" in provider;
var isSupportedProvider5 = (provider) => provider && (isWeb3Provider5(provider) || isEIP1193Provider5(provider) || isLegacyRequestProvider5(provider) || isLegacySendAsyncProvider5(provider) || isLegacySendProvider5(provider));
var isSupportSubscriptions5 = (provider) => {
  if (provider && "supportsSubscriptions" in provider) {
    return provider.supportsSubscriptions();
  }
  if (provider && typeof provider !== "string" && "on" in provider) {
    return true;
  }
  return false;
};

// node_modules/web3-eth-ens/node_modules/web3-core/lib/esm/web3_request_manager.js
var __awaiter73 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3RequestManagerEvent5;
(function(Web3RequestManagerEvent7) {
  Web3RequestManagerEvent7["PROVIDER_CHANGED"] = "PROVIDER_CHANGED";
  Web3RequestManagerEvent7["BEFORE_PROVIDER_CHANGE"] = "BEFORE_PROVIDER_CHANGE";
})(Web3RequestManagerEvent5 || (Web3RequestManagerEvent5 = {}));
var availableProviders5 = {
  HttpProvider: HttpProvider5,
  WebsocketProvider: WebSocketProvider5
};
var metamaskPayload5 = (payload) => {
  var _a16;
  if (Array.isArray(payload.params)) {
    const params = payload.params[0];
    if (params.input && !params.data) {
      return Object.assign(Object.assign({}, payload), { params: [Object.assign(Object.assign({}, params), { data: (_a16 = params.data) !== null && _a16 !== void 0 ? _a16 : params.input })] });
    }
  }
  return payload;
};
var Web3RequestManager5 = class extends Web3EventEmitter5 {
  constructor(provider, useRpcCallSpecification) {
    super();
    if (!isNullish8(provider)) {
      this.setProvider(provider);
    }
    this.useRpcCallSpecification = useRpcCallSpecification;
  }
  static get providers() {
    return availableProviders5;
  }
  get provider() {
    return this._provider;
  }
  get providers() {
    return availableProviders5;
  }
  setProvider(provider) {
    let newProvider;
    if (provider && typeof provider === "string" && this.providers) {
      if (/^http(s)?:\/\//i.test(provider)) {
        newProvider = new this.providers.HttpProvider(provider);
      } else if (/^ws(s)?:\/\//i.test(provider)) {
        newProvider = new this.providers.WebsocketProvider(provider);
      } else {
        throw new ProviderError(`Can't autodetect provider for "${provider}"`);
      }
    } else if (isNullish8(provider)) {
      newProvider = void 0;
    } else {
      newProvider = provider;
    }
    this.emit(Web3RequestManagerEvent5.BEFORE_PROVIDER_CHANGE, this._provider);
    this._provider = newProvider;
    this.emit(Web3RequestManagerEvent5.PROVIDER_CHANGED, this._provider);
    return true;
  }
  send(request) {
    return __awaiter73(this, void 0, void 0, function* () {
      const response = yield this._sendRequest(request);
      if (json_rpc_exports7.isResponseWithResult(response)) {
        return response.result;
      }
      throw new ResponseError(response);
    });
  }
  sendBatch(request) {
    return __awaiter73(this, void 0, void 0, function* () {
      const response = yield this._sendRequest(request);
      return response;
    });
  }
  _sendRequest(request) {
    return __awaiter73(this, void 0, void 0, function* () {
      const { provider } = this;
      if (isNullish8(provider)) {
        throw new ProviderError("Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.");
      }
      let payload = json_rpc_exports7.isBatchRequest(request) ? json_rpc_exports7.toBatchPayload(request) : json_rpc_exports7.toPayload(request);
      if (isMetaMaskProvider5(provider)) {
        if (payload.method === "eth_sendTransaction") {
          if (!json_rpc_exports7.isBatchRequest(payload)) {
            payload = metamaskPayload5(payload);
          } else {
            payload = payload.map((p) => metamaskPayload5(p));
          }
        }
      }
      if (isWeb3Provider5(provider)) {
        let response;
        try {
          response = yield provider.request(payload);
        } catch (error) {
          response = error;
        }
        return this._processJsonRpcResponse(payload, response, { legacy: false, error: false });
      }
      if (isEIP1193Provider5(provider)) {
        return provider.request(payload).then((res) => this._processJsonRpcResponse(payload, res, {
          legacy: true,
          error: false
        })).catch((error) => this._processJsonRpcResponse(payload, error, { legacy: true, error: true }));
      }
      if (isLegacyRequestProvider5(provider)) {
        return new Promise((resolve, reject) => {
          const rejectWithError = (err) => reject(this._processJsonRpcResponse(payload, err, {
            legacy: true,
            error: true
          }));
          const resolveWithResponse = (response) => resolve(this._processJsonRpcResponse(payload, response, {
            legacy: true,
            error: false
          }));
          const result = provider.request(
            payload,
            (err, response) => {
              if (err) {
                return rejectWithError(err);
              }
              return resolveWithResponse(response);
            }
          );
          if (isPromise5(result)) {
            const responsePromise = result;
            responsePromise.then(resolveWithResponse).catch(rejectWithError);
          }
        });
      }
      if (isLegacySendProvider5(provider)) {
        return new Promise((resolve, reject) => {
          provider.send(payload, (err, response) => {
            if (err) {
              return reject(this._processJsonRpcResponse(payload, err, {
                legacy: true,
                error: true
              }));
            }
            if (isNullish8(response)) {
              throw new ResponseError("", 'Got a "nullish" response from provider.');
            }
            return resolve(this._processJsonRpcResponse(payload, response, {
              legacy: true,
              error: false
            }));
          });
        });
      }
      if (isLegacySendAsyncProvider5(provider)) {
        return provider.sendAsync(payload).then((response) => this._processJsonRpcResponse(payload, response, { legacy: true, error: false })).catch((error) => this._processJsonRpcResponse(payload, error, {
          legacy: true,
          error: true
        }));
      }
      throw new ProviderError("Provider does not have a request or send method to use.");
    });
  }
  _processJsonRpcResponse(payload, response, { legacy, error }) {
    if (isNullish8(response)) {
      return this._buildResponse(
        payload,
        null,
        error
      );
    }
    if (json_rpc_exports7.isResponseWithError(response)) {
      if (this.useRpcCallSpecification && isResponseRpcError7(response)) {
        const rpcErrorResponse = response;
        if (rpcErrorsMap.get(rpcErrorResponse.error.code)) {
          const Err = rpcErrorsMap.get(rpcErrorResponse.error.code).error;
          throw new Err(rpcErrorResponse);
        } else {
          throw new RpcError(rpcErrorResponse);
        }
      } else if (!Web3RequestManager5._isReverted(response)) {
        throw new InvalidResponseError(response, payload);
      }
    }
    if (json_rpc_exports7.isResponseWithResult(response)) {
      return response;
    }
    if (response instanceof Error) {
      Web3RequestManager5._isReverted(response);
      throw response;
    }
    if (!legacy && json_rpc_exports7.isBatchRequest(payload) && json_rpc_exports7.isBatchResponse(response)) {
      return response;
    }
    if (legacy && !error && json_rpc_exports7.isBatchRequest(payload)) {
      return response;
    }
    if (legacy && error && json_rpc_exports7.isBatchRequest(payload)) {
      throw response;
    }
    if (legacy && !json_rpc_exports7.isResponseWithError(response) && !json_rpc_exports7.isResponseWithResult(response)) {
      return this._buildResponse(payload, response, error);
    }
    if (json_rpc_exports7.isBatchRequest(payload) && !Array.isArray(response)) {
      throw new ResponseError(response, "Got normal response for a batch request.");
    }
    if (!json_rpc_exports7.isBatchRequest(payload) && Array.isArray(response)) {
      throw new ResponseError(response, "Got batch response for a normal request.");
    }
    if ((json_rpc_exports7.isResponseWithError(response) || json_rpc_exports7.isResponseWithResult(response)) && !json_rpc_exports7.isBatchRequest(payload)) {
      if (response.id && payload.id !== response.id) {
        throw new InvalidResponseError(response);
      }
    }
    throw new ResponseError(response, "Invalid response");
  }
  static _isReverted(response) {
    let error;
    if (json_rpc_exports7.isResponseWithError(response)) {
      error = response.error;
    } else if (response instanceof Error) {
      error = response;
    }
    if (error === null || error === void 0 ? void 0 : error.message.includes("revert"))
      throw new ContractExecutionError(error);
    return false;
  }
  _buildResponse(payload, response, error) {
    const res = {
      jsonrpc: "2.0",
      id: json_rpc_exports7.isBatchRequest(payload) ? payload[0].id : "id" in payload ? payload.id : null
    };
    if (error) {
      return Object.assign(Object.assign({}, res), { error: response });
    }
    return Object.assign(Object.assign({}, res), { result: response });
  }
};

// node_modules/web3-eth-ens/node_modules/web3-core/lib/esm/web3_subscription_manager.js
init_shim();
var __awaiter74 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3SubscriptionManager5 = class {
  constructor(requestManager, registeredSubscriptions2, tolerateUnlinkedSubscription = false) {
    this.requestManager = requestManager;
    this.registeredSubscriptions = registeredSubscriptions2;
    this.tolerateUnlinkedSubscription = tolerateUnlinkedSubscription;
    this._subscriptions = /* @__PURE__ */ new Map();
    this.requestManager.on(Web3RequestManagerEvent5.BEFORE_PROVIDER_CHANGE, () => __awaiter74(this, void 0, void 0, function* () {
      yield this.unsubscribe();
    }));
    this.requestManager.on(Web3RequestManagerEvent5.PROVIDER_CHANGED, () => {
      this.clear();
      this.listenToProviderEvents();
    });
    this.listenToProviderEvents();
  }
  listenToProviderEvents() {
    const providerAsWebProvider = this.requestManager.provider;
    if (!this.requestManager.provider || typeof (providerAsWebProvider === null || providerAsWebProvider === void 0 ? void 0 : providerAsWebProvider.supportsSubscriptions) === "function" && !(providerAsWebProvider === null || providerAsWebProvider === void 0 ? void 0 : providerAsWebProvider.supportsSubscriptions())) {
      return;
    }
    if (typeof this.requestManager.provider.on === "function") {
      if (typeof this.requestManager.provider.request === "function") {
        this.requestManager.provider.on(
          "message",
          (message) => this.messageListener(message)
        );
      } else {
        providerAsWebProvider.on("data", (data) => this.messageListener(data));
      }
    }
  }
  messageListener(data) {
    var _a16, _b, _c;
    if (!data) {
      throw new SubscriptionError("Should not call messageListener with no data. Type was");
    }
    const subscriptionId = ((_a16 = data.params) === null || _a16 === void 0 ? void 0 : _a16.subscription) || ((_b = data.data) === null || _b === void 0 ? void 0 : _b.subscription) || ((_c = data.id) === null || _c === void 0 ? void 0 : _c.toString(16));
    if (subscriptionId) {
      const sub = this._subscriptions.get(subscriptionId);
      sub === null || sub === void 0 ? void 0 : sub.processSubscriptionData(data);
    }
  }
  subscribe(name2, args, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter74(this, void 0, void 0, function* () {
      const Klass = this.registeredSubscriptions[name2];
      if (!Klass) {
        throw new SubscriptionError("Invalid subscription type");
      }
      const subscription = new Klass(args !== null && args !== void 0 ? args : void 0, {
        subscriptionManager: this,
        returnFormat
      });
      yield this.addSubscription(subscription);
      return subscription;
    });
  }
  get subscriptions() {
    return this._subscriptions;
  }
  addSubscription(sub) {
    return __awaiter74(this, void 0, void 0, function* () {
      if (!this.requestManager.provider) {
        throw new ProviderError("Provider not available");
      }
      if (!this.supportsSubscriptions()) {
        throw new SubscriptionError("The current provider does not support subscriptions");
      }
      if (sub.id && this._subscriptions.has(sub.id)) {
        throw new SubscriptionError(`Subscription with id "${sub.id}" already exists`);
      }
      yield sub.sendSubscriptionRequest();
      if (isNullish8(sub.id)) {
        throw new SubscriptionError("Subscription is not subscribed yet.");
      }
      this._subscriptions.set(sub.id, sub);
      return sub.id;
    });
  }
  removeSubscription(sub) {
    return __awaiter74(this, void 0, void 0, function* () {
      const { id } = sub;
      if (isNullish8(id)) {
        throw new SubscriptionError("Subscription is not subscribed yet. Or, had already been unsubscribed but not through the Subscription Manager.");
      }
      if (!this._subscriptions.has(id) && !this.tolerateUnlinkedSubscription) {
        throw new SubscriptionError(`Subscription with id "${id.toString()}" does not exists`);
      }
      yield sub.sendUnsubscribeRequest();
      this._subscriptions.delete(id);
      return id;
    });
  }
  unsubscribe(condition) {
    return __awaiter74(this, void 0, void 0, function* () {
      const result = [];
      for (const [id, sub] of this.subscriptions.entries()) {
        if (!condition || typeof condition === "function" && condition({ id, sub })) {
          result.push(this.removeSubscription(sub));
        }
      }
      return Promise.all(result);
    });
  }
  clear() {
    this._subscriptions.clear();
  }
  supportsSubscriptions() {
    return isNullish8(this.requestManager.provider) ? false : isSupportSubscriptions5(this.requestManager.provider);
  }
};

// node_modules/web3-eth-ens/node_modules/web3-core/lib/esm/web3_subscriptions.js
init_shim();

// node_modules/web3-eth-ens/node_modules/web3-core/lib/esm/web3_context.js
init_shim();

// node_modules/web3-eth-ens/node_modules/web3-core/lib/esm/web3_batch_request.js
init_shim();
var __awaiter75 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_BATCH_REQUEST_TIMEOUT5 = 1e3;
var Web3BatchRequest5 = class {
  constructor(requestManager) {
    this._requestManager = requestManager;
    this._requests = /* @__PURE__ */ new Map();
  }
  get requests() {
    return [...this._requests.values()].map((r) => r.payload);
  }
  add(request) {
    const payload = json_rpc_exports7.toPayload(request);
    const promise = new Web3DeferredPromise7();
    this._requests.set(payload.id, { payload, promise });
    return promise;
  }
  execute(options) {
    var _a16;
    return __awaiter75(this, void 0, void 0, function* () {
      if (this.requests.length === 0) {
        return Promise.resolve([]);
      }
      const request = new Web3DeferredPromise7({
        timeout: (_a16 = options === null || options === void 0 ? void 0 : options.timeout) !== null && _a16 !== void 0 ? _a16 : DEFAULT_BATCH_REQUEST_TIMEOUT5,
        eagerStart: true,
        timeoutMessage: "Batch request timeout"
      });
      this._processBatchRequest(request).catch((err) => request.reject(err));
      request.catch((err) => {
        if (err instanceof OperationTimeoutError) {
          this._abortAllRequests("Batch request timeout");
        }
        request.reject(err);
      });
      return request;
    });
  }
  _processBatchRequest(promise) {
    var _a16, _b;
    return __awaiter75(this, void 0, void 0, function* () {
      const response = yield this._requestManager.sendBatch([...this._requests.values()].map((r) => r.payload));
      if (response.length !== this._requests.size) {
        this._abortAllRequests("Invalid batch response");
        throw new ResponseError(response, `Batch request size mismatch the results size. Requests: ${this._requests.size}, Responses: ${response.length}`);
      }
      const requestIds = this.requests.map((r) => r.id).map(Number).sort((a, b) => a - b);
      const responseIds = response.map((r) => r.id).map(Number).sort((a, b) => a - b);
      if (JSON.stringify(requestIds) !== JSON.stringify(responseIds)) {
        this._abortAllRequests("Invalid batch response");
        throw new ResponseError(response, `Batch request mismatch the results. Requests: [${requestIds.join()}], Responses: [${responseIds.join()}]`);
      }
      for (const res of response) {
        if (json_rpc_exports7.isResponseWithResult(res)) {
          (_a16 = this._requests.get(res.id)) === null || _a16 === void 0 ? void 0 : _a16.promise.resolve(res.result);
        } else if (json_rpc_exports7.isResponseWithError(res)) {
          (_b = this._requests.get(res.id)) === null || _b === void 0 ? void 0 : _b.promise.reject(res.error);
        }
      }
      promise.resolve(response);
    });
  }
  _abortAllRequests(msg) {
    for (const { promise } of this._requests.values()) {
      promise.reject(new OperationAbortError(msg));
    }
  }
};

// node_modules/web3-eth-ens/node_modules/web3-core/lib/esm/web3_context.js
var __awaiter76 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3Context5 = class extends Web3Config5 {
  constructor(providerOrContext) {
    var _a16;
    super();
    this.providers = Web3RequestManager5.providers;
    if (isNullish8(providerOrContext) || typeof providerOrContext === "string" && providerOrContext.trim() !== "" || isSupportedProvider5(providerOrContext)) {
      this._requestManager = new Web3RequestManager5(providerOrContext);
      this._subscriptionManager = new Web3SubscriptionManager5(this._requestManager, {});
      return;
    }
    const { config, provider, requestManager, subscriptionManager, registeredSubscriptions: registeredSubscriptions2, accountProvider, wallet } = providerOrContext;
    this.setConfig(config !== null && config !== void 0 ? config : {});
    this._requestManager = requestManager !== null && requestManager !== void 0 ? requestManager : new Web3RequestManager5(provider, (_a16 = config === null || config === void 0 ? void 0 : config.enableExperimentalFeatures) === null || _a16 === void 0 ? void 0 : _a16.useSubscriptionWhenCheckingBlockTimeout);
    if (subscriptionManager) {
      this._subscriptionManager = subscriptionManager;
    } else {
      this._subscriptionManager = new Web3SubscriptionManager5(this.requestManager, registeredSubscriptions2 !== null && registeredSubscriptions2 !== void 0 ? registeredSubscriptions2 : {});
    }
    if (accountProvider) {
      this._accountProvider = accountProvider;
    }
    if (wallet) {
      this._wallet = wallet;
    }
  }
  get requestManager() {
    return this._requestManager;
  }
  get subscriptionManager() {
    return this._subscriptionManager;
  }
  get wallet() {
    return this._wallet;
  }
  get accountProvider() {
    return this._accountProvider;
  }
  static fromContextObject(...args) {
    return new this(...args.reverse());
  }
  getContextObject() {
    var _a16;
    return {
      config: this.config,
      provider: this.provider,
      requestManager: this.requestManager,
      subscriptionManager: this.subscriptionManager,
      registeredSubscriptions: (_a16 = this.subscriptionManager) === null || _a16 === void 0 ? void 0 : _a16.registeredSubscriptions,
      providers: this.providers,
      wallet: this.wallet,
      accountProvider: this.accountProvider
    };
  }
  use(ContextRef, ...args) {
    const newContextChild = new ContextRef(...[...args, this.getContextObject()]);
    this.on(Web3ConfigEvent5.CONFIG_CHANGE, (event) => {
      newContextChild.setConfig({ [event.name]: event.newValue });
    });
    return newContextChild;
  }
  link(parentContext) {
    this.setConfig(parentContext.config);
    this._requestManager = parentContext.requestManager;
    this.provider = parentContext.provider;
    this._subscriptionManager = parentContext.subscriptionManager;
    this._wallet = parentContext.wallet;
    this._accountProvider = parentContext._accountProvider;
    parentContext.on(Web3ConfigEvent5.CONFIG_CHANGE, (event) => {
      this.setConfig({ [event.name]: event.newValue });
    });
  }
  registerPlugin(plugin) {
    if (this[plugin.pluginNamespace] !== void 0)
      throw new ExistingPluginNamespaceError(plugin.pluginNamespace);
    const _pluginObject = {
      [plugin.pluginNamespace]: plugin
    };
    _pluginObject[plugin.pluginNamespace].link(this);
    Object.assign(this, _pluginObject);
  }
  get provider() {
    return this.currentProvider;
  }
  set provider(provider) {
    this.requestManager.setProvider(provider);
  }
  get currentProvider() {
    return this.requestManager.provider;
  }
  set currentProvider(provider) {
    this.requestManager.setProvider(provider);
  }
  get givenProvider() {
    return Web3Context5.givenProvider;
  }
  setProvider(provider) {
    this.provider = provider;
    return true;
  }
  get BatchRequest() {
    return Web3BatchRequest5.bind(void 0, this._requestManager);
  }
  extend(extendObj) {
    var _a16;
    if (extendObj.property && !this[extendObj.property])
      this[extendObj.property] = {};
    (_a16 = extendObj.methods) === null || _a16 === void 0 ? void 0 : _a16.forEach((element) => {
      const method = (...givenParams) => __awaiter76(this, void 0, void 0, function* () {
        return this.requestManager.send({
          method: element.call,
          params: givenParams
        });
      });
      if (extendObj.property)
        this[extendObj.property][element.name] = method;
      else
        this[element.name] = method;
    });
    return this;
  }
};
Web3Context5.providers = Web3RequestManager5.providers;

// node_modules/web3-eth-ens/node_modules/web3-core/lib/esm/types.js
init_shim();

// node_modules/web3-eth-ens/node_modules/web3-core/lib/esm/formatters.js
var formatters_exports5 = {};
__export(formatters_exports5, {
  inputAddressFormatter: () => inputAddressFormatter5,
  inputBlockNumberFormatter: () => inputBlockNumberFormatter5,
  inputCallFormatter: () => inputCallFormatter5,
  inputDefaultBlockNumberFormatter: () => inputDefaultBlockNumberFormatter5,
  inputLogFormatter: () => inputLogFormatter5,
  inputPostFormatter: () => inputPostFormatter5,
  inputSignFormatter: () => inputSignFormatter5,
  inputStorageKeysFormatter: () => inputStorageKeysFormatter5,
  inputTopicFormatter: () => inputTopicFormatter5,
  inputTransactionFormatter: () => inputTransactionFormatter5,
  outputBigIntegerFormatter: () => outputBigIntegerFormatter5,
  outputBlockFormatter: () => outputBlockFormatter5,
  outputLogFormatter: () => outputLogFormatter5,
  outputPostFormatter: () => outputPostFormatter5,
  outputProofFormatter: () => outputProofFormatter5,
  outputSyncingFormatter: () => outputSyncingFormatter5,
  outputTransactionFormatter: () => outputTransactionFormatter5,
  outputTransactionReceiptFormatter: () => outputTransactionReceiptFormatter5,
  txInputOptionsFormatter: () => txInputOptionsFormatter5
});
init_shim();

// node_modules/web3-eth-ens/node_modules/web3-eth-iban/lib/esm/index.js
init_shim();

// node_modules/web3-eth-ens/node_modules/web3-eth-iban/lib/esm/iban.js
init_shim();
var Iban5 = class {
  constructor(iban) {
    this.toAddress = () => {
      if (this.isDirect()) {
        const base36 = this._iban.slice(4);
        const parsedBigInt = Iban5._parseInt(base36, 36);
        const paddedBigInt = leftPad7(parsedBigInt, 40);
        return toChecksumAddress7(paddedBigInt);
      }
      throw new Error("Iban is indirect and cannot be converted. Must be length of 34 or 35");
    };
    if (Iban5.isIndirect(iban) || Iban5.isDirect(iban)) {
      this._iban = iban;
    } else {
      throw new Error("Invalid IBAN was provided");
    }
  }
  static isDirect(iban) {
    return iban.length === 34 || iban.length === 35;
  }
  isDirect() {
    return Iban5.isDirect(this._iban);
  }
  static isIndirect(iban) {
    return iban.length === 20;
  }
  isIndirect() {
    return Iban5.isIndirect(this._iban);
  }
  static isValid(iban) {
    return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(iban) && Iban5._mod9710(Iban5._iso13616Prepare(iban)) === 1;
  }
  isValid() {
    return Iban5.isValid(this._iban);
  }
  static fromBban(bban) {
    const countryCode = "XE";
    const remainder = this._mod9710(this._iso13616Prepare(`${countryCode}00${bban}`));
    const checkDigit = `0${(98 - remainder).toString()}`.slice(-2);
    return new Iban5(`${countryCode}${checkDigit}${bban}`);
  }
  static createIndirect(options) {
    return Iban5.fromBban(`ETH${options.institution}${options.identifier}`);
  }
  static fromAddress(address) {
    if (!isAddress(address)) {
      throw new InvalidAddressError(address);
    }
    const num = BigInt(hexToNumber7(address));
    const base36 = num.toString(36);
    const padded = leftPad7(base36, 15);
    return Iban5.fromBban(padded.toUpperCase());
  }
  static toIban(address) {
    return Iban5.fromAddress(address).toString();
  }
  client() {
    return this.isIndirect() ? this._iban.slice(11) : "";
  }
  checksum() {
    return this._iban.slice(2, 4);
  }
  institution() {
    return this.isIndirect() ? this._iban.slice(7, 11) : "";
  }
  toString() {
    return this._iban;
  }
};
Iban5._iso13616Prepare = (iban) => {
  const A = "A".charCodeAt(0);
  const Z = "Z".charCodeAt(0);
  const upperIban = iban.toUpperCase();
  const modifiedIban = `${upperIban.slice(4)}${upperIban.slice(0, 4)}`;
  return modifiedIban.split("").map((n) => {
    const code = n.charCodeAt(0);
    if (code >= A && code <= Z) {
      return code - A + 10;
    }
    return n;
  }).join("");
};
Iban5._parseInt = (str, base2) => [...str].reduce((acc, curr) => BigInt(parseInt(curr, base2)) + BigInt(base2) * acc, BigInt(0));
Iban5._mod9710 = (iban) => {
  let remainder = iban;
  let block;
  while (remainder.length > 2) {
    block = remainder.slice(0, 9);
    remainder = `${(parseInt(block, 10) % 97).toString()}${remainder.slice(block.length)}`;
  }
  return parseInt(remainder, 10) % 97;
};
Iban5.toAddress = (iban) => {
  const ibanObject = new Iban5(iban);
  return ibanObject.toAddress();
};

// node_modules/web3-eth-ens/node_modules/web3-eth-iban/lib/esm/types.js
init_shim();

// node_modules/web3-eth-ens/node_modules/web3-core/lib/esm/formatters.js
var inputStorageKeysFormatter5 = (keys) => keys.map((num) => numberToHex8(num));
var outputProofFormatter5 = (proof) => ({
  address: toChecksumAddress7(proof.address),
  nonce: hexToNumberString5(proof.nonce),
  balance: hexToNumberString5(proof.balance)
});
var outputBigIntegerFormatter5 = (number) => toNumber7(number);
var inputBlockNumberFormatter5 = (blockNumber) => {
  if (isNullish(blockNumber)) {
    return void 0;
  }
  if (typeof blockNumber === "string" && isBlockTag(blockNumber)) {
    return blockNumber;
  }
  if (blockNumber === "genesis") {
    return "0x0";
  }
  if (typeof blockNumber === "string" && isHexStrict6(blockNumber)) {
    return blockNumber.toLowerCase();
  }
  return numberToHex8(blockNumber);
};
var inputDefaultBlockNumberFormatter5 = (blockNumber, defaultBlock) => {
  if (!blockNumber) {
    return inputBlockNumberFormatter5(defaultBlock);
  }
  return inputBlockNumberFormatter5(blockNumber);
};
var inputAddressFormatter5 = (address) => {
  if (Iban5.isValid(address) && Iban5.isDirect(address)) {
    const iban = new Iban5(address);
    return iban.toAddress().toLowerCase();
  }
  if (isAddress6(address)) {
    return `0x${address.toLowerCase().replace("0x", "")}`;
  }
  throw new FormatterError(`Provided address ${address} is invalid, the capitalization checksum test failed, or it's an indirect IBAN address which can't be converted.`);
};
var txInputOptionsFormatter5 = (options) => {
  var _a16;
  const modifiedOptions = Object.assign({}, options);
  if (options.to) {
    modifiedOptions.to = inputAddressFormatter5(options.to);
  }
  if (options.data && options.input) {
    throw new FormatterError(`You can't have "data" and "input" as properties of transactions at the same time, please use either "data" or "input" instead.`);
  }
  if (!options.input && options.data) {
    modifiedOptions.input = options.data;
    delete modifiedOptions.data;
  }
  if (options.input && !options.input.startsWith("0x")) {
    modifiedOptions.input = `0x${options.input}`;
  }
  if (modifiedOptions.input && !isHexStrict6(modifiedOptions.input)) {
    throw new FormatterError("The input field must be HEX encoded data.");
  }
  if (options.gas || options.gasLimit) {
    modifiedOptions.gas = toNumber7((_a16 = options.gas) !== null && _a16 !== void 0 ? _a16 : options.gasLimit);
  }
  if (options.maxPriorityFeePerGas || options.maxFeePerGas) {
    delete modifiedOptions.gasPrice;
  }
  ["gasPrice", "gas", "value", "maxPriorityFeePerGas", "maxFeePerGas", "nonce", "chainId"].filter((key) => !isNullish(modifiedOptions[key])).forEach((key) => {
    modifiedOptions[key] = numberToHex8(modifiedOptions[key]);
  });
  return modifiedOptions;
};
var inputCallFormatter5 = (options, defaultAccount) => {
  var _a16;
  const opts = txInputOptionsFormatter5(options);
  const from = (_a16 = opts.from) !== null && _a16 !== void 0 ? _a16 : defaultAccount;
  if (from) {
    opts.from = inputAddressFormatter5(from);
  }
  return opts;
};
var inputTransactionFormatter5 = (options, defaultAccount) => {
  var _a16;
  const opts = txInputOptionsFormatter5(options);
  if (!(typeof opts.from === "number") && !(!!opts.from && typeof opts.from === "object")) {
    opts.from = (_a16 = opts.from) !== null && _a16 !== void 0 ? _a16 : defaultAccount;
    if (!options.from && !(typeof options.from === "number")) {
      throw new FormatterError('The send transactions "from" field must be defined!');
    }
    opts.from = inputAddressFormatter5(options.from);
  }
  return opts;
};
var inputSignFormatter5 = (data) => isHexStrict6(data) ? data : utf8ToHex7(data);
var outputTransactionFormatter5 = (tx) => {
  const modifiedTx = Object.assign({}, tx);
  if (tx.blockNumber) {
    modifiedTx.blockNumber = hexToNumber7(tx.blockNumber);
  }
  if (tx.transactionIndex) {
    modifiedTx.transactionIndex = hexToNumber7(tx.transactionIndex);
  }
  modifiedTx.nonce = hexToNumber7(tx.nonce);
  modifiedTx.gas = hexToNumber7(tx.gas);
  if (tx.gasPrice) {
    modifiedTx.gasPrice = outputBigIntegerFormatter5(tx.gasPrice);
  }
  if (tx.maxFeePerGas) {
    modifiedTx.maxFeePerGas = outputBigIntegerFormatter5(tx.maxFeePerGas);
  }
  if (tx.maxPriorityFeePerGas) {
    modifiedTx.maxPriorityFeePerGas = outputBigIntegerFormatter5(tx.maxPriorityFeePerGas);
  }
  if (tx.type) {
    modifiedTx.type = hexToNumber7(tx.type);
  }
  modifiedTx.value = outputBigIntegerFormatter5(tx.value);
  if (tx.to && isAddress6(tx.to)) {
    modifiedTx.to = toChecksumAddress7(tx.to);
  } else {
    modifiedTx.to = void 0;
  }
  if (tx.from) {
    modifiedTx.from = toChecksumAddress7(tx.from);
  }
  return modifiedTx;
};
var inputTopicFormatter5 = (topic) => {
  if (isNullish(topic))
    return null;
  const value = String(topic);
  return isHex(value) ? value : fromUtf86(value);
};
var inputLogFormatter5 = (filter) => {
  var _a16;
  const val = isNullish(filter) ? {} : mergeDeep7({}, filter);
  if (isNullish(val.fromBlock)) {
    val.fromBlock = BlockTags.LATEST;
  }
  val.fromBlock = inputBlockNumberFormatter5(val.fromBlock);
  if (!isNullish(val.toBlock)) {
    val.toBlock = inputBlockNumberFormatter5(val.toBlock);
  }
  val.topics = (_a16 = val.topics) !== null && _a16 !== void 0 ? _a16 : [];
  val.topics = val.topics.map((topic) => Array.isArray(topic) ? topic.map(inputTopicFormatter5) : inputTopicFormatter5(topic));
  if (val.address) {
    val.address = Array.isArray(val.address) ? val.address.map((addr) => inputAddressFormatter5(addr)) : inputAddressFormatter5(val.address);
  }
  return val;
};
var outputLogFormatter5 = (log) => {
  const modifiedLog = Object.assign({}, log);
  const logIndex = typeof log.logIndex === "string" ? log.logIndex : numberToHex8(log.logIndex);
  if (typeof log.blockHash === "string" && typeof log.transactionHash === "string") {
    const shaId = sha3Raw7(`${log.blockHash.replace("0x", "")}${log.transactionHash.replace("0x", "")}${logIndex.replace("0x", "")}`);
    modifiedLog.id = `log_${shaId.replace("0x", "").slice(0, 8)}`;
  } else if (!log.id) {
    modifiedLog.id = void 0;
  }
  if (log.blockNumber && isHexStrict6(log.blockNumber)) {
    modifiedLog.blockNumber = hexToNumber7(log.blockNumber);
  }
  if (log.transactionIndex && isHexStrict6(log.transactionIndex)) {
    modifiedLog.transactionIndex = hexToNumber7(log.transactionIndex);
  }
  if (log.logIndex && isHexStrict6(log.logIndex)) {
    modifiedLog.logIndex = hexToNumber7(log.logIndex);
  }
  if (log.address) {
    modifiedLog.address = toChecksumAddress7(log.address);
  }
  return modifiedLog;
};
var outputTransactionReceiptFormatter5 = (receipt) => {
  if (typeof receipt !== "object") {
    throw new FormatterError(`Received receipt is invalid: ${String(receipt)}`);
  }
  const modifiedReceipt = Object.assign({}, receipt);
  if (receipt.blockNumber) {
    modifiedReceipt.blockNumber = hexToNumber7(receipt.blockNumber);
  }
  if (receipt.transactionIndex) {
    modifiedReceipt.transactionIndex = hexToNumber7(receipt.transactionIndex);
  }
  modifiedReceipt.cumulativeGasUsed = hexToNumber7(receipt.cumulativeGasUsed);
  modifiedReceipt.gasUsed = hexToNumber7(receipt.gasUsed);
  if (receipt.logs && Array.isArray(receipt.logs)) {
    modifiedReceipt.logs = receipt.logs.map(outputLogFormatter5);
  }
  if (receipt.effectiveGasPrice) {
    modifiedReceipt.effectiveGasPrice = hexToNumber7(receipt.effectiveGasPrice);
  }
  if (receipt.contractAddress) {
    modifiedReceipt.contractAddress = toChecksumAddress7(receipt.contractAddress);
  }
  if (receipt.status) {
    modifiedReceipt.status = Boolean(parseInt(receipt.status, 10));
  }
  return modifiedReceipt;
};
var outputBlockFormatter5 = (block) => {
  const modifiedBlock = Object.assign({}, block);
  modifiedBlock.gasLimit = hexToNumber7(block.gasLimit);
  modifiedBlock.gasUsed = hexToNumber7(block.gasUsed);
  modifiedBlock.size = hexToNumber7(block.size);
  modifiedBlock.timestamp = hexToNumber7(block.timestamp);
  if (block.number) {
    modifiedBlock.number = hexToNumber7(block.number);
  }
  if (block.difficulty) {
    modifiedBlock.difficulty = outputBigIntegerFormatter5(block.difficulty);
  }
  if (block.totalDifficulty) {
    modifiedBlock.totalDifficulty = outputBigIntegerFormatter5(block.totalDifficulty);
  }
  if (block.transactions && Array.isArray(block.transactions)) {
    modifiedBlock.transactions = block.transactions.map(outputTransactionFormatter5);
  }
  if (block.miner) {
    modifiedBlock.miner = toChecksumAddress7(block.miner);
  }
  if (block.baseFeePerGas) {
    modifiedBlock.baseFeePerGas = outputBigIntegerFormatter5(block.baseFeePerGas);
  }
  return modifiedBlock;
};
var inputPostFormatter5 = (post) => {
  var _a16;
  const modifiedPost = Object.assign({}, post);
  if (post.ttl) {
    modifiedPost.ttl = numberToHex8(post.ttl);
  }
  if (post.workToProve) {
    modifiedPost.workToProve = numberToHex8(post.workToProve);
  }
  if (post.priority) {
    modifiedPost.priority = numberToHex8(post.priority);
  }
  if (post.topics && !Array.isArray(post.topics)) {
    modifiedPost.topics = post.topics ? [post.topics] : [];
  }
  modifiedPost.topics = (_a16 = modifiedPost.topics) === null || _a16 === void 0 ? void 0 : _a16.map((topic) => topic.startsWith("0x") ? topic : fromUtf86(topic));
  return modifiedPost;
};
var outputPostFormatter5 = (post) => {
  var _a16;
  const modifiedPost = Object.assign({}, post);
  if (post.expiry) {
    modifiedPost.expiry = hexToNumber7(post.expiry);
  }
  if (post.sent) {
    modifiedPost.sent = hexToNumber7(post.sent);
  }
  if (post.ttl) {
    modifiedPost.ttl = hexToNumber7(post.ttl);
  }
  if (post.workProved) {
    modifiedPost.workProved = hexToNumber7(post.workProved);
  }
  if (!post.topics) {
    modifiedPost.topics = [];
  }
  modifiedPost.topics = (_a16 = modifiedPost.topics) === null || _a16 === void 0 ? void 0 : _a16.map(toUtf85);
  return modifiedPost;
};
var outputSyncingFormatter5 = (result) => {
  const modifiedResult = Object.assign({}, result);
  modifiedResult.startingBlock = hexToNumber7(result.startingBlock);
  modifiedResult.currentBlock = hexToNumber7(result.currentBlock);
  modifiedResult.highestBlock = hexToNumber7(result.highestBlock);
  if (result.knownStates) {
    modifiedResult.knownStates = hexToNumber7(result.knownStates);
  }
  if (result.pulledStates) {
    modifiedResult.pulledStates = hexToNumber7(result.pulledStates);
  }
  return modifiedResult;
};

// node_modules/web3-eth-ens/node_modules/web3-core/lib/esm/web3_promi_event.js
init_shim();
var _a13;
_a13 = Symbol.toStringTag;

// node_modules/web3-eth-ens/lib/esm/registry.js
init_shim();

// node_modules/web3-eth-ens/lib/esm/abi/ens/ENSRegistry.js
init_shim();
var ENSRegistryAbi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "label",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "NewOwner",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "resolver",
        type: "address"
      }
    ],
    name: "NewResolver",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "recordExists",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "resolver",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "ttl",
    outputs: [
      {
        internalType: "uint64",
        name: "",
        type: "uint64"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/web3-eth-ens/lib/esm/abi/ens/PublicResolver.js
init_shim();
var PublicResolverAbi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "a",
        type: "address"
      }
    ],
    name: "AddrChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "coinType",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "newAddress",
        type: "bytes"
      }
    ],
    name: "AddressChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "hash",
        type: "bytes"
      }
    ],
    name: "ContenthashChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "name",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "resource",
        type: "uint16"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "record",
        type: "bytes"
      }
    ],
    name: "DNSRecordChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "name",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "resource",
        type: "uint16"
      }
    ],
    name: "DNSRecordDeleted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "DNSZoneCleared",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "lastzonehash",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "zonehash",
        type: "bytes"
      }
    ],
    name: "DNSZonehashChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes4",
        name: "interfaceID",
        type: "bytes4"
      },
      {
        indexed: false,
        internalType: "address",
        name: "implementer",
        type: "address"
      }
    ],
    name: "InterfaceChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "string",
        name: "name",
        type: "string"
      }
    ],
    name: "NameChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "x",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "y",
        type: "bytes32"
      }
    ],
    name: "PubkeyChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "string",
        name: "indexedKey",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "key",
        type: "string"
      }
    ],
    name: "TextChanged",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "contentTypes",
        type: "uint256"
      }
    ],
    name: "ABI",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "addr",
    outputs: [
      {
        internalType: "address payable",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "coinType",
        type: "uint256"
      }
    ],
    name: "addr",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "contenthash",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "name",
        type: "bytes32"
      },
      {
        internalType: "uint16",
        name: "resource",
        type: "uint16"
      }
    ],
    name: "dnsRecord",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "name",
        type: "bytes32"
      }
    ],
    name: "hasDNSRecords",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "bytes4",
        name: "interfaceID",
        type: "bytes4"
      }
    ],
    name: "interfaceImplementer",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "pubkey",
    outputs: [
      {
        internalType: "bytes32",
        name: "x",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "y",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceID",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "string",
        name: "key",
        type: "string"
      }
    ],
    name: "text",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "zonehash",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/web3-eth-ens/lib/esm/utils.js
init_shim();

// node_modules/@adraffy/ens-normalize/dist/index.mjs
init_shim();
var COMPRESSED$1 = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
var FENCED = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
var NSM_MAX = 4;
function decode_arithmetic(bytes) {
  let pos = 0;
  function u16() {
    return bytes[pos++] << 8 | bytes[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i = 1; i < symbol_count; i++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N = 31;
  const FULL = 2 ** N;
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i = 0; i < N; i++)
    register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0)
      break;
    symbols.push(start);
    let a = low + Math.floor(range * acc[start] / total);
    let b = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a ^ b) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a = a << 1 & MASK;
      b = b << 1 & MASK | 1;
    }
    while (a & ~b & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a = a << 1 ^ HALF;
      b = (b ^ HALF) << 1 | HALF | 1;
    }
    low = a;
    range = 1 + b - a;
  }
  let offset = symbol_count - 4;
  return symbols.map((x) => {
    switch (x - offset) {
      case 3:
        return offset + 65792 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 2:
        return offset + 256 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 1:
        return offset + bytes[pos_payload++];
      default:
        return x - 1;
    }
  });
}
function read_payload(v) {
  let pos = 0;
  return () => v[pos++];
}
function read_compressed_payload(s) {
  return read_payload(decode_arithmetic(unsafe_atob(s)));
}
function unsafe_atob(s) {
  let lookup = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c, i) => lookup[c.charCodeAt(0)] = i);
  let n = s.length;
  let ret = new Uint8Array(6 * n >> 3);
  for (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {
    carry = carry << 6 | lookup[s.charCodeAt(i)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
}
function signed(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
}
function read_deltas(n, next) {
  let v = Array(n);
  for (let i = 0, x = 0; i < n; i++)
    v[i] = x += signed(next());
  return v;
}
function read_sorted(next, prev = 0) {
  let ret = [];
  while (true) {
    let x = next();
    let n = next();
    if (!n)
      break;
    prev += x;
    for (let i = 0; i < n; i++) {
      ret.push(prev + i);
    }
    prev += n + 1;
  }
  return ret;
}
function read_sorted_arrays(next) {
  return read_array_while(() => {
    let v = read_sorted(next);
    if (v.length)
      return v;
  });
}
function read_mapped(next) {
  let ret = [];
  while (true) {
    let w = next();
    if (w == 0)
      break;
    ret.push(read_linear_table(w, next));
  }
  while (true) {
    let w = next() - 1;
    if (w < 0)
      break;
    ret.push(read_replacement_table(w, next));
  }
  return ret.flat();
}
function read_array_while(next) {
  let v = [];
  while (true) {
    let x = next(v.length);
    if (!x)
      break;
    v.push(x);
  }
  return v;
}
function read_transposed(n, w, next) {
  let m = Array(n).fill().map(() => []);
  for (let i = 0; i < w; i++) {
    read_deltas(n, next).forEach((x, j) => m[j].push(x));
  }
  return m;
}
function read_linear_table(w, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_array_while(next);
  let m = read_transposed(vN.length, 1 + w, next);
  return m.flatMap((v, i) => {
    let [x, ...ys] = v;
    return Array(vN[i]).fill().map((_, j) => {
      let j_dy = j * dy;
      return [x + j * dx, ys.map((y) => y + j_dy)];
    });
  });
}
function read_replacement_table(w, next) {
  let n = 1 + next();
  let m = read_transposed(n, 1 + w, next);
  return m.map((v) => [v[0], v.slice(1)]);
}
function read_trie(next) {
  let ret = [];
  let sorted = read_sorted(next);
  expand(decode([]), []);
  return ret;
  function decode(Q) {
    let S = next();
    let B = read_array_while(() => {
      let cps = read_sorted(next).map((i) => sorted[i]);
      if (cps.length)
        return decode(cps);
    });
    return { S, B, Q };
  }
  function expand({ S, B }, cps, saved) {
    if (S & 4 && saved === cps[cps.length - 1])
      return;
    if (S & 2)
      saved = cps[cps.length - 1];
    if (S & 1)
      ret.push(cps);
    for (let br of B) {
      for (let cp of br.Q) {
        expand(br, [...cps, cp], saved);
      }
    }
  }
}
function hex_cp(cp) {
  return cp.toString(16).toUpperCase().padStart(2, "0");
}
function quote_cp(cp) {
  return `{${hex_cp(cp)}}`;
}
function explode_cp(s) {
  let cps = [];
  for (let pos = 0, len = s.length; pos < len; ) {
    let cp = s.codePointAt(pos);
    pos += cp < 65536 ? 1 : 2;
    cps.push(cp);
  }
  return cps;
}
function str_from_cps(cps) {
  const chunk = 4096;
  let len = cps.length;
  if (len < chunk)
    return String.fromCodePoint(...cps);
  let buf = [];
  for (let i = 0; i < len; ) {
    buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
  }
  return buf.join("");
}
function compare_arrays(a, b) {
  let n = a.length;
  let c = n - b.length;
  for (let i = 0; c == 0 && i < n; i++)
    c = a[i] - b[i];
  return c;
}
var COMPRESSED = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
var S0 = 44032;
var L0 = 4352;
var V0 = 4449;
var T0 = 4519;
var L_COUNT = 19;
var V_COUNT = 21;
var T_COUNT = 28;
var N_COUNT = V_COUNT * T_COUNT;
var S_COUNT = L_COUNT * N_COUNT;
var S1 = S0 + S_COUNT;
var L1 = L0 + L_COUNT;
var V1 = V0 + V_COUNT;
var T1 = T0 + T_COUNT;
function unpack_cc(packed) {
  return packed >> 24 & 255;
}
function unpack_cp(packed) {
  return packed & 16777215;
}
var SHIFTED_RANK;
var EXCLUSIONS;
var DECOMP;
var RECOMP;
function init$1() {
  let r = read_compressed_payload(COMPRESSED);
  SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map((x) => [x, i + 1 << 24])));
  EXCLUSIONS = new Set(read_sorted(r));
  DECOMP = /* @__PURE__ */ new Map();
  RECOMP = /* @__PURE__ */ new Map();
  for (let [cp, cps] of read_mapped(r)) {
    if (!EXCLUSIONS.has(cp) && cps.length == 2) {
      let [a, b] = cps;
      let bucket = RECOMP.get(a);
      if (!bucket) {
        bucket = /* @__PURE__ */ new Map();
        RECOMP.set(a, bucket);
      }
      bucket.set(b, cp);
    }
    DECOMP.set(cp, cps.reverse());
  }
}
function is_hangul(cp) {
  return cp >= S0 && cp < S1;
}
function compose_pair(a, b) {
  if (a >= L0 && a < L1 && b >= V0 && b < V1) {
    return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;
  } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {
    return a + (b - T0);
  } else {
    let recomp = RECOMP.get(a);
    if (recomp) {
      recomp = recomp.get(b);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
}
function decomposed(cps) {
  if (!SHIFTED_RANK)
    init$1();
  let ret = [];
  let buf = [];
  let check_order = false;
  function add(cp) {
    let cc = SHIFTED_RANK.get(cp);
    if (cc) {
      check_order = true;
      cp |= cc;
    }
    ret.push(cp);
  }
  for (let cp of cps) {
    while (true) {
      if (cp < 128) {
        ret.push(cp);
      } else if (is_hangul(cp)) {
        let s_index = cp - S0;
        let l_index = s_index / N_COUNT | 0;
        let v_index = s_index % N_COUNT / T_COUNT | 0;
        let t_index = s_index % T_COUNT;
        add(L0 + l_index);
        add(V0 + v_index);
        if (t_index > 0)
          add(T0 + t_index);
      } else {
        let mapped = DECOMP.get(cp);
        if (mapped) {
          buf.push(...mapped);
        } else {
          add(cp);
        }
      }
      if (!buf.length)
        break;
      cp = buf.pop();
    }
  }
  if (check_order && ret.length > 1) {
    let prev_cc = unpack_cc(ret[0]);
    for (let i = 1; i < ret.length; i++) {
      let cc = unpack_cc(ret[i]);
      if (cc == 0 || prev_cc <= cc) {
        prev_cc = cc;
        continue;
      }
      let j = i - 1;
      while (true) {
        let tmp = ret[j + 1];
        ret[j + 1] = ret[j];
        ret[j] = tmp;
        if (!j)
          break;
        prev_cc = unpack_cc(ret[--j]);
        if (prev_cc <= cc)
          break;
      }
      prev_cc = unpack_cc(ret[i]);
    }
  }
  return ret;
}
function composed_from_decomposed(v) {
  let ret = [];
  let stack = [];
  let prev_cp = -1;
  let prev_cc = 0;
  for (let packed of v) {
    let cc = unpack_cc(packed);
    let cp = unpack_cp(packed);
    if (prev_cp == -1) {
      if (cc == 0) {
        prev_cp = cp;
      } else {
        ret.push(cp);
      }
    } else if (prev_cc > 0 && prev_cc >= cc) {
      if (cc == 0) {
        ret.push(prev_cp, ...stack);
        stack.length = 0;
        prev_cp = cp;
      } else {
        stack.push(cp);
      }
      prev_cc = cc;
    } else {
      let composed = compose_pair(prev_cp, cp);
      if (composed >= 0) {
        prev_cp = composed;
      } else if (prev_cc == 0 && cc == 0) {
        ret.push(prev_cp);
        prev_cp = cp;
      } else {
        stack.push(cp);
        prev_cc = cc;
      }
    }
  }
  if (prev_cp >= 0) {
    ret.push(prev_cp, ...stack);
  }
  return ret;
}
function nfd(cps) {
  return decomposed(cps).map(unpack_cp);
}
function nfc(cps) {
  return composed_from_decomposed(decomposed(cps));
}
var HYPHEN = 45;
var STOP_CH = ".";
var FE0F = 65039;
var UNIQUE_PH = 1;
var Array_from = (x) => Array.from(x);
function group_has_cp(g, cp) {
  return g.P.has(cp) || g.Q.has(cp);
}
var Emoji = class extends Array {
  get is_emoji() {
    return true;
  }
};
var MAPPED;
var IGNORED;
var CM;
var NSM;
var ESCAPE;
var NFC_CHECK;
var GROUPS;
var WHOLE_VALID;
var WHOLE_MAP;
var VALID;
var EMOJI_LIST;
var EMOJI_ROOT;
function init() {
  if (MAPPED)
    return;
  let r = read_compressed_payload(COMPRESSED$1);
  const read_sorted_array = () => read_sorted(r);
  const read_sorted_set = () => new Set(read_sorted_array());
  MAPPED = new Map(read_mapped(r));
  IGNORED = read_sorted_set();
  CM = read_sorted_array();
  NSM = new Set(read_sorted_array().map((i) => CM[i]));
  CM = new Set(CM);
  ESCAPE = read_sorted_set();
  NFC_CHECK = read_sorted_set();
  let chunks = read_sorted_arrays(r);
  let unrestricted = r();
  const read_chunked = () => new Set(read_sorted_array().flatMap((i) => chunks[i]).concat(read_sorted_array()));
  GROUPS = read_array_while((i) => {
    let N = read_array_while(r).map((x) => x + 96);
    if (N.length) {
      let R = i >= unrestricted;
      N[0] -= 32;
      N = str_from_cps(N);
      if (R)
        N = `Restricted[${N}]`;
      let P = read_chunked();
      let Q = read_chunked();
      let M = !r();
      return { N, P, Q, M, R };
    }
  });
  WHOLE_VALID = read_sorted_set();
  WHOLE_MAP = /* @__PURE__ */ new Map();
  let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b) => a - b);
  wholes.forEach((cp, i) => {
    let d = r();
    let w = wholes[i] = d ? wholes[i - d] : { V: [], M: /* @__PURE__ */ new Map() };
    w.V.push(cp);
    if (!WHOLE_VALID.has(cp)) {
      WHOLE_MAP.set(cp, w);
    }
  });
  for (let { V, M } of new Set(WHOLE_MAP.values())) {
    let recs = [];
    for (let cp of V) {
      let gs = GROUPS.filter((g) => group_has_cp(g, cp));
      let rec = recs.find(({ G }) => gs.some((g) => G.has(g)));
      if (!rec) {
        rec = { G: /* @__PURE__ */ new Set(), V: [] };
        recs.push(rec);
      }
      rec.V.push(cp);
      gs.forEach((g) => rec.G.add(g));
    }
    let union2 = recs.flatMap((x) => Array_from(x.G));
    for (let { G, V: V2 } of recs) {
      let complement = new Set(union2.filter((g) => !G.has(g)));
      for (let cp of V2) {
        M.set(cp, complement);
      }
    }
  }
  let union = /* @__PURE__ */ new Set();
  let multi = /* @__PURE__ */ new Set();
  const add_to_union = (cp) => union.has(cp) ? multi.add(cp) : union.add(cp);
  for (let g of GROUPS) {
    for (let cp of g.P)
      add_to_union(cp);
    for (let cp of g.Q)
      add_to_union(cp);
  }
  for (let cp of union) {
    if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
      WHOLE_MAP.set(cp, UNIQUE_PH);
    }
  }
  VALID = new Set(Array_from(union).concat(Array_from(nfd(union))));
  EMOJI_LIST = read_trie(r).map((v) => Emoji.from(v)).sort(compare_arrays);
  EMOJI_ROOT = /* @__PURE__ */ new Map();
  for (let cps of EMOJI_LIST) {
    let prev = [EMOJI_ROOT];
    for (let cp of cps) {
      let next = prev.map((node) => {
        let child = node.get(cp);
        if (!child) {
          child = /* @__PURE__ */ new Map();
          node.set(cp, child);
        }
        return child;
      });
      if (cp === FE0F) {
        prev.push(...next);
      } else {
        prev = next;
      }
    }
    for (let x of prev) {
      x.V = cps;
    }
  }
}
function quoted_cp(cp) {
  return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
}
function bidi_qq(s) {
  return `"${s}"\u200E`;
}
function check_label_extension(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
    throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
  }
}
function check_leading_underscore(cps) {
  const UNDERSCORE = 95;
  for (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {
    if (cps[--i] !== UNDERSCORE) {
      throw new Error("underscore allowed only at start");
    }
  }
}
function check_fenced(cps) {
  let cp = cps[0];
  let prev = FENCED.get(cp);
  if (prev)
    throw error_placement(`leading ${prev}`);
  let n = cps.length;
  let last = -1;
  for (let i = 1; i < n; i++) {
    cp = cps[i];
    let match = FENCED.get(cp);
    if (match) {
      if (last == i)
        throw error_placement(`${prev} + ${match}`);
      last = i + 1;
      prev = match;
    }
  }
  if (last == n)
    throw error_placement(`trailing ${prev}`);
}
function safe_str_from_cps(cps, quoter = quote_cp) {
  let buf = [];
  if (is_combining_mark(cps[0]))
    buf.push("\u25CC");
  let prev = 0;
  let n = cps.length;
  for (let i = 0; i < n; i++) {
    let cp = cps[i];
    if (should_escape(cp)) {
      buf.push(str_from_cps(cps.slice(prev, i)));
      buf.push(quoter(cp));
      prev = i + 1;
    }
  }
  buf.push(str_from_cps(cps.slice(prev, n)));
  return buf.join("");
}
function is_combining_mark(cp) {
  init();
  return CM.has(cp);
}
function should_escape(cp) {
  init();
  return ESCAPE.has(cp);
}
function ens_normalize(name2) {
  return flatten(split(name2, nfc, filter_fe0f));
}
function split(name2, nf, ef) {
  if (!name2)
    return [];
  init();
  let offset = 0;
  return name2.split(STOP_CH).map((label) => {
    let input = explode_cp(label);
    let info = {
      input,
      offset
    };
    offset += input.length + 1;
    try {
      let tokens = info.tokens = tokens_from_str(input, nf, ef);
      let token_count = tokens.length;
      let type;
      if (!token_count) {
        throw new Error(`empty label`);
      }
      let norm = info.output = tokens.flat();
      check_leading_underscore(norm);
      let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
      if (!emoji && norm.every((cp) => cp < 128)) {
        check_label_extension(norm);
        type = "ASCII";
      } else {
        let chars = tokens.flatMap((x) => x.is_emoji ? [] : x);
        if (!chars.length) {
          type = "Emoji";
        } else {
          if (CM.has(norm[0]))
            throw error_placement("leading combining mark");
          for (let i = 1; i < token_count; i++) {
            let cps = tokens[i];
            if (!cps.is_emoji && CM.has(cps[0])) {
              throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([cps[0]])}"`);
            }
          }
          check_fenced(norm);
          let unique = Array_from(new Set(chars));
          let [g] = determine_group(unique);
          check_group(g, chars);
          check_whole(g, unique);
          type = g.N;
        }
      }
      info.type = type;
    } catch (err) {
      info.error = err;
    }
    return info;
  });
}
function check_whole(group, unique) {
  let maker;
  let shared = [];
  for (let cp of unique) {
    let whole = WHOLE_MAP.get(cp);
    if (whole === UNIQUE_PH)
      return;
    if (whole) {
      let set = whole.M.get(cp);
      maker = maker ? maker.filter((g) => set.has(g)) : Array_from(set);
      if (!maker.length)
        return;
    } else {
      shared.push(cp);
    }
  }
  if (maker) {
    for (let g of maker) {
      if (shared.every((cp) => group_has_cp(g, cp))) {
        throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
      }
    }
  }
}
function determine_group(unique) {
  let groups = GROUPS;
  for (let cp of unique) {
    let gs = groups.filter((g) => group_has_cp(g, cp));
    if (!gs.length) {
      if (!GROUPS.some((g) => group_has_cp(g, cp))) {
        throw error_disallowed(cp);
      } else {
        throw error_group_member(groups[0], cp);
      }
    }
    groups = gs;
    if (gs.length == 1)
      break;
  }
  return groups;
}
function flatten(split2) {
  return split2.map(({ input, error, output }) => {
    if (error) {
      let msg = error.message;
      throw new Error(split2.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input))}: ${msg}`);
    }
    return str_from_cps(output);
  }).join(STOP_CH);
}
function error_disallowed(cp) {
  return new Error(`disallowed character: ${quoted_cp(cp)}`);
}
function error_group_member(g, cp) {
  let quoted = quoted_cp(cp);
  let gg = GROUPS.find((g2) => g2.P.has(cp));
  if (gg) {
    quoted = `${gg.N} ${quoted}`;
  }
  return new Error(`illegal mixture: ${g.N} + ${quoted}`);
}
function error_placement(where) {
  return new Error(`illegal placement: ${where}`);
}
function check_group(g, cps) {
  for (let cp of cps) {
    if (!group_has_cp(g, cp)) {
      throw error_group_member(g, cp);
    }
  }
  if (g.M) {
    let decomposed2 = nfd(cps);
    for (let i = 1, e = decomposed2.length; i < e; i++) {
      if (NSM.has(decomposed2[i])) {
        let j = i + 1;
        for (let cp; j < e && NSM.has(cp = decomposed2[j]); j++) {
          for (let k = i; k < j; k++) {
            if (decomposed2[k] == cp) {
              throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
            }
          }
        }
        if (j - i > NSM_MAX) {
          throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed2.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);
        }
        i = j;
      }
    }
  }
}
function tokens_from_str(input, nf, ef) {
  let ret = [];
  let chars = [];
  input = input.slice().reverse();
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      if (chars.length) {
        ret.push(nf(chars));
        chars = [];
      }
      ret.push(ef(emoji));
    } else {
      let cp = input.pop();
      if (VALID.has(cp)) {
        chars.push(cp);
      } else {
        let cps = MAPPED.get(cp);
        if (cps) {
          chars.push(...cps);
        } else if (!IGNORED.has(cp)) {
          throw error_disallowed(cp);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf(chars));
  }
  return ret;
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != FE0F);
}
function consume_emoji_reversed(cps, eaten) {
  let node = EMOJI_ROOT;
  let emoji;
  let pos = cps.length;
  while (pos) {
    node = node.get(cps[--pos]);
    if (!node)
      break;
    let { V } = node;
    if (V) {
      emoji = V;
      if (eaten)
        eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}

// node_modules/web3-eth-ens/lib/esm/utils.js
var normalize = (name2) => ens_normalize(name2);
var namehash = (inputName) => {
  let node = "";
  for (let i = 0; i < 32; i += 1) {
    node += "00";
  }
  if (inputName) {
    const name2 = normalize(inputName);
    const labels = name2.split(".");
    for (let i = labels.length - 1; i >= 0; i -= 1) {
      const labelSha = sha3Raw7(labels[i]).slice(2);
      node = sha3Raw7(`0x${node}${labelSha}`).slice(2);
    }
  }
  return `0x${node}`;
};

// node_modules/web3-eth-ens/lib/esm/registry.js
var __awaiter77 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Registry = class {
  constructor(context, customRegistryAddress) {
    this.contract = new Contract(ENSRegistryAbi, customRegistryAddress !== null && customRegistryAddress !== void 0 ? customRegistryAddress : registryAddresses.main, context);
    this.context = context;
  }
  getOwner(name2) {
    return __awaiter77(this, void 0, void 0, function* () {
      try {
        const result = this.contract.methods.owner(namehash(name2)).call();
        return result;
      } catch (error) {
        throw new Error();
      }
    });
  }
  getTTL(name2) {
    return __awaiter77(this, void 0, void 0, function* () {
      try {
        return this.contract.methods.ttl(namehash(name2)).call();
      } catch (error) {
        throw new Error();
      }
    });
  }
  recordExists(name2) {
    return __awaiter77(this, void 0, void 0, function* () {
      try {
        const promise = this.contract.methods.recordExists(namehash(name2)).call();
        return promise;
      } catch (error) {
        throw new Error();
      }
    });
  }
  getResolver(name2) {
    return __awaiter77(this, void 0, void 0, function* () {
      try {
        return this.contract.methods.resolver(namehash(name2)).call().then((address) => {
          if (typeof address === "string") {
            const contract = new Contract(PublicResolverAbi, address, this.context);
            return contract;
          }
          throw new Error();
        });
      } catch (error) {
        throw new Error();
      }
    });
  }
  get events() {
    return this.contract.events;
  }
};

// node_modules/web3-eth-ens/lib/esm/resolver.js
init_shim();
var __awaiter78 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Resolver = class {
  constructor(registry) {
    this.registry = registry;
  }
  getResolverContractAdapter(ENSName) {
    return __awaiter78(this, void 0, void 0, function* () {
      return this.registry.getResolver(ENSName);
    });
  }
  checkInterfaceSupport(resolverContract, methodName) {
    var _a16, _b;
    return __awaiter78(this, void 0, void 0, function* () {
      if (isNullish8(interfaceIds[methodName]))
        throw new ResolverMethodMissingError((_a16 = resolverContract.options.address) !== null && _a16 !== void 0 ? _a16 : "", methodName);
      const supported = yield resolverContract.methods.supportsInterface(interfaceIds[methodName]).call();
      if (!supported)
        throw new ResolverMethodMissingError((_b = resolverContract.options.address) !== null && _b !== void 0 ? _b : "", methodName);
    });
  }
  supportsInterface(ENSName, interfaceId) {
    var _a16;
    return __awaiter78(this, void 0, void 0, function* () {
      const resolverContract = yield this.getResolverContractAdapter(ENSName);
      let interfaceIdParam = interfaceId;
      if (!isHexStrict(interfaceIdParam)) {
        interfaceIdParam = (_a16 = sha37(interfaceId)) !== null && _a16 !== void 0 ? _a16 : "";
        if (interfaceId === "")
          throw new Error("Invalid interface Id");
        interfaceIdParam = interfaceIdParam.slice(0, 10);
      }
      return resolverContract.methods.supportsInterface(interfaceIdParam).call();
    });
  }
  getAddress(ENSName, coinType = 60) {
    return __awaiter78(this, void 0, void 0, function* () {
      const resolverContract = yield this.getResolverContractAdapter(ENSName);
      yield this.checkInterfaceSupport(resolverContract, methodsInInterface.addr);
      return resolverContract.methods.addr(namehash(ENSName), coinType).call();
    });
  }
  getPubkey(ENSName) {
    return __awaiter78(this, void 0, void 0, function* () {
      const resolverContract = yield this.getResolverContractAdapter(ENSName);
      yield this.checkInterfaceSupport(resolverContract, methodsInInterface.pubkey);
      return resolverContract.methods.pubkey(namehash(ENSName)).call();
    });
  }
  getContenthash(ENSName) {
    return __awaiter78(this, void 0, void 0, function* () {
      const resolverContract = yield this.getResolverContractAdapter(ENSName);
      yield this.checkInterfaceSupport(resolverContract, methodsInInterface.contenthash);
      return resolverContract.methods.contenthash(namehash(ENSName)).call();
    });
  }
};

// node_modules/web3-eth-ens/lib/esm/ens.js
var __awaiter79 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ENS = class extends Web3Context5 {
  constructor(registryAddr, provider) {
    super(provider !== null && provider !== void 0 ? provider : "");
    this.registryAddress = registryAddr !== null && registryAddr !== void 0 ? registryAddr : registryAddresses.main;
    this._registry = new Registry(this.getContextObject(), registryAddr);
    this._resolver = new Resolver(this._registry);
  }
  getResolver(name2) {
    return __awaiter79(this, void 0, void 0, function* () {
      return this._registry.getResolver(name2);
    });
  }
  recordExists(name2) {
    return __awaiter79(this, void 0, void 0, function* () {
      return this._registry.recordExists(name2);
    });
  }
  getTTL(name2) {
    return __awaiter79(this, void 0, void 0, function* () {
      return this._registry.getTTL(name2);
    });
  }
  getOwner(name2) {
    return __awaiter79(this, void 0, void 0, function* () {
      return this._registry.getOwner(name2);
    });
  }
  getAddress(ENSName, coinType = 60) {
    return __awaiter79(this, void 0, void 0, function* () {
      return this._resolver.getAddress(ENSName, coinType);
    });
  }
  getPubkey(ENSName) {
    return __awaiter79(this, void 0, void 0, function* () {
      return this._resolver.getPubkey(ENSName);
    });
  }
  getContenthash(ENSName) {
    return __awaiter79(this, void 0, void 0, function* () {
      return this._resolver.getContenthash(ENSName);
    });
  }
  checkNetwork() {
    return __awaiter79(this, void 0, void 0, function* () {
      const now = Date.now() / 1e3;
      if (!this._lastSyncCheck || now - this._lastSyncCheck > 3600) {
        const syncInfo = yield isSyncing(this);
        if (!(typeof syncInfo === "boolean" && !syncInfo)) {
          throw new ENSNetworkNotSyncedError();
        }
        this._lastSyncCheck = now;
      }
      if (this._detectedAddress) {
        return this._detectedAddress;
      }
      const networkType = yield getId2(this, Object.assign(Object.assign({}, DEFAULT_RETURN_FORMAT), { number: FMT_NUMBER.HEX }));
      const addr = registryAddresses[networkIds[networkType]];
      if (typeof addr === "undefined") {
        throw new ENSUnsupportedNetworkError(networkType);
      }
      this._detectedAddress = addr;
      return this._detectedAddress;
    });
  }
  supportsInterface(ENSName, interfaceId) {
    return __awaiter79(this, void 0, void 0, function* () {
      return this._resolver.supportsInterface(ENSName, interfaceId);
    });
  }
  get events() {
    return this._registry.events;
  }
};

// node_modules/web3-eth-personal/lib/esm/index.js
var esm_exports15 = {};
__export(esm_exports15, {
  Personal: () => Personal,
  default: () => esm_default4
});
init_shim();

// node_modules/web3-eth-personal/lib/esm/personal.js
init_shim();

// node_modules/web3-eth-personal/node_modules/web3-core/lib/esm/index.js
init_shim();

// node_modules/web3-eth-personal/node_modules/web3-core/lib/esm/web3_config.js
init_shim();

// node_modules/web3-eth-personal/node_modules/web3-utils/lib/esm/index.js
init_shim();

// node_modules/web3-eth-personal/node_modules/web3-utils/lib/esm/converters.js
init_shim();

// node_modules/web3-eth-personal/node_modules/ethereum-cryptography/esm/keccak.js
init_shim();
init_sha3();

// node_modules/web3-eth-personal/node_modules/ethereum-cryptography/esm/utils.js
init_shim();
init_assert();
init_utils();
init_utils();
var assertBool9 = assert_default.bool;
var assertBytes9 = assert_default.bytes;
function bytesToUtf88(data) {
  if (!(data instanceof Uint8Array)) {
    throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
  }
  return new TextDecoder().decode(data);
}
function wrapHash9(hash) {
  return (msg) => {
    assert_default.bytes(msg);
    return hash(msg);
  };
}
var crypto11 = (() => {
  const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
  return {
    node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
    web: webCrypto
  };
})();

// node_modules/web3-eth-personal/node_modules/ethereum-cryptography/esm/keccak.js
var keccak2249 = wrapHash9(keccak_224);
var keccak2569 = (() => {
  const k = wrapHash9(keccak_256);
  k.create = keccak_256.create;
  return k;
})();
var keccak3849 = wrapHash9(keccak_384);
var keccak5129 = wrapHash9(keccak_512);

// node_modules/web3-eth-personal/node_modules/web3-utils/lib/esm/converters.js
var ethUnitMap8 = {
  noether: BigInt(0),
  wei: BigInt(1),
  kwei: BigInt(1e3),
  Kwei: BigInt(1e3),
  babbage: BigInt(1e3),
  femtoether: BigInt(1e3),
  mwei: BigInt(1e6),
  Mwei: BigInt(1e6),
  lovelace: BigInt(1e6),
  picoether: BigInt(1e6),
  gwei: BigInt(1e9),
  Gwei: BigInt(1e9),
  shannon: BigInt(1e9),
  nanoether: BigInt(1e9),
  nano: BigInt(1e9),
  szabo: BigInt(1e12),
  microether: BigInt(1e12),
  micro: BigInt(1e12),
  finney: BigInt(1e15),
  milliether: BigInt(1e15),
  milli: BigInt(1e15),
  ether: BigInt("1000000000000000000"),
  kether: BigInt("1000000000000000000000"),
  grand: BigInt("1000000000000000000000"),
  mether: BigInt("1000000000000000000000000"),
  gether: BigInt("1000000000000000000000000000"),
  tether: BigInt("1000000000000000000000000000000")
};
var bytesToUint8Array8 = (data) => {
  validator.validate(["bytes"], [data]);
  if (data instanceof Uint8Array) {
    return data;
  }
  if (Array.isArray(data)) {
    return new Uint8Array(data);
  }
  if (typeof data === "string") {
    return utils_exports.hexToUint8Array(data);
  }
  throw new InvalidBytesError(data);
};
var { uint8ArrayToHexString: uint8ArrayToHexString9 } = utils_exports;
var bytesToHex9 = (bytes) => uint8ArrayToHexString9(bytesToUint8Array8(bytes));
var hexToBytes9 = (bytes) => {
  if (typeof bytes === "string" && bytes.slice(0, 2).toLowerCase() !== "0x") {
    return bytesToUint8Array8(`0x${bytes}`);
  }
  return bytesToUint8Array8(bytes);
};
var hexToNumber8 = (value) => {
  validator.validate(["hex"], [value]);
  return utils_exports.hexToNumber(value);
};
var numberToHex9 = (value, hexstrict) => {
  if (typeof value !== "bigint")
    validator.validate(["int"], [value]);
  let updatedValue = utils_exports.numberToHex(value);
  if (hexstrict) {
    if (!updatedValue.startsWith("-") && updatedValue.length % 2 === 1) {
      updatedValue = "0x0".concat(updatedValue.slice(2));
    } else if (updatedValue.length % 2 === 0 && updatedValue.startsWith("-"))
      updatedValue = "-0x0".concat(updatedValue.slice(3));
  }
  return updatedValue;
};
var hexToNumberString6 = (data) => hexToNumber8(data).toString();
var utf8ToHex8 = (str) => {
  validator.validate(["string"], [str]);
  let strWithoutNullCharacter = str.replace(/^(?:\u0000)/, "");
  strWithoutNullCharacter = strWithoutNullCharacter.replace(/(?:\u0000)$/, "");
  return bytesToHex9(new TextEncoder().encode(strWithoutNullCharacter));
};
var fromUtf87 = utf8ToHex8;
var hexToUtf87 = (str) => bytesToUtf88(hexToBytes9(str));
var toUtf86 = (input) => {
  if (typeof input === "string") {
    return hexToUtf87(input);
  }
  validator.validate(["bytes"], [input]);
  return bytesToUtf88(input);
};
var utf8ToBytes9 = utf8ToBytes;
var toHex8 = (value, returnType) => {
  if (typeof value === "string" && isAddress(value)) {
    return returnType ? "address" : `0x${value.toLowerCase().replace(/^0x/i, "")}`;
  }
  if (typeof value === "boolean") {
    return returnType ? "bool" : value ? "0x01" : "0x00";
  }
  if (typeof value === "number") {
    return returnType ? value < 0 ? "int256" : "uint256" : numberToHex9(value);
  }
  if (typeof value === "bigint") {
    return returnType ? "bigint" : numberToHex9(value);
  }
  if (typeof value === "object" && !!value) {
    return returnType ? "string" : utf8ToHex8(JSON.stringify(value));
  }
  if (typeof value === "string") {
    if (value.startsWith("-0x") || value.startsWith("-0X")) {
      return returnType ? "int256" : numberToHex9(value);
    }
    if (isHexStrict(value)) {
      return returnType ? "bytes" : value;
    }
    if (isHex(value) && !isInt(value)) {
      return returnType ? "bytes" : `0x${value}`;
    }
    if (!Number.isFinite(value)) {
      return returnType ? "string" : utf8ToHex8(value);
    }
  }
  throw new HexProcessingError(value);
};
var toNumber8 = (value) => {
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "bigint") {
    return value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER ? Number(value) : value;
  }
  if (typeof value === "string" && isHexStrict(value)) {
    return hexToNumber8(value);
  }
  try {
    return toNumber8(BigInt(value));
  } catch (_a16) {
    throw new InvalidNumberError(value);
  }
};
var toChecksumAddress8 = (address) => {
  if (!isAddress(address, false)) {
    throw new InvalidAddressError(address);
  }
  const lowerCaseAddress = address.toLowerCase().replace(/^0x/i, "");
  const hash = utils_exports.uint8ArrayToHexString(keccak2569(utf8ToBytes9(lowerCaseAddress)));
  if (isNullish(hash) || hash === "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470")
    return "";
  let checksumAddress = "0x";
  const addressHash = hash.replace(/^0x/i, "");
  for (let i = 0; i < lowerCaseAddress.length; i += 1) {
    if (parseInt(addressHash[i], 16) > 7) {
      checksumAddress += lowerCaseAddress[i].toUpperCase();
    } else {
      checksumAddress += lowerCaseAddress[i];
    }
  }
  return checksumAddress;
};

// node_modules/web3-eth-personal/node_modules/web3-utils/lib/esm/event_emitter.js
init_shim();
var import_events15 = __toESM(require_events(), 1);
var __awaiter80 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var wrapFunction8 = (fn) => (params) => fn(params.detail);
var EventEmitterAtBrowser8 = class extends EventTarget {
  constructor() {
    super(...arguments);
    this._listeners = {};
    this.maxListeners = Number.MAX_SAFE_INTEGER;
  }
  on(eventName, fn) {
    this.addEventListener(eventName, fn);
    return this;
  }
  once(eventName, fn) {
    const onceCallback = (params) => __awaiter80(this, void 0, void 0, function* () {
      this.off(eventName, onceCallback);
      yield fn(params);
    });
    return this.on(eventName, onceCallback);
  }
  off(eventName, fn) {
    this.removeEventListener(eventName, fn);
    return this;
  }
  emit(eventName, params) {
    const event = new CustomEvent(eventName, { detail: params });
    return super.dispatchEvent(event);
  }
  listenerCount(eventName) {
    const eventListeners = this._listeners[eventName];
    return eventListeners ? eventListeners.length : 0;
  }
  listeners(eventName) {
    return this._listeners[eventName].map((value) => value[0]) || [];
  }
  eventNames() {
    return Object.keys(this._listeners);
  }
  removeAllListeners() {
    Object.keys(this._listeners).forEach((event) => {
      this._listeners[event].forEach((listener) => {
        super.removeEventListener(event, listener[1]);
      });
    });
    this._listeners = {};
    return this;
  }
  setMaxListeners(maxListeners) {
    this.maxListeners = maxListeners;
    return this;
  }
  getMaxListeners() {
    return this.maxListeners;
  }
  addEventListener(eventName, fn) {
    const wrappedFn = wrapFunction8(fn);
    super.addEventListener(eventName, wrappedFn);
    if (!this._listeners[eventName]) {
      this._listeners[eventName] = [];
    }
    this._listeners[eventName].push([fn, wrappedFn]);
  }
  removeEventListener(eventName, fn) {
    const eventListeners = this._listeners[eventName];
    if (eventListeners) {
      const index = eventListeners.findIndex((item) => item[0] === fn);
      if (index !== -1) {
        super.removeEventListener(eventName, eventListeners[index][1]);
        eventListeners.splice(index, 1);
      }
    }
  }
};
var EventEmitterType8;
if (typeof window === "undefined") {
  EventEmitterType8 = import_events15.EventEmitter;
} else {
  EventEmitterType8 = EventEmitterAtBrowser8;
}
var EventEmitter14 = class extends EventEmitterType8 {
};

// node_modules/web3-eth-personal/node_modules/web3-utils/lib/esm/validation.js
init_shim();
var isHexStrict7 = isHexStrict;
var isAddress7 = isAddress;
var isNullish9 = isNullish;

// node_modules/web3-eth-personal/node_modules/web3-utils/lib/esm/formatter.js
init_shim();

// node_modules/web3-eth-personal/node_modules/web3-utils/lib/esm/objects.js
init_shim();
var isIterable6 = (item) => typeof item === "object" && !isNullish(item) && !Array.isArray(item) && !(item instanceof TypedArray);
var mergeDeep8 = (destination, ...sources) => {
  const result = destination;
  if (!isIterable6(result)) {
    return result;
  }
  for (const src of sources) {
    for (const key in src) {
      if (isIterable6(src[key])) {
        if (!result[key]) {
          result[key] = {};
        }
        mergeDeep8(result[key], src[key]);
      } else if (!isNullish(src[key]) && Object.hasOwnProperty.call(src, key)) {
        if (Array.isArray(src[key]) || src[key] instanceof TypedArray) {
          result[key] = src[key].slice(0);
        } else {
          result[key] = src[key];
        }
      }
    }
  }
  return result;
};

// node_modules/web3-eth-personal/node_modules/web3-utils/lib/esm/string_manipulation.js
init_shim();
var padLeft9 = (value, characterAmount, sign6 = "0") => {
  if (typeof value === "string") {
    if (!isHexStrict(value)) {
      return value.padStart(characterAmount, sign6);
    }
    return utils_exports.padLeft(value, characterAmount, sign6);
  }
  validator.validate(["int"], [value]);
  return utils_exports.padLeft(value, characterAmount, sign6);
};
var leftPad8 = padLeft9;

// node_modules/web3-eth-personal/node_modules/web3-utils/lib/esm/uint8array.js
init_shim();

// node_modules/web3-eth-personal/node_modules/web3-utils/lib/esm/formatter.js
var { parseBaseType: parseBaseType9 } = utils_exports;

// node_modules/web3-eth-personal/node_modules/web3-utils/lib/esm/hash.js
init_shim();
var SHA3_EMPTY_BYTES8 = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
var sha38 = (data) => {
  let updatedData;
  if (typeof data === "string") {
    if (data.startsWith("0x") && isHexStrict(data)) {
      updatedData = hexToBytes9(data);
    } else {
      updatedData = utf8ToBytes(data);
    }
  } else {
    updatedData = data;
  }
  const hash = bytesToHex9(keccak2569(updatedData));
  return hash === SHA3_EMPTY_BYTES8 ? void 0 : hash;
};
var sha3Raw8 = (data) => {
  const hash = sha38(data);
  if (isNullish(hash)) {
    return SHA3_EMPTY_BYTES8;
  }
  return hash;
};

// node_modules/web3-eth-personal/node_modules/web3-utils/lib/esm/random.js
init_shim();

// node_modules/web3-eth-personal/node_modules/ethereum-cryptography/esm/random.js
init_shim();
init_utils();
function getRandomBytesSync8(bytes) {
  return randomBytes(bytes);
}

// node_modules/web3-eth-personal/node_modules/web3-utils/lib/esm/random.js
var randomBytes9 = (size) => getRandomBytesSync8(size);

// node_modules/web3-eth-personal/node_modules/web3-utils/lib/esm/promise_helpers.js
init_shim();
function isPromise6(object) {
  return (typeof object === "object" || typeof object === "function") && typeof object.then === "function";
}

// node_modules/web3-eth-personal/node_modules/web3-utils/lib/esm/json_rpc.js
var json_rpc_exports8 = {};
__export(json_rpc_exports8, {
  isBatchRequest: () => isBatchRequest8,
  isBatchResponse: () => isBatchResponse8,
  isResponseRpcError: () => isResponseRpcError8,
  isResponseWithError: () => isResponseWithError9,
  isResponseWithNotification: () => isResponseWithNotification8,
  isResponseWithResult: () => isResponseWithResult8,
  isSubscriptionResult: () => isSubscriptionResult8,
  isValidResponse: () => isValidResponse8,
  setRequestIdStart: () => setRequestIdStart8,
  toBatchPayload: () => toBatchPayload8,
  toPayload: () => toPayload8,
  validateResponse: () => validateResponse8
});
init_shim();

// node_modules/web3-eth-personal/node_modules/web3-utils/lib/esm/uuid.js
init_shim();
var uuidV48 = () => {
  const bytes = randomBytes9(16);
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 63 | 128;
  const hexString = bytesToHex9(bytes);
  return [
    hexString.substring(2, 10),
    hexString.substring(10, 14),
    hexString.substring(14, 18),
    hexString.substring(18, 22),
    hexString.substring(22, 34)
  ].join("-");
};

// node_modules/web3-eth-personal/node_modules/web3-utils/lib/esm/json_rpc.js
var isResponseRpcError8 = (rpcError) => {
  const errorCode = rpcError.error.code;
  return rpcErrorsMap.has(errorCode) || errorCode >= -32099 && errorCode <= -32e3;
};
var isResponseWithResult8 = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && "result" in response && isNullish(response.error) && (typeof response.id === "number" || typeof response.id === "string");
var isResponseWithError9 = (response) => !Array.isArray(response) && response.jsonrpc === "2.0" && !!response && isNullish(response.result) && "error" in response && (typeof response.id === "number" || typeof response.id === "string");
var isResponseWithNotification8 = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && !isNullish(response.params) && !isNullish(response.method);
var isSubscriptionResult8 = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && "id" in response && "result" in response;
var validateResponse8 = (response) => isResponseWithResult8(response) || isResponseWithError9(response);
var isValidResponse8 = (response) => Array.isArray(response) ? response.every(validateResponse8) : validateResponse8(response);
var isBatchResponse8 = (response) => Array.isArray(response) && response.length > 0 && isValidResponse8(response);
var requestIdSeed8;
var setRequestIdStart8 = (start) => {
  requestIdSeed8 = start;
};
var toPayload8 = (request) => {
  var _a16, _b, _c, _d;
  if (typeof requestIdSeed8 !== "undefined") {
    requestIdSeed8 += 1;
  }
  return {
    jsonrpc: (_a16 = request.jsonrpc) !== null && _a16 !== void 0 ? _a16 : "2.0",
    id: (_c = (_b = request.id) !== null && _b !== void 0 ? _b : requestIdSeed8) !== null && _c !== void 0 ? _c : uuidV48(),
    method: request.method,
    params: (_d = request.params) !== null && _d !== void 0 ? _d : void 0
  };
};
var toBatchPayload8 = (requests) => requests.map((request) => toPayload8(request));
var isBatchRequest8 = (request) => Array.isArray(request) && request.length > 0;

// node_modules/web3-eth-personal/node_modules/web3-utils/lib/esm/web3_deferred_promise.js
init_shim();
var __awaiter81 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a14;
var Web3DeferredPromise8 = class {
  constructor({ timeout, eagerStart, timeoutMessage } = {
    timeout: 0,
    eagerStart: false,
    timeoutMessage: "DeferredPromise timed out"
  }) {
    this[_a14] = "Promise";
    this._state = "pending";
    this._promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
    this._timeoutMessage = timeoutMessage;
    this._timeoutInterval = timeout;
    if (eagerStart) {
      this.startTimer();
    }
  }
  get state() {
    return this._state;
  }
  then(onfulfilled, onrejected) {
    return __awaiter81(this, void 0, void 0, function* () {
      return this._promise.then(onfulfilled, onrejected);
    });
  }
  catch(onrejected) {
    return __awaiter81(this, void 0, void 0, function* () {
      return this._promise.catch(onrejected);
    });
  }
  finally(onfinally) {
    return __awaiter81(this, void 0, void 0, function* () {
      return this._promise.finally(onfinally);
    });
  }
  resolve(value) {
    this._resolve(value);
    this._state = "fulfilled";
    this._clearTimeout();
  }
  reject(reason) {
    this._reject(reason);
    this._state = "rejected";
    this._clearTimeout();
  }
  startTimer() {
    if (this._timeoutInterval && this._timeoutInterval > 0) {
      this._timeoutId = setTimeout(this._checkTimeout.bind(this), this._timeoutInterval);
    }
  }
  _checkTimeout() {
    if (this._state === "pending" && this._timeoutId) {
      this.reject(new OperationTimeoutError(this._timeoutMessage));
    }
  }
  _clearTimeout() {
    if (this._timeoutId) {
      clearTimeout(this._timeoutId);
    }
  }
};
_a14 = Symbol.toStringTag;

// node_modules/web3-eth-personal/node_modules/web3-utils/lib/esm/chunk_response_parser.js
init_shim();
var ChunkResponseParser8 = class {
  constructor(eventEmitter, autoReconnect) {
    this.eventEmitter = eventEmitter;
    this.autoReconnect = autoReconnect;
  }
  clearQueues() {
    if (typeof this._clearQueues === "function") {
      this._clearQueues();
    }
  }
  onError(clearQueues) {
    this._clearQueues = clearQueues;
  }
  parseResponse(data) {
    const returnValues = [];
    const dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
    dechunkedData.forEach((_chunkData) => {
      let chunkData = _chunkData;
      if (this.lastChunk) {
        chunkData = this.lastChunk + chunkData;
      }
      let result;
      try {
        result = JSON.parse(chunkData);
      } catch (e) {
        this.lastChunk = chunkData;
        if (this.lastChunkTimeout) {
          clearTimeout(this.lastChunkTimeout);
        }
        this.lastChunkTimeout = setTimeout(() => {
          if (this.autoReconnect)
            return;
          this.clearQueues();
          this.eventEmitter.emit("error", new InvalidResponseError({
            id: 1,
            jsonrpc: "2.0",
            error: { code: 2, message: "Chunk timeout" }
          }));
        }, 1e3 * 15);
        return;
      }
      clearTimeout(this.lastChunkTimeout);
      this.lastChunk = void 0;
      if (result)
        returnValues.push(result);
    });
    return returnValues;
  }
};

// node_modules/web3-eth-personal/node_modules/web3-utils/lib/esm/web3_eip1193_provider.js
init_shim();
var import_events16 = __toESM(require_events(), 1);
var __awaiter82 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Eip1193Provider8 = class extends Web3BaseProvider {
  constructor() {
    super(...arguments);
    this._eventEmitter = new import_events16.EventEmitter();
    this._chainId = "";
    this._accounts = [];
  }
  _getChainId() {
    var _a16;
    return __awaiter82(this, void 0, void 0, function* () {
      const data = yield this.request(toPayload8({
        method: "eth_chainId",
        params: []
      }));
      return (_a16 = data === null || data === void 0 ? void 0 : data.result) !== null && _a16 !== void 0 ? _a16 : "";
    });
  }
  _getAccounts() {
    var _a16;
    return __awaiter82(this, void 0, void 0, function* () {
      const data = yield this.request(toPayload8({
        method: "eth_accounts",
        params: []
      }));
      return (_a16 = data === null || data === void 0 ? void 0 : data.result) !== null && _a16 !== void 0 ? _a16 : [];
    });
  }
  _onConnect() {
    Promise.all([
      this._getChainId().then((chainId) => {
        if (chainId !== this._chainId) {
          this._chainId = chainId;
          this._eventEmitter.emit("chainChanged", this._chainId);
        }
      }).catch((err) => {
        console.error(err);
      }),
      this._getAccounts().then((accounts) => {
        if (!(this._accounts.length === accounts.length && accounts.every((v) => accounts.includes(v)))) {
          this._accounts = accounts;
          this._onAccountsChanged();
        }
      }).catch((err) => {
        console.error(err);
      })
    ]).then(() => this._eventEmitter.emit("connect", {
      chainId: this._chainId
    })).catch((err) => {
      console.error(err);
    });
  }
  _onDisconnect(code, data) {
    this._eventEmitter.emit("disconnect", new EIP1193ProviderRpcError(code, data));
  }
  _onAccountsChanged() {
    this._eventEmitter.emit("accountsChanged", this._accounts);
  }
};

// node_modules/web3-eth-personal/node_modules/web3-utils/lib/esm/socket_provider.js
init_shim();
var __awaiter83 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_RECONNECTION_OPTIONS6 = {
  autoReconnect: true,
  delay: 5e3,
  maxAttempts: 5
};
var NORMAL_CLOSE_CODE6 = 1e3;
var SocketProvider6 = class extends Eip1193Provider8 {
  constructor(socketPath, socketOptions, reconnectOptions) {
    super();
    this._connectionStatus = "connecting";
    this._onMessageHandler = this._onMessage.bind(this);
    this._onOpenHandler = this._onConnect.bind(this);
    this._onCloseHandler = this._onCloseEvent.bind(this);
    this._onErrorHandler = this._onError.bind(this);
    if (!this._validateProviderPath(socketPath))
      throw new InvalidClientError(socketPath);
    this._socketPath = socketPath;
    this._socketOptions = socketOptions;
    this._reconnectOptions = Object.assign(Object.assign({}, DEFAULT_RECONNECTION_OPTIONS6), reconnectOptions !== null && reconnectOptions !== void 0 ? reconnectOptions : {});
    this._pendingRequestsQueue = /* @__PURE__ */ new Map();
    this._sentRequestsQueue = /* @__PURE__ */ new Map();
    this._init();
    this.connect();
    this.chunkResponseParser = new ChunkResponseParser8(this._eventEmitter, this._reconnectOptions.autoReconnect);
    this.chunkResponseParser.onError(() => {
      this._clearQueues();
    });
    this.isReconnecting = false;
  }
  get SocketConnection() {
    return this._socketConnection;
  }
  _init() {
    this._reconnectAttempts = 0;
  }
  connect() {
    try {
      this._openSocketConnection();
      this._connectionStatus = "connecting";
      this._addSocketListeners();
    } catch (e) {
      if (!this.isReconnecting) {
        this._connectionStatus = "disconnected";
        if (e && e.message) {
          throw new ConnectionError(`Error while connecting to ${this._socketPath}. Reason: ${e.message}`);
        } else {
          throw new InvalidClientError(this._socketPath);
        }
      } else {
        setImmediate(() => {
          this._reconnect();
        });
      }
    }
  }
  _validateProviderPath(path) {
    return !!path;
  }
  supportsSubscriptions() {
    return true;
  }
  on(type, listener) {
    this._eventEmitter.on(type, listener);
  }
  once(type, listener) {
    this._eventEmitter.once(type, listener);
  }
  removeListener(type, listener) {
    this._eventEmitter.removeListener(type, listener);
  }
  _onDisconnect(code, data) {
    this._connectionStatus = "disconnected";
    super._onDisconnect(code, data);
  }
  disconnect(code, data) {
    const disconnectCode = code !== null && code !== void 0 ? code : NORMAL_CLOSE_CODE6;
    this._removeSocketListeners();
    if (this.getStatus() !== "disconnected") {
      this._closeSocketConnection(disconnectCode, data);
    }
    this._onDisconnect(disconnectCode, data);
  }
  removeAllListeners(type) {
    this._eventEmitter.removeAllListeners(type);
  }
  _onError(event) {
    if (this.isReconnecting) {
      this._reconnect();
    } else {
      this._eventEmitter.emit("error", event);
    }
  }
  reset() {
    this._sentRequestsQueue.clear();
    this._pendingRequestsQueue.clear();
    this._init();
    this._removeSocketListeners();
    this._addSocketListeners();
  }
  _reconnect() {
    if (this.isReconnecting) {
      return;
    }
    this.isReconnecting = true;
    if (this._sentRequestsQueue.size > 0) {
      this._sentRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new PendingRequestsOnReconnectingError());
        this._sentRequestsQueue.delete(key);
      });
    }
    if (this._reconnectAttempts < this._reconnectOptions.maxAttempts) {
      this._reconnectAttempts += 1;
      setTimeout(() => {
        this._removeSocketListeners();
        this.connect();
        this.isReconnecting = false;
      }, this._reconnectOptions.delay);
    } else {
      this.isReconnecting = false;
      this._clearQueues();
      this._removeSocketListeners();
      this._eventEmitter.emit("error", new MaxAttemptsReachedOnReconnectingError(this._reconnectOptions.maxAttempts));
    }
  }
  request(request) {
    return __awaiter83(this, void 0, void 0, function* () {
      if (isNullish9(this._socketConnection)) {
        throw new Error("Connection is undefined");
      }
      if (this.getStatus() === "disconnected") {
        this.connect();
      }
      const requestId = isBatchRequest8(request) ? request[0].id : request.id;
      if (!requestId) {
        throw new Web3WSProviderError("Request Id not defined");
      }
      if (this._sentRequestsQueue.has(requestId)) {
        throw new RequestAlreadySentError(requestId);
      }
      const deferredPromise = new Web3DeferredPromise8();
      deferredPromise.catch((error) => {
        this._eventEmitter.emit("error", error);
      });
      const reqItem = {
        payload: request,
        deferredPromise
      };
      if (this.getStatus() === "connecting") {
        this._pendingRequestsQueue.set(requestId, reqItem);
        return reqItem.deferredPromise;
      }
      this._sentRequestsQueue.set(requestId, reqItem);
      try {
        this._sendToSocket(reqItem.payload);
      } catch (error) {
        this._sentRequestsQueue.delete(requestId);
        this._eventEmitter.emit("error", error);
      }
      return deferredPromise;
    });
  }
  _onConnect() {
    this._connectionStatus = "connected";
    this._reconnectAttempts = 0;
    super._onConnect();
    this._sendPendingRequests();
  }
  _sendPendingRequests() {
    for (const [id, value] of this._pendingRequestsQueue.entries()) {
      this._sendToSocket(value.payload);
      this._pendingRequestsQueue.delete(id);
      this._sentRequestsQueue.set(id, value);
    }
  }
  _onMessage(event) {
    const responses = this._parseResponses(event);
    if (isNullish9(responses) || responses.length === 0) {
      return;
    }
    for (const response of responses) {
      if (isResponseWithNotification8(response) && response.method.endsWith("_subscription")) {
        this._eventEmitter.emit("message", response);
        return;
      }
      const requestId = isBatchResponse8(response) ? response[0].id : response.id;
      const requestItem = this._sentRequestsQueue.get(requestId);
      if (!requestItem) {
        return;
      }
      if (isBatchResponse8(response) || isResponseWithResult8(response) || isResponseWithError9(response)) {
        this._eventEmitter.emit("message", response);
        requestItem.deferredPromise.resolve(response);
      }
      this._sentRequestsQueue.delete(requestId);
    }
  }
  _clearQueues(event) {
    if (this._pendingRequestsQueue.size > 0) {
      this._pendingRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new ConnectionNotOpenError(event));
        this._pendingRequestsQueue.delete(key);
      });
    }
    if (this._sentRequestsQueue.size > 0) {
      this._sentRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new ConnectionNotOpenError(event));
        this._sentRequestsQueue.delete(key);
      });
    }
    this._removeSocketListeners();
  }
};

// node_modules/web3-eth-personal/node_modules/web3-core/lib/esm/web3_event_emitter.js
init_shim();
var Web3EventEmitter6 = class {
  constructor() {
    this._emitter = new EventEmitter14();
  }
  on(eventName, fn) {
    this._emitter.on(eventName, fn);
  }
  once(eventName, fn) {
    this._emitter.once(eventName, fn);
  }
  off(eventName, fn) {
    this._emitter.off(eventName, fn);
  }
  emit(eventName, params) {
    this._emitter.emit(eventName, params);
  }
  listenerCount(eventName) {
    return this._emitter.listenerCount(eventName);
  }
  listeners(eventName) {
    return this._emitter.listeners(eventName);
  }
  eventNames() {
    return this._emitter.eventNames();
  }
  removeAllListeners() {
    return this._emitter.removeAllListeners();
  }
  setMaxListenerWarningThreshold(maxListenersWarningThreshold) {
    this._emitter.setMaxListeners(maxListenersWarningThreshold);
  }
  getMaxListeners() {
    return this._emitter.getMaxListeners();
  }
};

// node_modules/web3-eth-personal/node_modules/web3-core/lib/esm/web3_config.js
var Web3ConfigEvent6;
(function(Web3ConfigEvent7) {
  Web3ConfigEvent7["CONFIG_CHANGE"] = "CONFIG_CHANGE";
})(Web3ConfigEvent6 || (Web3ConfigEvent6 = {}));
var Web3Config6 = class extends Web3EventEmitter6 {
  constructor(options) {
    super();
    this.config = {
      handleRevert: false,
      defaultAccount: void 0,
      defaultBlock: "latest",
      transactionBlockTimeout: 50,
      transactionConfirmationBlocks: 24,
      transactionPollingInterval: 1e3,
      transactionPollingTimeout: 750 * 1e3,
      transactionReceiptPollingInterval: void 0,
      transactionSendTimeout: 750 * 1e3,
      transactionConfirmationPollingInterval: void 0,
      blockHeaderTimeout: 10,
      maxListenersWarningThreshold: 100,
      contractDataInputFill: "input",
      defaultNetworkId: void 0,
      defaultChain: "mainnet",
      defaultHardfork: "london",
      defaultCommon: void 0,
      defaultTransactionType: "0x2",
      defaultMaxPriorityFeePerGas: toHex8(25e8),
      enableExperimentalFeatures: {
        useSubscriptionWhenCheckingBlockTimeout: false,
        useRpcCallSpecification: false
      },
      transactionBuilder: void 0,
      transactionTypeParser: void 0
    };
    this.setConfig(options !== null && options !== void 0 ? options : {});
  }
  setConfig(options) {
    Object.assign(this.config, options);
  }
  get handleRevert() {
    return this.config.handleRevert;
  }
  set handleRevert(val) {
    this._triggerConfigChange("handleRevert", val);
    this.config.handleRevert = val;
  }
  get contractDataInputFill() {
    return this.config.contractDataInputFill;
  }
  set contractDataInputFill(val) {
    this._triggerConfigChange("contractDataInputFill", val);
    this.config.contractDataInputFill = val;
  }
  get defaultAccount() {
    return this.config.defaultAccount;
  }
  set defaultAccount(val) {
    this._triggerConfigChange("defaultAccount", val);
    this.config.defaultAccount = val;
  }
  get defaultBlock() {
    return this.config.defaultBlock;
  }
  set defaultBlock(val) {
    this._triggerConfigChange("defaultBlock", val);
    this.config.defaultBlock = val;
  }
  get transactionSendTimeout() {
    return this.config.transactionSendTimeout;
  }
  set transactionSendTimeout(val) {
    this._triggerConfigChange("transactionSendTimeout", val);
    this.config.transactionSendTimeout = val;
  }
  get transactionBlockTimeout() {
    return this.config.transactionBlockTimeout;
  }
  set transactionBlockTimeout(val) {
    this._triggerConfigChange("transactionBlockTimeout", val);
    this.config.transactionBlockTimeout = val;
  }
  get transactionConfirmationBlocks() {
    return this.config.transactionConfirmationBlocks;
  }
  set transactionConfirmationBlocks(val) {
    this._triggerConfigChange("transactionConfirmationBlocks", val);
    this.config.transactionConfirmationBlocks = val;
  }
  get transactionPollingInterval() {
    return this.config.transactionPollingInterval;
  }
  set transactionPollingInterval(val) {
    this._triggerConfigChange("transactionPollingInterval", val);
    this.config.transactionPollingInterval = val;
    this.transactionReceiptPollingInterval = val;
    this.transactionConfirmationPollingInterval = val;
  }
  get transactionPollingTimeout() {
    return this.config.transactionPollingTimeout;
  }
  set transactionPollingTimeout(val) {
    this._triggerConfigChange("transactionPollingTimeout", val);
    this.config.transactionPollingTimeout = val;
  }
  get transactionReceiptPollingInterval() {
    return this.config.transactionReceiptPollingInterval;
  }
  set transactionReceiptPollingInterval(val) {
    this._triggerConfigChange("transactionReceiptPollingInterval", val);
    this.config.transactionReceiptPollingInterval = val;
  }
  get transactionConfirmationPollingInterval() {
    return this.config.transactionConfirmationPollingInterval;
  }
  set transactionConfirmationPollingInterval(val) {
    this._triggerConfigChange("transactionConfirmationPollingInterval", val);
    this.config.transactionConfirmationPollingInterval = val;
  }
  get blockHeaderTimeout() {
    return this.config.blockHeaderTimeout;
  }
  set blockHeaderTimeout(val) {
    this._triggerConfigChange("blockHeaderTimeout", val);
    this.config.blockHeaderTimeout = val;
  }
  get enableExperimentalFeatures() {
    return this.config.enableExperimentalFeatures;
  }
  set enableExperimentalFeatures(val) {
    this._triggerConfigChange("enableExperimentalFeatures", val);
    this.config.enableExperimentalFeatures = val;
  }
  get maxListenersWarningThreshold() {
    return this.config.maxListenersWarningThreshold;
  }
  set maxListenersWarningThreshold(val) {
    this._triggerConfigChange("maxListenersWarningThreshold", val);
    this.setMaxListenerWarningThreshold(val);
    this.config.maxListenersWarningThreshold = val;
  }
  get defaultNetworkId() {
    return this.config.defaultNetworkId;
  }
  set defaultNetworkId(val) {
    this._triggerConfigChange("defaultNetworkId", val);
    this.config.defaultNetworkId = val;
  }
  get defaultChain() {
    return this.config.defaultChain;
  }
  set defaultChain(val) {
    if (!isNullish9(this.config.defaultCommon) && !isNullish9(this.config.defaultCommon.baseChain) && val !== this.config.defaultCommon.baseChain)
      throw new ConfigChainMismatchError(this.config.defaultChain, val);
    this._triggerConfigChange("defaultChain", val);
    this.config.defaultChain = val;
  }
  get defaultHardfork() {
    return this.config.defaultHardfork;
  }
  set defaultHardfork(val) {
    if (!isNullish9(this.config.defaultCommon) && !isNullish9(this.config.defaultCommon.hardfork) && val !== this.config.defaultCommon.hardfork)
      throw new ConfigHardforkMismatchError(this.config.defaultCommon.hardfork, val);
    this._triggerConfigChange("defaultHardfork", val);
    this.config.defaultHardfork = val;
  }
  get defaultCommon() {
    return this.config.defaultCommon;
  }
  set defaultCommon(val) {
    if (!isNullish9(this.config.defaultHardfork) && !isNullish9(val) && !isNullish9(val.hardfork) && this.config.defaultHardfork !== val.hardfork)
      throw new ConfigHardforkMismatchError(this.config.defaultHardfork, val.hardfork);
    if (!isNullish9(this.config.defaultChain) && !isNullish9(val) && !isNullish9(val.baseChain) && this.config.defaultChain !== val.baseChain)
      throw new ConfigChainMismatchError(this.config.defaultChain, val.baseChain);
    this._triggerConfigChange("defaultCommon", val);
    this.config.defaultCommon = val;
  }
  get defaultTransactionType() {
    return this.config.defaultTransactionType;
  }
  set defaultTransactionType(val) {
    this._triggerConfigChange("defaultTransactionType", val);
    this.config.defaultTransactionType = val;
  }
  get defaultMaxPriorityFeePerGas() {
    return this.config.defaultMaxPriorityFeePerGas;
  }
  set defaultMaxPriorityFeePerGas(val) {
    this._triggerConfigChange("defaultMaxPriorityFeePerGas", val);
    this.config.defaultMaxPriorityFeePerGas = val;
  }
  get transactionBuilder() {
    return this.config.transactionBuilder;
  }
  set transactionBuilder(val) {
    this._triggerConfigChange("transactionBuilder", val);
    this.config.transactionBuilder = val;
  }
  get transactionTypeParser() {
    return this.config.transactionTypeParser;
  }
  set transactionTypeParser(val) {
    this._triggerConfigChange("transactionTypeParser", val);
    this.config.transactionTypeParser = val;
  }
  _triggerConfigChange(config, newValue) {
    this.emit(Web3ConfigEvent6.CONFIG_CHANGE, {
      name: config,
      oldValue: this.config[config],
      newValue
    });
  }
};

// node_modules/web3-eth-personal/node_modules/web3-core/lib/esm/web3_request_manager.js
init_shim();

// node_modules/web3-eth-personal/node_modules/web3-providers-http/lib/esm/index.js
init_shim();
var import_cross_fetch6 = __toESM(require_browser_ponyfill6());
var __awaiter84 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var HttpProvider6 = class extends Web3BaseProvider {
  constructor(clientUrl, httpProviderOptions) {
    super();
    if (!HttpProvider6.validateClientUrl(clientUrl))
      throw new InvalidClientError(clientUrl);
    this.clientUrl = clientUrl;
    this.httpProviderOptions = httpProviderOptions;
  }
  static validateClientUrl(clientUrl) {
    return typeof clientUrl === "string" ? /^http(s)?:\/\//i.test(clientUrl) : false;
  }
  getStatus() {
    throw new MethodNotImplementedError();
  }
  supportsSubscriptions() {
    return false;
  }
  request(payload, requestOptions) {
    var _a16;
    return __awaiter84(this, void 0, void 0, function* () {
      const providerOptionsCombined = Object.assign(Object.assign({}, (_a16 = this.httpProviderOptions) === null || _a16 === void 0 ? void 0 : _a16.providerOptions), requestOptions);
      const response = yield (0, import_cross_fetch6.default)(this.clientUrl, Object.assign(Object.assign({}, providerOptionsCombined), { method: "POST", headers: Object.assign(Object.assign({}, providerOptionsCombined.headers), { "Content-Type": "application/json" }), body: JSON.stringify(payload) }));
      if (!response.ok)
        throw new ResponseError(yield response.json());
      return yield response.json();
    });
  }
  on() {
    throw new MethodNotImplementedError();
  }
  removeListener() {
    throw new MethodNotImplementedError();
  }
  once() {
    throw new MethodNotImplementedError();
  }
  removeAllListeners() {
    throw new MethodNotImplementedError();
  }
  connect() {
    throw new MethodNotImplementedError();
  }
  disconnect() {
    throw new MethodNotImplementedError();
  }
  reset() {
    throw new MethodNotImplementedError();
  }
  reconnect() {
    throw new MethodNotImplementedError();
  }
};

// node_modules/web3-eth-personal/node_modules/web3-providers-ws/lib/esm/index.js
init_shim();

// node_modules/web3-eth-personal/node_modules/isomorphic-ws/browser.js
init_shim();
var ws6 = null;
if (typeof WebSocket !== "undefined") {
  ws6 = WebSocket;
} else if (typeof MozWebSocket !== "undefined") {
  ws6 = MozWebSocket;
} else if (typeof _global !== "undefined") {
  ws6 = _global.WebSocket || _global.MozWebSocket;
} else if (typeof window !== "undefined") {
  ws6 = window.WebSocket || window.MozWebSocket;
} else if (typeof self !== "undefined") {
  ws6 = self.WebSocket || self.MozWebSocket;
}
var browser_default6 = ws6;

// node_modules/web3-eth-personal/node_modules/web3-providers-ws/lib/esm/index.js
var WebSocketProvider6 = class extends SocketProvider6 {
  constructor(socketPath, socketOptions, reconnectOptions) {
    super(socketPath, socketOptions, reconnectOptions);
  }
  _validateProviderPath(providerUrl) {
    return typeof providerUrl === "string" ? /^ws(s)?:\/\//i.test(providerUrl) : false;
  }
  getStatus() {
    if (this._socketConnection && !isNullish9(this._socketConnection)) {
      switch (this._socketConnection.readyState) {
        case this._socketConnection.CONNECTING: {
          return "connecting";
        }
        case this._socketConnection.OPEN: {
          return "connected";
        }
        default: {
          return "disconnected";
        }
      }
    }
    return "disconnected";
  }
  _openSocketConnection() {
    this._socketConnection = new browser_default6(this._socketPath, void 0, this._socketOptions && Object.keys(this._socketOptions).length === 0 ? void 0 : this._socketOptions);
  }
  _closeSocketConnection(code, data) {
    var _a16;
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.close(code, data);
  }
  _sendToSocket(payload) {
    var _a16;
    if (this.getStatus() === "disconnected") {
      throw new ConnectionNotOpenError();
    }
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.send(JSON.stringify(payload));
  }
  _parseResponses(event) {
    return this.chunkResponseParser.parseResponse(event.data);
  }
  _addSocketListeners() {
    var _a16, _b, _c, _d;
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.addEventListener("open", this._onOpenHandler);
    (_b = this._socketConnection) === null || _b === void 0 ? void 0 : _b.addEventListener("message", this._onMessageHandler);
    (_c = this._socketConnection) === null || _c === void 0 ? void 0 : _c.addEventListener("close", (e) => this._onCloseHandler(e));
    (_d = this._socketConnection) === null || _d === void 0 ? void 0 : _d.addEventListener("error", this._onErrorHandler);
  }
  _removeSocketListeners() {
    var _a16, _b, _c;
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.removeEventListener("message", this._onMessageHandler);
    (_b = this._socketConnection) === null || _b === void 0 ? void 0 : _b.removeEventListener("open", this._onOpenHandler);
    (_c = this._socketConnection) === null || _c === void 0 ? void 0 : _c.removeEventListener("close", this._onCloseHandler);
  }
  _onCloseEvent(event) {
    var _a16;
    if (this._reconnectOptions.autoReconnect && (![1e3, 1001].includes(event.code) || !event.wasClean)) {
      this._reconnect();
      return;
    }
    this._clearQueues(event);
    this._removeSocketListeners();
    this._onDisconnect(event.code, event.reason);
    (_a16 = this._socketConnection) === null || _a16 === void 0 ? void 0 : _a16.removeEventListener("error", this._onErrorHandler);
  }
};

// node_modules/web3-eth-personal/node_modules/web3-core/lib/esm/utils.js
init_shim();
var isWeb3Provider6 = (provider) => Web3BaseProvider.isWeb3Provider(provider);
var isMetaMaskProvider6 = (provider) => typeof provider !== "string" && "request" in provider && provider.request.constructor.name === "AsyncFunction" && "isMetaMask" in provider && provider.isMetaMask;
var isLegacyRequestProvider6 = (provider) => typeof provider !== "string" && "request" in provider && provider.request.constructor.name === "Function";
var isEIP1193Provider6 = (provider) => typeof provider !== "string" && "request" in provider && provider.request.constructor.name === "AsyncFunction";
var isLegacySendProvider6 = (provider) => typeof provider !== "string" && "send" in provider;
var isLegacySendAsyncProvider6 = (provider) => typeof provider !== "string" && "sendAsync" in provider;
var isSupportedProvider6 = (provider) => provider && (isWeb3Provider6(provider) || isEIP1193Provider6(provider) || isLegacyRequestProvider6(provider) || isLegacySendAsyncProvider6(provider) || isLegacySendProvider6(provider));
var isSupportSubscriptions6 = (provider) => {
  if (provider && "supportsSubscriptions" in provider) {
    return provider.supportsSubscriptions();
  }
  if (provider && typeof provider !== "string" && "on" in provider) {
    return true;
  }
  return false;
};

// node_modules/web3-eth-personal/node_modules/web3-core/lib/esm/web3_request_manager.js
var __awaiter85 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3RequestManagerEvent6;
(function(Web3RequestManagerEvent7) {
  Web3RequestManagerEvent7["PROVIDER_CHANGED"] = "PROVIDER_CHANGED";
  Web3RequestManagerEvent7["BEFORE_PROVIDER_CHANGE"] = "BEFORE_PROVIDER_CHANGE";
})(Web3RequestManagerEvent6 || (Web3RequestManagerEvent6 = {}));
var availableProviders6 = {
  HttpProvider: HttpProvider6,
  WebsocketProvider: WebSocketProvider6
};
var metamaskPayload6 = (payload) => {
  var _a16;
  if (Array.isArray(payload.params)) {
    const params = payload.params[0];
    if (params.input && !params.data) {
      return Object.assign(Object.assign({}, payload), { params: [Object.assign(Object.assign({}, params), { data: (_a16 = params.data) !== null && _a16 !== void 0 ? _a16 : params.input })] });
    }
  }
  return payload;
};
var Web3RequestManager6 = class extends Web3EventEmitter6 {
  constructor(provider, useRpcCallSpecification) {
    super();
    if (!isNullish9(provider)) {
      this.setProvider(provider);
    }
    this.useRpcCallSpecification = useRpcCallSpecification;
  }
  static get providers() {
    return availableProviders6;
  }
  get provider() {
    return this._provider;
  }
  get providers() {
    return availableProviders6;
  }
  setProvider(provider) {
    let newProvider;
    if (provider && typeof provider === "string" && this.providers) {
      if (/^http(s)?:\/\//i.test(provider)) {
        newProvider = new this.providers.HttpProvider(provider);
      } else if (/^ws(s)?:\/\//i.test(provider)) {
        newProvider = new this.providers.WebsocketProvider(provider);
      } else {
        throw new ProviderError(`Can't autodetect provider for "${provider}"`);
      }
    } else if (isNullish9(provider)) {
      newProvider = void 0;
    } else {
      newProvider = provider;
    }
    this.emit(Web3RequestManagerEvent6.BEFORE_PROVIDER_CHANGE, this._provider);
    this._provider = newProvider;
    this.emit(Web3RequestManagerEvent6.PROVIDER_CHANGED, this._provider);
    return true;
  }
  send(request) {
    return __awaiter85(this, void 0, void 0, function* () {
      const response = yield this._sendRequest(request);
      if (json_rpc_exports8.isResponseWithResult(response)) {
        return response.result;
      }
      throw new ResponseError(response);
    });
  }
  sendBatch(request) {
    return __awaiter85(this, void 0, void 0, function* () {
      const response = yield this._sendRequest(request);
      return response;
    });
  }
  _sendRequest(request) {
    return __awaiter85(this, void 0, void 0, function* () {
      const { provider } = this;
      if (isNullish9(provider)) {
        throw new ProviderError("Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.");
      }
      let payload = json_rpc_exports8.isBatchRequest(request) ? json_rpc_exports8.toBatchPayload(request) : json_rpc_exports8.toPayload(request);
      if (isMetaMaskProvider6(provider)) {
        if (payload.method === "eth_sendTransaction") {
          if (!json_rpc_exports8.isBatchRequest(payload)) {
            payload = metamaskPayload6(payload);
          } else {
            payload = payload.map((p) => metamaskPayload6(p));
          }
        }
      }
      if (isWeb3Provider6(provider)) {
        let response;
        try {
          response = yield provider.request(payload);
        } catch (error) {
          response = error;
        }
        return this._processJsonRpcResponse(payload, response, { legacy: false, error: false });
      }
      if (isEIP1193Provider6(provider)) {
        return provider.request(payload).then((res) => this._processJsonRpcResponse(payload, res, {
          legacy: true,
          error: false
        })).catch((error) => this._processJsonRpcResponse(payload, error, { legacy: true, error: true }));
      }
      if (isLegacyRequestProvider6(provider)) {
        return new Promise((resolve, reject) => {
          const rejectWithError = (err) => reject(this._processJsonRpcResponse(payload, err, {
            legacy: true,
            error: true
          }));
          const resolveWithResponse = (response) => resolve(this._processJsonRpcResponse(payload, response, {
            legacy: true,
            error: false
          }));
          const result = provider.request(
            payload,
            (err, response) => {
              if (err) {
                return rejectWithError(err);
              }
              return resolveWithResponse(response);
            }
          );
          if (isPromise6(result)) {
            const responsePromise = result;
            responsePromise.then(resolveWithResponse).catch(rejectWithError);
          }
        });
      }
      if (isLegacySendProvider6(provider)) {
        return new Promise((resolve, reject) => {
          provider.send(payload, (err, response) => {
            if (err) {
              return reject(this._processJsonRpcResponse(payload, err, {
                legacy: true,
                error: true
              }));
            }
            if (isNullish9(response)) {
              throw new ResponseError("", 'Got a "nullish" response from provider.');
            }
            return resolve(this._processJsonRpcResponse(payload, response, {
              legacy: true,
              error: false
            }));
          });
        });
      }
      if (isLegacySendAsyncProvider6(provider)) {
        return provider.sendAsync(payload).then((response) => this._processJsonRpcResponse(payload, response, { legacy: true, error: false })).catch((error) => this._processJsonRpcResponse(payload, error, {
          legacy: true,
          error: true
        }));
      }
      throw new ProviderError("Provider does not have a request or send method to use.");
    });
  }
  _processJsonRpcResponse(payload, response, { legacy, error }) {
    if (isNullish9(response)) {
      return this._buildResponse(
        payload,
        null,
        error
      );
    }
    if (json_rpc_exports8.isResponseWithError(response)) {
      if (this.useRpcCallSpecification && isResponseRpcError8(response)) {
        const rpcErrorResponse = response;
        if (rpcErrorsMap.get(rpcErrorResponse.error.code)) {
          const Err = rpcErrorsMap.get(rpcErrorResponse.error.code).error;
          throw new Err(rpcErrorResponse);
        } else {
          throw new RpcError(rpcErrorResponse);
        }
      } else if (!Web3RequestManager6._isReverted(response)) {
        throw new InvalidResponseError(response, payload);
      }
    }
    if (json_rpc_exports8.isResponseWithResult(response)) {
      return response;
    }
    if (response instanceof Error) {
      Web3RequestManager6._isReverted(response);
      throw response;
    }
    if (!legacy && json_rpc_exports8.isBatchRequest(payload) && json_rpc_exports8.isBatchResponse(response)) {
      return response;
    }
    if (legacy && !error && json_rpc_exports8.isBatchRequest(payload)) {
      return response;
    }
    if (legacy && error && json_rpc_exports8.isBatchRequest(payload)) {
      throw response;
    }
    if (legacy && !json_rpc_exports8.isResponseWithError(response) && !json_rpc_exports8.isResponseWithResult(response)) {
      return this._buildResponse(payload, response, error);
    }
    if (json_rpc_exports8.isBatchRequest(payload) && !Array.isArray(response)) {
      throw new ResponseError(response, "Got normal response for a batch request.");
    }
    if (!json_rpc_exports8.isBatchRequest(payload) && Array.isArray(response)) {
      throw new ResponseError(response, "Got batch response for a normal request.");
    }
    if ((json_rpc_exports8.isResponseWithError(response) || json_rpc_exports8.isResponseWithResult(response)) && !json_rpc_exports8.isBatchRequest(payload)) {
      if (response.id && payload.id !== response.id) {
        throw new InvalidResponseError(response);
      }
    }
    throw new ResponseError(response, "Invalid response");
  }
  static _isReverted(response) {
    let error;
    if (json_rpc_exports8.isResponseWithError(response)) {
      error = response.error;
    } else if (response instanceof Error) {
      error = response;
    }
    if (error === null || error === void 0 ? void 0 : error.message.includes("revert"))
      throw new ContractExecutionError(error);
    return false;
  }
  _buildResponse(payload, response, error) {
    const res = {
      jsonrpc: "2.0",
      id: json_rpc_exports8.isBatchRequest(payload) ? payload[0].id : "id" in payload ? payload.id : null
    };
    if (error) {
      return Object.assign(Object.assign({}, res), { error: response });
    }
    return Object.assign(Object.assign({}, res), { result: response });
  }
};

// node_modules/web3-eth-personal/node_modules/web3-core/lib/esm/web3_subscription_manager.js
init_shim();
var __awaiter86 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3SubscriptionManager6 = class {
  constructor(requestManager, registeredSubscriptions2, tolerateUnlinkedSubscription = false) {
    this.requestManager = requestManager;
    this.registeredSubscriptions = registeredSubscriptions2;
    this.tolerateUnlinkedSubscription = tolerateUnlinkedSubscription;
    this._subscriptions = /* @__PURE__ */ new Map();
    this.requestManager.on(Web3RequestManagerEvent6.BEFORE_PROVIDER_CHANGE, () => __awaiter86(this, void 0, void 0, function* () {
      yield this.unsubscribe();
    }));
    this.requestManager.on(Web3RequestManagerEvent6.PROVIDER_CHANGED, () => {
      this.clear();
      this.listenToProviderEvents();
    });
    this.listenToProviderEvents();
  }
  listenToProviderEvents() {
    const providerAsWebProvider = this.requestManager.provider;
    if (!this.requestManager.provider || typeof (providerAsWebProvider === null || providerAsWebProvider === void 0 ? void 0 : providerAsWebProvider.supportsSubscriptions) === "function" && !(providerAsWebProvider === null || providerAsWebProvider === void 0 ? void 0 : providerAsWebProvider.supportsSubscriptions())) {
      return;
    }
    if (typeof this.requestManager.provider.on === "function") {
      if (typeof this.requestManager.provider.request === "function") {
        this.requestManager.provider.on(
          "message",
          (message) => this.messageListener(message)
        );
      } else {
        providerAsWebProvider.on("data", (data) => this.messageListener(data));
      }
    }
  }
  messageListener(data) {
    var _a16, _b, _c;
    if (!data) {
      throw new SubscriptionError("Should not call messageListener with no data. Type was");
    }
    const subscriptionId = ((_a16 = data.params) === null || _a16 === void 0 ? void 0 : _a16.subscription) || ((_b = data.data) === null || _b === void 0 ? void 0 : _b.subscription) || ((_c = data.id) === null || _c === void 0 ? void 0 : _c.toString(16));
    if (subscriptionId) {
      const sub = this._subscriptions.get(subscriptionId);
      sub === null || sub === void 0 ? void 0 : sub.processSubscriptionData(data);
    }
  }
  subscribe(name2, args, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter86(this, void 0, void 0, function* () {
      const Klass = this.registeredSubscriptions[name2];
      if (!Klass) {
        throw new SubscriptionError("Invalid subscription type");
      }
      const subscription = new Klass(args !== null && args !== void 0 ? args : void 0, {
        subscriptionManager: this,
        returnFormat
      });
      yield this.addSubscription(subscription);
      return subscription;
    });
  }
  get subscriptions() {
    return this._subscriptions;
  }
  addSubscription(sub) {
    return __awaiter86(this, void 0, void 0, function* () {
      if (!this.requestManager.provider) {
        throw new ProviderError("Provider not available");
      }
      if (!this.supportsSubscriptions()) {
        throw new SubscriptionError("The current provider does not support subscriptions");
      }
      if (sub.id && this._subscriptions.has(sub.id)) {
        throw new SubscriptionError(`Subscription with id "${sub.id}" already exists`);
      }
      yield sub.sendSubscriptionRequest();
      if (isNullish9(sub.id)) {
        throw new SubscriptionError("Subscription is not subscribed yet.");
      }
      this._subscriptions.set(sub.id, sub);
      return sub.id;
    });
  }
  removeSubscription(sub) {
    return __awaiter86(this, void 0, void 0, function* () {
      const { id } = sub;
      if (isNullish9(id)) {
        throw new SubscriptionError("Subscription is not subscribed yet. Or, had already been unsubscribed but not through the Subscription Manager.");
      }
      if (!this._subscriptions.has(id) && !this.tolerateUnlinkedSubscription) {
        throw new SubscriptionError(`Subscription with id "${id.toString()}" does not exists`);
      }
      yield sub.sendUnsubscribeRequest();
      this._subscriptions.delete(id);
      return id;
    });
  }
  unsubscribe(condition) {
    return __awaiter86(this, void 0, void 0, function* () {
      const result = [];
      for (const [id, sub] of this.subscriptions.entries()) {
        if (!condition || typeof condition === "function" && condition({ id, sub })) {
          result.push(this.removeSubscription(sub));
        }
      }
      return Promise.all(result);
    });
  }
  clear() {
    this._subscriptions.clear();
  }
  supportsSubscriptions() {
    return isNullish9(this.requestManager.provider) ? false : isSupportSubscriptions6(this.requestManager.provider);
  }
};

// node_modules/web3-eth-personal/node_modules/web3-core/lib/esm/web3_subscriptions.js
init_shim();

// node_modules/web3-eth-personal/node_modules/web3-core/lib/esm/web3_context.js
init_shim();

// node_modules/web3-eth-personal/node_modules/web3-core/lib/esm/web3_batch_request.js
init_shim();
var __awaiter87 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_BATCH_REQUEST_TIMEOUT6 = 1e3;
var Web3BatchRequest6 = class {
  constructor(requestManager) {
    this._requestManager = requestManager;
    this._requests = /* @__PURE__ */ new Map();
  }
  get requests() {
    return [...this._requests.values()].map((r) => r.payload);
  }
  add(request) {
    const payload = json_rpc_exports8.toPayload(request);
    const promise = new Web3DeferredPromise8();
    this._requests.set(payload.id, { payload, promise });
    return promise;
  }
  execute(options) {
    var _a16;
    return __awaiter87(this, void 0, void 0, function* () {
      if (this.requests.length === 0) {
        return Promise.resolve([]);
      }
      const request = new Web3DeferredPromise8({
        timeout: (_a16 = options === null || options === void 0 ? void 0 : options.timeout) !== null && _a16 !== void 0 ? _a16 : DEFAULT_BATCH_REQUEST_TIMEOUT6,
        eagerStart: true,
        timeoutMessage: "Batch request timeout"
      });
      this._processBatchRequest(request).catch((err) => request.reject(err));
      request.catch((err) => {
        if (err instanceof OperationTimeoutError) {
          this._abortAllRequests("Batch request timeout");
        }
        request.reject(err);
      });
      return request;
    });
  }
  _processBatchRequest(promise) {
    var _a16, _b;
    return __awaiter87(this, void 0, void 0, function* () {
      const response = yield this._requestManager.sendBatch([...this._requests.values()].map((r) => r.payload));
      if (response.length !== this._requests.size) {
        this._abortAllRequests("Invalid batch response");
        throw new ResponseError(response, `Batch request size mismatch the results size. Requests: ${this._requests.size}, Responses: ${response.length}`);
      }
      const requestIds = this.requests.map((r) => r.id).map(Number).sort((a, b) => a - b);
      const responseIds = response.map((r) => r.id).map(Number).sort((a, b) => a - b);
      if (JSON.stringify(requestIds) !== JSON.stringify(responseIds)) {
        this._abortAllRequests("Invalid batch response");
        throw new ResponseError(response, `Batch request mismatch the results. Requests: [${requestIds.join()}], Responses: [${responseIds.join()}]`);
      }
      for (const res of response) {
        if (json_rpc_exports8.isResponseWithResult(res)) {
          (_a16 = this._requests.get(res.id)) === null || _a16 === void 0 ? void 0 : _a16.promise.resolve(res.result);
        } else if (json_rpc_exports8.isResponseWithError(res)) {
          (_b = this._requests.get(res.id)) === null || _b === void 0 ? void 0 : _b.promise.reject(res.error);
        }
      }
      promise.resolve(response);
    });
  }
  _abortAllRequests(msg) {
    for (const { promise } of this._requests.values()) {
      promise.reject(new OperationAbortError(msg));
    }
  }
};

// node_modules/web3-eth-personal/node_modules/web3-core/lib/esm/web3_context.js
var __awaiter88 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3Context6 = class extends Web3Config6 {
  constructor(providerOrContext) {
    var _a16;
    super();
    this.providers = Web3RequestManager6.providers;
    if (isNullish9(providerOrContext) || typeof providerOrContext === "string" && providerOrContext.trim() !== "" || isSupportedProvider6(providerOrContext)) {
      this._requestManager = new Web3RequestManager6(providerOrContext);
      this._subscriptionManager = new Web3SubscriptionManager6(this._requestManager, {});
      return;
    }
    const { config, provider, requestManager, subscriptionManager, registeredSubscriptions: registeredSubscriptions2, accountProvider, wallet } = providerOrContext;
    this.setConfig(config !== null && config !== void 0 ? config : {});
    this._requestManager = requestManager !== null && requestManager !== void 0 ? requestManager : new Web3RequestManager6(provider, (_a16 = config === null || config === void 0 ? void 0 : config.enableExperimentalFeatures) === null || _a16 === void 0 ? void 0 : _a16.useSubscriptionWhenCheckingBlockTimeout);
    if (subscriptionManager) {
      this._subscriptionManager = subscriptionManager;
    } else {
      this._subscriptionManager = new Web3SubscriptionManager6(this.requestManager, registeredSubscriptions2 !== null && registeredSubscriptions2 !== void 0 ? registeredSubscriptions2 : {});
    }
    if (accountProvider) {
      this._accountProvider = accountProvider;
    }
    if (wallet) {
      this._wallet = wallet;
    }
  }
  get requestManager() {
    return this._requestManager;
  }
  get subscriptionManager() {
    return this._subscriptionManager;
  }
  get wallet() {
    return this._wallet;
  }
  get accountProvider() {
    return this._accountProvider;
  }
  static fromContextObject(...args) {
    return new this(...args.reverse());
  }
  getContextObject() {
    var _a16;
    return {
      config: this.config,
      provider: this.provider,
      requestManager: this.requestManager,
      subscriptionManager: this.subscriptionManager,
      registeredSubscriptions: (_a16 = this.subscriptionManager) === null || _a16 === void 0 ? void 0 : _a16.registeredSubscriptions,
      providers: this.providers,
      wallet: this.wallet,
      accountProvider: this.accountProvider
    };
  }
  use(ContextRef, ...args) {
    const newContextChild = new ContextRef(...[...args, this.getContextObject()]);
    this.on(Web3ConfigEvent6.CONFIG_CHANGE, (event) => {
      newContextChild.setConfig({ [event.name]: event.newValue });
    });
    return newContextChild;
  }
  link(parentContext) {
    this.setConfig(parentContext.config);
    this._requestManager = parentContext.requestManager;
    this.provider = parentContext.provider;
    this._subscriptionManager = parentContext.subscriptionManager;
    this._wallet = parentContext.wallet;
    this._accountProvider = parentContext._accountProvider;
    parentContext.on(Web3ConfigEvent6.CONFIG_CHANGE, (event) => {
      this.setConfig({ [event.name]: event.newValue });
    });
  }
  registerPlugin(plugin) {
    if (this[plugin.pluginNamespace] !== void 0)
      throw new ExistingPluginNamespaceError(plugin.pluginNamespace);
    const _pluginObject = {
      [plugin.pluginNamespace]: plugin
    };
    _pluginObject[plugin.pluginNamespace].link(this);
    Object.assign(this, _pluginObject);
  }
  get provider() {
    return this.currentProvider;
  }
  set provider(provider) {
    this.requestManager.setProvider(provider);
  }
  get currentProvider() {
    return this.requestManager.provider;
  }
  set currentProvider(provider) {
    this.requestManager.setProvider(provider);
  }
  get givenProvider() {
    return Web3Context6.givenProvider;
  }
  setProvider(provider) {
    this.provider = provider;
    return true;
  }
  get BatchRequest() {
    return Web3BatchRequest6.bind(void 0, this._requestManager);
  }
  extend(extendObj) {
    var _a16;
    if (extendObj.property && !this[extendObj.property])
      this[extendObj.property] = {};
    (_a16 = extendObj.methods) === null || _a16 === void 0 ? void 0 : _a16.forEach((element) => {
      const method = (...givenParams) => __awaiter88(this, void 0, void 0, function* () {
        return this.requestManager.send({
          method: element.call,
          params: givenParams
        });
      });
      if (extendObj.property)
        this[extendObj.property][element.name] = method;
      else
        this[element.name] = method;
    });
    return this;
  }
};
Web3Context6.providers = Web3RequestManager6.providers;

// node_modules/web3-eth-personal/node_modules/web3-core/lib/esm/types.js
init_shim();

// node_modules/web3-eth-personal/node_modules/web3-core/lib/esm/formatters.js
var formatters_exports6 = {};
__export(formatters_exports6, {
  inputAddressFormatter: () => inputAddressFormatter6,
  inputBlockNumberFormatter: () => inputBlockNumberFormatter6,
  inputCallFormatter: () => inputCallFormatter6,
  inputDefaultBlockNumberFormatter: () => inputDefaultBlockNumberFormatter6,
  inputLogFormatter: () => inputLogFormatter6,
  inputPostFormatter: () => inputPostFormatter6,
  inputSignFormatter: () => inputSignFormatter6,
  inputStorageKeysFormatter: () => inputStorageKeysFormatter6,
  inputTopicFormatter: () => inputTopicFormatter6,
  inputTransactionFormatter: () => inputTransactionFormatter6,
  outputBigIntegerFormatter: () => outputBigIntegerFormatter6,
  outputBlockFormatter: () => outputBlockFormatter6,
  outputLogFormatter: () => outputLogFormatter6,
  outputPostFormatter: () => outputPostFormatter6,
  outputProofFormatter: () => outputProofFormatter6,
  outputSyncingFormatter: () => outputSyncingFormatter6,
  outputTransactionFormatter: () => outputTransactionFormatter6,
  outputTransactionReceiptFormatter: () => outputTransactionReceiptFormatter6,
  txInputOptionsFormatter: () => txInputOptionsFormatter6
});
init_shim();

// node_modules/web3-eth-personal/node_modules/web3-eth-iban/lib/esm/index.js
init_shim();

// node_modules/web3-eth-personal/node_modules/web3-eth-iban/lib/esm/iban.js
init_shim();
var Iban6 = class {
  constructor(iban) {
    this.toAddress = () => {
      if (this.isDirect()) {
        const base36 = this._iban.slice(4);
        const parsedBigInt = Iban6._parseInt(base36, 36);
        const paddedBigInt = leftPad8(parsedBigInt, 40);
        return toChecksumAddress8(paddedBigInt);
      }
      throw new Error("Iban is indirect and cannot be converted. Must be length of 34 or 35");
    };
    if (Iban6.isIndirect(iban) || Iban6.isDirect(iban)) {
      this._iban = iban;
    } else {
      throw new Error("Invalid IBAN was provided");
    }
  }
  static isDirect(iban) {
    return iban.length === 34 || iban.length === 35;
  }
  isDirect() {
    return Iban6.isDirect(this._iban);
  }
  static isIndirect(iban) {
    return iban.length === 20;
  }
  isIndirect() {
    return Iban6.isIndirect(this._iban);
  }
  static isValid(iban) {
    return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(iban) && Iban6._mod9710(Iban6._iso13616Prepare(iban)) === 1;
  }
  isValid() {
    return Iban6.isValid(this._iban);
  }
  static fromBban(bban) {
    const countryCode = "XE";
    const remainder = this._mod9710(this._iso13616Prepare(`${countryCode}00${bban}`));
    const checkDigit = `0${(98 - remainder).toString()}`.slice(-2);
    return new Iban6(`${countryCode}${checkDigit}${bban}`);
  }
  static createIndirect(options) {
    return Iban6.fromBban(`ETH${options.institution}${options.identifier}`);
  }
  static fromAddress(address) {
    if (!isAddress(address)) {
      throw new InvalidAddressError(address);
    }
    const num = BigInt(hexToNumber8(address));
    const base36 = num.toString(36);
    const padded = leftPad8(base36, 15);
    return Iban6.fromBban(padded.toUpperCase());
  }
  static toIban(address) {
    return Iban6.fromAddress(address).toString();
  }
  client() {
    return this.isIndirect() ? this._iban.slice(11) : "";
  }
  checksum() {
    return this._iban.slice(2, 4);
  }
  institution() {
    return this.isIndirect() ? this._iban.slice(7, 11) : "";
  }
  toString() {
    return this._iban;
  }
};
Iban6._iso13616Prepare = (iban) => {
  const A = "A".charCodeAt(0);
  const Z = "Z".charCodeAt(0);
  const upperIban = iban.toUpperCase();
  const modifiedIban = `${upperIban.slice(4)}${upperIban.slice(0, 4)}`;
  return modifiedIban.split("").map((n) => {
    const code = n.charCodeAt(0);
    if (code >= A && code <= Z) {
      return code - A + 10;
    }
    return n;
  }).join("");
};
Iban6._parseInt = (str, base2) => [...str].reduce((acc, curr) => BigInt(parseInt(curr, base2)) + BigInt(base2) * acc, BigInt(0));
Iban6._mod9710 = (iban) => {
  let remainder = iban;
  let block;
  while (remainder.length > 2) {
    block = remainder.slice(0, 9);
    remainder = `${(parseInt(block, 10) % 97).toString()}${remainder.slice(block.length)}`;
  }
  return parseInt(remainder, 10) % 97;
};
Iban6.toAddress = (iban) => {
  const ibanObject = new Iban6(iban);
  return ibanObject.toAddress();
};

// node_modules/web3-eth-personal/node_modules/web3-eth-iban/lib/esm/types.js
init_shim();

// node_modules/web3-eth-personal/node_modules/web3-core/lib/esm/formatters.js
var inputStorageKeysFormatter6 = (keys) => keys.map((num) => numberToHex9(num));
var outputProofFormatter6 = (proof) => ({
  address: toChecksumAddress8(proof.address),
  nonce: hexToNumberString6(proof.nonce),
  balance: hexToNumberString6(proof.balance)
});
var outputBigIntegerFormatter6 = (number) => toNumber8(number);
var inputBlockNumberFormatter6 = (blockNumber) => {
  if (isNullish(blockNumber)) {
    return void 0;
  }
  if (typeof blockNumber === "string" && isBlockTag(blockNumber)) {
    return blockNumber;
  }
  if (blockNumber === "genesis") {
    return "0x0";
  }
  if (typeof blockNumber === "string" && isHexStrict7(blockNumber)) {
    return blockNumber.toLowerCase();
  }
  return numberToHex9(blockNumber);
};
var inputDefaultBlockNumberFormatter6 = (blockNumber, defaultBlock) => {
  if (!blockNumber) {
    return inputBlockNumberFormatter6(defaultBlock);
  }
  return inputBlockNumberFormatter6(blockNumber);
};
var inputAddressFormatter6 = (address) => {
  if (Iban6.isValid(address) && Iban6.isDirect(address)) {
    const iban = new Iban6(address);
    return iban.toAddress().toLowerCase();
  }
  if (isAddress7(address)) {
    return `0x${address.toLowerCase().replace("0x", "")}`;
  }
  throw new FormatterError(`Provided address ${address} is invalid, the capitalization checksum test failed, or it's an indirect IBAN address which can't be converted.`);
};
var txInputOptionsFormatter6 = (options) => {
  var _a16;
  const modifiedOptions = Object.assign({}, options);
  if (options.to) {
    modifiedOptions.to = inputAddressFormatter6(options.to);
  }
  if (options.data && options.input) {
    throw new FormatterError(`You can't have "data" and "input" as properties of transactions at the same time, please use either "data" or "input" instead.`);
  }
  if (!options.input && options.data) {
    modifiedOptions.input = options.data;
    delete modifiedOptions.data;
  }
  if (options.input && !options.input.startsWith("0x")) {
    modifiedOptions.input = `0x${options.input}`;
  }
  if (modifiedOptions.input && !isHexStrict7(modifiedOptions.input)) {
    throw new FormatterError("The input field must be HEX encoded data.");
  }
  if (options.gas || options.gasLimit) {
    modifiedOptions.gas = toNumber8((_a16 = options.gas) !== null && _a16 !== void 0 ? _a16 : options.gasLimit);
  }
  if (options.maxPriorityFeePerGas || options.maxFeePerGas) {
    delete modifiedOptions.gasPrice;
  }
  ["gasPrice", "gas", "value", "maxPriorityFeePerGas", "maxFeePerGas", "nonce", "chainId"].filter((key) => !isNullish(modifiedOptions[key])).forEach((key) => {
    modifiedOptions[key] = numberToHex9(modifiedOptions[key]);
  });
  return modifiedOptions;
};
var inputCallFormatter6 = (options, defaultAccount) => {
  var _a16;
  const opts = txInputOptionsFormatter6(options);
  const from = (_a16 = opts.from) !== null && _a16 !== void 0 ? _a16 : defaultAccount;
  if (from) {
    opts.from = inputAddressFormatter6(from);
  }
  return opts;
};
var inputTransactionFormatter6 = (options, defaultAccount) => {
  var _a16;
  const opts = txInputOptionsFormatter6(options);
  if (!(typeof opts.from === "number") && !(!!opts.from && typeof opts.from === "object")) {
    opts.from = (_a16 = opts.from) !== null && _a16 !== void 0 ? _a16 : defaultAccount;
    if (!options.from && !(typeof options.from === "number")) {
      throw new FormatterError('The send transactions "from" field must be defined!');
    }
    opts.from = inputAddressFormatter6(options.from);
  }
  return opts;
};
var inputSignFormatter6 = (data) => isHexStrict7(data) ? data : utf8ToHex8(data);
var outputTransactionFormatter6 = (tx) => {
  const modifiedTx = Object.assign({}, tx);
  if (tx.blockNumber) {
    modifiedTx.blockNumber = hexToNumber8(tx.blockNumber);
  }
  if (tx.transactionIndex) {
    modifiedTx.transactionIndex = hexToNumber8(tx.transactionIndex);
  }
  modifiedTx.nonce = hexToNumber8(tx.nonce);
  modifiedTx.gas = hexToNumber8(tx.gas);
  if (tx.gasPrice) {
    modifiedTx.gasPrice = outputBigIntegerFormatter6(tx.gasPrice);
  }
  if (tx.maxFeePerGas) {
    modifiedTx.maxFeePerGas = outputBigIntegerFormatter6(tx.maxFeePerGas);
  }
  if (tx.maxPriorityFeePerGas) {
    modifiedTx.maxPriorityFeePerGas = outputBigIntegerFormatter6(tx.maxPriorityFeePerGas);
  }
  if (tx.type) {
    modifiedTx.type = hexToNumber8(tx.type);
  }
  modifiedTx.value = outputBigIntegerFormatter6(tx.value);
  if (tx.to && isAddress7(tx.to)) {
    modifiedTx.to = toChecksumAddress8(tx.to);
  } else {
    modifiedTx.to = void 0;
  }
  if (tx.from) {
    modifiedTx.from = toChecksumAddress8(tx.from);
  }
  return modifiedTx;
};
var inputTopicFormatter6 = (topic) => {
  if (isNullish(topic))
    return null;
  const value = String(topic);
  return isHex(value) ? value : fromUtf87(value);
};
var inputLogFormatter6 = (filter) => {
  var _a16;
  const val = isNullish(filter) ? {} : mergeDeep8({}, filter);
  if (isNullish(val.fromBlock)) {
    val.fromBlock = BlockTags.LATEST;
  }
  val.fromBlock = inputBlockNumberFormatter6(val.fromBlock);
  if (!isNullish(val.toBlock)) {
    val.toBlock = inputBlockNumberFormatter6(val.toBlock);
  }
  val.topics = (_a16 = val.topics) !== null && _a16 !== void 0 ? _a16 : [];
  val.topics = val.topics.map((topic) => Array.isArray(topic) ? topic.map(inputTopicFormatter6) : inputTopicFormatter6(topic));
  if (val.address) {
    val.address = Array.isArray(val.address) ? val.address.map((addr) => inputAddressFormatter6(addr)) : inputAddressFormatter6(val.address);
  }
  return val;
};
var outputLogFormatter6 = (log) => {
  const modifiedLog = Object.assign({}, log);
  const logIndex = typeof log.logIndex === "string" ? log.logIndex : numberToHex9(log.logIndex);
  if (typeof log.blockHash === "string" && typeof log.transactionHash === "string") {
    const shaId = sha3Raw8(`${log.blockHash.replace("0x", "")}${log.transactionHash.replace("0x", "")}${logIndex.replace("0x", "")}`);
    modifiedLog.id = `log_${shaId.replace("0x", "").slice(0, 8)}`;
  } else if (!log.id) {
    modifiedLog.id = void 0;
  }
  if (log.blockNumber && isHexStrict7(log.blockNumber)) {
    modifiedLog.blockNumber = hexToNumber8(log.blockNumber);
  }
  if (log.transactionIndex && isHexStrict7(log.transactionIndex)) {
    modifiedLog.transactionIndex = hexToNumber8(log.transactionIndex);
  }
  if (log.logIndex && isHexStrict7(log.logIndex)) {
    modifiedLog.logIndex = hexToNumber8(log.logIndex);
  }
  if (log.address) {
    modifiedLog.address = toChecksumAddress8(log.address);
  }
  return modifiedLog;
};
var outputTransactionReceiptFormatter6 = (receipt) => {
  if (typeof receipt !== "object") {
    throw new FormatterError(`Received receipt is invalid: ${String(receipt)}`);
  }
  const modifiedReceipt = Object.assign({}, receipt);
  if (receipt.blockNumber) {
    modifiedReceipt.blockNumber = hexToNumber8(receipt.blockNumber);
  }
  if (receipt.transactionIndex) {
    modifiedReceipt.transactionIndex = hexToNumber8(receipt.transactionIndex);
  }
  modifiedReceipt.cumulativeGasUsed = hexToNumber8(receipt.cumulativeGasUsed);
  modifiedReceipt.gasUsed = hexToNumber8(receipt.gasUsed);
  if (receipt.logs && Array.isArray(receipt.logs)) {
    modifiedReceipt.logs = receipt.logs.map(outputLogFormatter6);
  }
  if (receipt.effectiveGasPrice) {
    modifiedReceipt.effectiveGasPrice = hexToNumber8(receipt.effectiveGasPrice);
  }
  if (receipt.contractAddress) {
    modifiedReceipt.contractAddress = toChecksumAddress8(receipt.contractAddress);
  }
  if (receipt.status) {
    modifiedReceipt.status = Boolean(parseInt(receipt.status, 10));
  }
  return modifiedReceipt;
};
var outputBlockFormatter6 = (block) => {
  const modifiedBlock = Object.assign({}, block);
  modifiedBlock.gasLimit = hexToNumber8(block.gasLimit);
  modifiedBlock.gasUsed = hexToNumber8(block.gasUsed);
  modifiedBlock.size = hexToNumber8(block.size);
  modifiedBlock.timestamp = hexToNumber8(block.timestamp);
  if (block.number) {
    modifiedBlock.number = hexToNumber8(block.number);
  }
  if (block.difficulty) {
    modifiedBlock.difficulty = outputBigIntegerFormatter6(block.difficulty);
  }
  if (block.totalDifficulty) {
    modifiedBlock.totalDifficulty = outputBigIntegerFormatter6(block.totalDifficulty);
  }
  if (block.transactions && Array.isArray(block.transactions)) {
    modifiedBlock.transactions = block.transactions.map(outputTransactionFormatter6);
  }
  if (block.miner) {
    modifiedBlock.miner = toChecksumAddress8(block.miner);
  }
  if (block.baseFeePerGas) {
    modifiedBlock.baseFeePerGas = outputBigIntegerFormatter6(block.baseFeePerGas);
  }
  return modifiedBlock;
};
var inputPostFormatter6 = (post) => {
  var _a16;
  const modifiedPost = Object.assign({}, post);
  if (post.ttl) {
    modifiedPost.ttl = numberToHex9(post.ttl);
  }
  if (post.workToProve) {
    modifiedPost.workToProve = numberToHex9(post.workToProve);
  }
  if (post.priority) {
    modifiedPost.priority = numberToHex9(post.priority);
  }
  if (post.topics && !Array.isArray(post.topics)) {
    modifiedPost.topics = post.topics ? [post.topics] : [];
  }
  modifiedPost.topics = (_a16 = modifiedPost.topics) === null || _a16 === void 0 ? void 0 : _a16.map((topic) => topic.startsWith("0x") ? topic : fromUtf87(topic));
  return modifiedPost;
};
var outputPostFormatter6 = (post) => {
  var _a16;
  const modifiedPost = Object.assign({}, post);
  if (post.expiry) {
    modifiedPost.expiry = hexToNumber8(post.expiry);
  }
  if (post.sent) {
    modifiedPost.sent = hexToNumber8(post.sent);
  }
  if (post.ttl) {
    modifiedPost.ttl = hexToNumber8(post.ttl);
  }
  if (post.workProved) {
    modifiedPost.workProved = hexToNumber8(post.workProved);
  }
  if (!post.topics) {
    modifiedPost.topics = [];
  }
  modifiedPost.topics = (_a16 = modifiedPost.topics) === null || _a16 === void 0 ? void 0 : _a16.map(toUtf86);
  return modifiedPost;
};
var outputSyncingFormatter6 = (result) => {
  const modifiedResult = Object.assign({}, result);
  modifiedResult.startingBlock = hexToNumber8(result.startingBlock);
  modifiedResult.currentBlock = hexToNumber8(result.currentBlock);
  modifiedResult.highestBlock = hexToNumber8(result.highestBlock);
  if (result.knownStates) {
    modifiedResult.knownStates = hexToNumber8(result.knownStates);
  }
  if (result.pulledStates) {
    modifiedResult.pulledStates = hexToNumber8(result.pulledStates);
  }
  return modifiedResult;
};

// node_modules/web3-eth-personal/node_modules/web3-core/lib/esm/web3_promi_event.js
init_shim();
var _a15;
_a15 = Symbol.toStringTag;

// node_modules/web3-eth-personal/lib/esm/rpc_method_wrappers.js
init_shim();
var __awaiter89 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getAccounts3 = (requestManager) => __awaiter89(void 0, void 0, void 0, function* () {
  const result = yield personal_rpc_methods_exports.getAccounts(requestManager);
  return result.map(toChecksumAddress8);
});
var newAccount2 = (requestManager, password) => __awaiter89(void 0, void 0, void 0, function* () {
  validator.validate(["string"], [password]);
  const result = yield personal_rpc_methods_exports.newAccount(requestManager, password);
  return toChecksumAddress8(result);
});
var unlockAccount2 = (requestManager, address, password, unlockDuration) => __awaiter89(void 0, void 0, void 0, function* () {
  validator.validate(["address", "string", "uint"], [address, password, unlockDuration]);
  return personal_rpc_methods_exports.unlockAccount(requestManager, address, password, unlockDuration);
});
var lockAccount2 = (requestManager, address) => __awaiter89(void 0, void 0, void 0, function* () {
  validator.validate(["address"], [address]);
  return personal_rpc_methods_exports.lockAccount(requestManager, address);
});
var importRawKey2 = (requestManager, keyData, passphrase) => __awaiter89(void 0, void 0, void 0, function* () {
  validator.validate(["string", "string"], [keyData, passphrase]);
  return personal_rpc_methods_exports.importRawKey(requestManager, keyData, passphrase);
});
var sendTransaction4 = (requestManager, tx, passphrase) => __awaiter89(void 0, void 0, void 0, function* () {
  const formattedTx = formatTransaction(tx, ETH_DATA_FORMAT);
  return personal_rpc_methods_exports.sendTransaction(requestManager, formattedTx, passphrase);
});
var signTransaction5 = (requestManager, tx, passphrase) => __awaiter89(void 0, void 0, void 0, function* () {
  const formattedTx = formatTransaction(tx, ETH_DATA_FORMAT);
  return personal_rpc_methods_exports.signTransaction(requestManager, formattedTx, passphrase);
});
var sign5 = (requestManager, data, address, passphrase) => __awaiter89(void 0, void 0, void 0, function* () {
  validator.validate(["string", "address", "string"], [data, address, passphrase]);
  const dataToSign = isHexStrict(data) ? data : utf8ToHex8(data);
  return personal_rpc_methods_exports.sign(requestManager, dataToSign, address, passphrase);
});
var ecRecover2 = (requestManager, signedData, signature) => __awaiter89(void 0, void 0, void 0, function* () {
  validator.validate(["string", "string"], [signedData, signature]);
  const signedDataString = isHexStrict(signedData) ? signedData : utf8ToHex8(signedData);
  return personal_rpc_methods_exports.ecRecover(requestManager, signedDataString, signature);
});

// node_modules/web3-eth-personal/lib/esm/personal.js
var __awaiter90 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Personal = class extends Web3Context6 {
  getAccounts() {
    return __awaiter90(this, void 0, void 0, function* () {
      return getAccounts3(this.requestManager);
    });
  }
  newAccount(password) {
    return __awaiter90(this, void 0, void 0, function* () {
      return newAccount2(this.requestManager, password);
    });
  }
  unlockAccount(address, password, unlockDuration) {
    return __awaiter90(this, void 0, void 0, function* () {
      return unlockAccount2(this.requestManager, address, password, unlockDuration);
    });
  }
  lockAccount(address) {
    return __awaiter90(this, void 0, void 0, function* () {
      return lockAccount2(this.requestManager, address);
    });
  }
  importRawKey(keyData, passphrase) {
    return __awaiter90(this, void 0, void 0, function* () {
      return importRawKey2(this.requestManager, keyData, passphrase);
    });
  }
  sendTransaction(tx, passphrase) {
    return __awaiter90(this, void 0, void 0, function* () {
      return sendTransaction4(this.requestManager, tx, passphrase);
    });
  }
  signTransaction(tx, passphrase) {
    return __awaiter90(this, void 0, void 0, function* () {
      return signTransaction5(this.requestManager, tx, passphrase);
    });
  }
  sign(data, address, passphrase) {
    return __awaiter90(this, void 0, void 0, function* () {
      return sign5(this.requestManager, data, address, passphrase);
    });
  }
  ecRecover(signedData, signature) {
    return __awaiter90(this, void 0, void 0, function* () {
      return ecRecover2(this.requestManager, signedData, signature);
    });
  }
};

// node_modules/web3-eth-personal/lib/esm/index.js
var esm_default4 = Personal;

// node_modules/web3/lib/esm/abi.js
init_shim();
var abi_default = {
  encodeEventSignature,
  encodeFunctionCall,
  encodeFunctionSignature,
  encodeParameter,
  encodeParameters: encodeParameters2,
  decodeParameter,
  decodeParameters: decodeParameters2,
  decodeLog
};

// node_modules/web3/lib/esm/accounts.js
init_shim();
var __awaiter91 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var initAccountsForContext = (context) => {
  const signTransactionWithContext = (transaction, privateKey) => __awaiter91(void 0, void 0, void 0, function* () {
    const tx = yield prepareTransactionForSigning(transaction, context);
    const privateKeyBytes = format({ format: "bytes" }, privateKey, ETH_DATA_FORMAT);
    return signTransaction3(tx, privateKeyBytes);
  });
  const privateKeyToAccountWithContext = (privateKey) => {
    const account = privateKeyToAccount(privateKey);
    return Object.assign(Object.assign({}, account), { signTransaction: (transaction) => __awaiter91(void 0, void 0, void 0, function* () {
      return signTransactionWithContext(transaction, account.privateKey);
    }) });
  };
  const decryptWithContext = (keystore, password, options) => __awaiter91(void 0, void 0, void 0, function* () {
    var _a16;
    const account = yield decrypt2(keystore, password, (_a16 = options === null || options === void 0 ? void 0 : options.nonStrict) !== null && _a16 !== void 0 ? _a16 : true);
    return Object.assign(Object.assign({}, account), { signTransaction: (transaction) => __awaiter91(void 0, void 0, void 0, function* () {
      return signTransactionWithContext(transaction, account.privateKey);
    }) });
  });
  const createWithContext = () => {
    const account = create();
    return Object.assign(Object.assign({}, account), { signTransaction: (transaction) => __awaiter91(void 0, void 0, void 0, function* () {
      return signTransactionWithContext(transaction, account.privateKey);
    }) });
  };
  const wallet = new Wallet({
    create: createWithContext,
    privateKeyToAccount: privateKeyToAccountWithContext,
    decrypt: decryptWithContext
  });
  return {
    signTransaction: signTransactionWithContext,
    create: createWithContext,
    privateKeyToAccount: privateKeyToAccountWithContext,
    decrypt: decryptWithContext,
    recoverTransaction,
    hashMessage,
    sign: sign3,
    recover,
    encrypt: encrypt2,
    wallet
  };
};

// node_modules/web3/lib/esm/version.js
init_shim();
var Web3PkgInfo = { version: "4.2.2" };

// node_modules/web3/lib/esm/web3.js
var Web3 = class extends Web3Context {
  constructor(providerOrContext) {
    var _a16;
    if (isNullish2(providerOrContext) || typeof providerOrContext === "string" && providerOrContext.trim() === "" || typeof providerOrContext !== "string" && !isSupportedProvider(providerOrContext) && !providerOrContext.provider) {
      console.warn("NOTE: web3.js is running without provider. You need to pass a provider in order to interact with the network!");
    }
    let contextInitOptions = {};
    if (typeof providerOrContext === "string" || isSupportedProvider(providerOrContext)) {
      contextInitOptions.provider = providerOrContext;
    } else if (providerOrContext) {
      contextInitOptions = providerOrContext;
    } else {
      contextInitOptions = {};
    }
    contextInitOptions.registeredSubscriptions = Object.assign(Object.assign({}, registeredSubscriptions), (_a16 = contextInitOptions.registeredSubscriptions) !== null && _a16 !== void 0 ? _a16 : {});
    super(contextInitOptions);
    const accounts = initAccountsForContext(this);
    this._wallet = accounts.wallet;
    this._accountProvider = accounts;
    this.utils = esm_exports4;
    const self2 = this;
    class ContractBuilder extends esm_default3 {
      constructor(jsonInterface, addressOrOptions, options) {
        if (typeof addressOrOptions === "object" && typeof options === "object") {
          throw new InvalidMethodParamsError("Should not provide options at both 2nd and 3rd parameters");
        }
        if (isNullish2(addressOrOptions)) {
          super(jsonInterface, options, self2.getContextObject());
        } else if (typeof addressOrOptions === "object") {
          super(jsonInterface, addressOrOptions, self2.getContextObject());
        } else if (typeof addressOrOptions === "string") {
          super(jsonInterface, addressOrOptions, options !== null && options !== void 0 ? options : {}, self2.getContextObject());
        } else {
          throw new InvalidMethodParamsError();
        }
        super.subscribeToContextEvents(self2);
      }
    }
    const eth = self2.use(Web3Eth);
    this.eth = Object.assign(eth, {
      ens: self2.use(ENS, registryAddresses.main),
      Iban,
      net: self2.use(Net),
      personal: self2.use(Personal),
      Contract: ContractBuilder,
      abi: abi_default,
      accounts
    });
  }
};
Web3.version = Web3PkgInfo.version;
Web3.utils = esm_exports4;
Web3.modules = {
  Web3Eth,
  Iban,
  Net,
  ENS,
  Personal
};
var web3_default = Web3;

// node_modules/web3/lib/esm/types.js
init_shim();

// node_modules/web3/lib/esm/eth.exports.js
var eth_exports_exports = {};
__export(eth_exports_exports, {
  ALL_EVENTS: () => ALL_EVENTS,
  ALL_EVENTS_ABI: () => ALL_EVENTS_ABI,
  LogsSubscription: () => LogsSubscription,
  NUMBER_DATA_FORMAT: () => NUMBER_DATA_FORMAT,
  NewHeadsSubscription: () => NewHeadsSubscription,
  NewPendingTransactionsSubscription: () => NewPendingTransactionsSubscription,
  SignatureObjectSchema: () => SignatureObjectSchema,
  SyncingSubscription: () => SyncingSubscription,
  Web3Eth: () => Web3Eth,
  abi: () => esm_exports12,
  accessListItemSchema: () => accessListItemSchema,
  accessListResultSchema: () => accessListResultSchema,
  accessListSchema: () => accessListSchema,
  accountSchema: () => accountSchema,
  accounts: () => esm_exports10,
  blockHeaderSchema: () => blockHeaderSchema,
  blockSchema: () => blockSchema,
  call: () => call2,
  chainSchema: () => chainSchema,
  contract: () => esm_exports13,
  createAccessList: () => createAccessList2,
  customChainSchema: () => customChainSchema,
  decodeEventABI: () => decodeEventABI,
  detectTransactionType: () => detectTransactionType,
  ens: () => esm_exports14,
  estimateGas: () => estimateGas2,
  feeHistorySchema: () => feeHistorySchema,
  formatTransaction: () => formatTransaction,
  getBalance: () => getBalance2,
  getBlock: () => getBlock,
  getBlockNumber: () => getBlockNumber2,
  getBlockTransactionCount: () => getBlockTransactionCount,
  getBlockUncleCount: () => getBlockUncleCount,
  getChainId: () => getChainId2,
  getCode: () => getCode2,
  getCoinbase: () => getCoinbase2,
  getFeeHistory: () => getFeeHistory2,
  getGasPrice: () => getGasPrice2,
  getHashRate: () => getHashRate2,
  getLogs: () => getLogs2,
  getPendingTransactions: () => getPendingTransactions2,
  getProof: () => getProof2,
  getProtocolVersion: () => getProtocolVersion2,
  getStorageAt: () => getStorageAt2,
  getTransaction: () => getTransaction,
  getTransactionCount: () => getTransactionCount2,
  getTransactionFromBlock: () => getTransactionFromBlock,
  getTransactionReceipt: () => getTransactionReceipt2,
  getUncle: () => getUncle,
  hardforkSchema: () => hardforkSchema,
  iban: () => esm_exports7,
  isAccessList: () => isAccessList2,
  isAccessListEntry: () => isAccessListEntry,
  isBaseTransaction: () => isBaseTransaction,
  isMining: () => isMining,
  isSyncing: () => isSyncing,
  isTransaction1559Unsigned: () => isTransaction1559Unsigned,
  isTransaction2930Unsigned: () => isTransaction2930Unsigned,
  isTransactionCall: () => isTransactionCall,
  isTransactionLegacyUnsigned: () => isTransactionLegacyUnsigned,
  isTransactionWithSender: () => isTransactionWithSender,
  logSchema: () => logSchema,
  personal: () => esm_exports15,
  prepareTransactionForSigning: () => prepareTransactionForSigning,
  registeredSubscriptions: () => registeredSubscriptions,
  sendSignedTransaction: () => sendSignedTransaction,
  sendTransaction: () => sendTransaction3,
  sign: () => sign4,
  signTransaction: () => signTransaction4,
  signTypedData: () => signTypedData2,
  storageProofSchema: () => storageProofSchema,
  syncSchema: () => syncSchema,
  transactionBuilder: () => transactionBuilder,
  transactionInfoSchema: () => transactionInfoSchema,
  transactionReceiptSchema: () => transactionReceiptSchema,
  transactionSchema: () => transactionSchema,
  validateBaseChain: () => validateBaseChain,
  validateChainInfo: () => validateChainInfo,
  validateCustomChainInfo: () => validateCustomChainInfo,
  validateFeeMarketGas: () => validateFeeMarketGas,
  validateGas: () => validateGas,
  validateHardfork: () => validateHardfork,
  validateLegacyGas: () => validateLegacyGas,
  validateTransactionCall: () => validateTransactionCall,
  validateTransactionForSigning: () => validateTransactionForSigning,
  validateTransactionWithSender: () => validateTransactionWithSender,
  withdrawalsSchema: () => withdrawalsSchema
});
init_shim();

// node_modules/web3/lib/esm/providers.exports.js
var providers_exports_exports = {};
__export(providers_exports_exports, {
  Eip1193Provider: () => Eip1193Provider,
  SocketProvider: () => SocketProvider,
  http: () => esm_exports5,
  ws: () => esm_exports6
});
init_shim();

// node_modules/web3/lib/esm/index.js
var esm_default5 = web3_default;
export {
  AbiError,
  BaseWeb3Error,
  BlockTags,
  ChainIdMismatchError,
  ChainMismatchError,
  CommonOrChainAndHardforkError,
  ConfigChainMismatchError,
  ConfigHardforkMismatchError,
  ConnectionCloseError,
  ConnectionError,
  ConnectionNotOpenError,
  ConnectionTimeoutError,
  Contract,
  ContractCodeNotStoredError,
  ContractEventDoesNotExistError,
  ContractExecutionError,
  ContractInstantiationError,
  ContractMissingABIError,
  ContractMissingDeployDataError,
  ContractNoAddressDefinedError,
  ContractNoFromAddressDefinedError,
  ContractOnceRequiresCallbackError,
  ContractReservedEventError,
  ContractTransactionDataAndInputError,
  DEFAULT_RETURN_FORMAT,
  EIP1193ProviderRpcError,
  ENSCheckInterfaceSupportError,
  ENSNetworkNotSyncedError,
  ENSUnsupportedNetworkError,
  ERR_ABI_ENCODING,
  ERR_CONN,
  ERR_CONN_CLOSE,
  ERR_CONN_INVALID,
  ERR_CONN_MAX_ATTEMPTS,
  ERR_CONN_NOT_OPEN,
  ERR_CONN_PENDING_REQUESTS,
  ERR_CONN_TIMEOUT,
  ERR_CONTRACT,
  ERR_CONTRACT_ABI_MISSING,
  ERR_CONTRACT_EVENT_NOT_EXISTS,
  ERR_CONTRACT_EXECUTION_REVERTED,
  ERR_CONTRACT_INSTANTIATION,
  ERR_CONTRACT_MISSING_ADDRESS,
  ERR_CONTRACT_MISSING_DEPLOY_DATA,
  ERR_CONTRACT_MISSING_FROM_ADDRESS,
  ERR_CONTRACT_REQUIRED_CALLBACK,
  ERR_CONTRACT_RESERVED_EVENT,
  ERR_CONTRACT_RESOLVER_MISSING,
  ERR_CONTRACT_TX_DATA_AND_INPUT,
  ERR_CORE_CHAIN_MISMATCH,
  ERR_CORE_HARDFORK_MISMATCH,
  ERR_ENS_CHECK_INTERFACE_SUPPORT,
  ERR_ENS_NETWORK_NOT_SYNCED,
  ERR_ENS_UNSUPPORTED_NETWORK,
  ERR_EXISTING_PLUGIN_NAMESPACE,
  ERR_FORMATTERS,
  ERR_INVALID_ADDRESS,
  ERR_INVALID_BLOCK,
  ERR_INVALID_BOOLEAN,
  ERR_INVALID_BYTES,
  ERR_INVALID_CLIENT,
  ERR_INVALID_HEX,
  ERR_INVALID_KEYSTORE,
  ERR_INVALID_LARGE_VALUE,
  ERR_INVALID_METHOD_PARAMS,
  ERR_INVALID_NIBBLE_WIDTH,
  ERR_INVALID_NUMBER,
  ERR_INVALID_PASSWORD,
  ERR_INVALID_PRIVATE_KEY,
  ERR_INVALID_PROVIDER,
  ERR_INVALID_RESPONSE,
  ERR_INVALID_SIGNATURE,
  ERR_INVALID_SIZE,
  ERR_INVALID_STRING,
  ERR_INVALID_TYPE,
  ERR_INVALID_TYPE_ABI,
  ERR_INVALID_UNIT,
  ERR_INVALID_UNSIGNED_INTEGER,
  ERR_IV_LENGTH,
  ERR_KEY_DERIVATION_FAIL,
  ERR_KEY_VERSION_UNSUPPORTED,
  ERR_METHOD_NOT_IMPLEMENTED,
  ERR_OPERATION_ABORT,
  ERR_OPERATION_TIMEOUT,
  ERR_PARAM,
  ERR_PBKDF2_ITERATIONS,
  ERR_PRIVATE_KEY_LENGTH,
  ERR_PROVIDER,
  ERR_RAW_TX_UNDEFINED,
  ERR_REQ_ALREADY_SENT,
  ERR_RESPONSE,
  ERR_RPC_INTERNAL_ERROR,
  ERR_RPC_INVALID_INPUT,
  ERR_RPC_INVALID_JSON,
  ERR_RPC_INVALID_METHOD,
  ERR_RPC_INVALID_PARAMS,
  ERR_RPC_INVALID_REQUEST,
  ERR_RPC_LIMIT_EXCEEDED,
  ERR_RPC_MISSING_RESOURCE,
  ERR_RPC_NOT_SUPPORTED,
  ERR_RPC_TRANSACTION_REJECTED,
  ERR_RPC_UNAVAILABLE_RESOURCE,
  ERR_RPC_UNSUPPORTED_METHOD,
  ERR_SCHEMA_FORMAT,
  ERR_SIGNATURE_FAILED,
  ERR_SUBSCRIPTION,
  ERR_TX,
  ERR_TX_BLOCK_TIMEOUT,
  ERR_TX_CHAIN_ID_MISMATCH,
  ERR_TX_CHAIN_MISMATCH,
  ERR_TX_CONTRACT_NOT_STORED,
  ERR_TX_DATA_AND_INPUT,
  ERR_TX_GAS_MISMATCH,
  ERR_TX_GAS_MISMATCH_INNER_ERROR,
  ERR_TX_HARDFORK_MISMATCH,
  ERR_TX_INVALID_CALL,
  ERR_TX_INVALID_CHAIN_INFO,
  ERR_TX_INVALID_FEE_MARKET_GAS,
  ERR_TX_INVALID_FEE_MARKET_GAS_PRICE,
  ERR_TX_INVALID_LEGACY_FEE_MARKET,
  ERR_TX_INVALID_LEGACY_GAS,
  ERR_TX_INVALID_NONCE_OR_CHAIN_ID,
  ERR_TX_INVALID_OBJECT,
  ERR_TX_INVALID_PROPERTIES_FOR_TYPE,
  ERR_TX_INVALID_RECEIVER,
  ERR_TX_INVALID_SENDER,
  ERR_TX_LOCAL_WALLET_NOT_AVAILABLE,
  ERR_TX_MISSING_CHAIN_INFO,
  ERR_TX_MISSING_CUSTOM_CHAIN,
  ERR_TX_MISSING_CUSTOM_CHAIN_ID,
  ERR_TX_MISSING_GAS,
  ERR_TX_MISSING_GAS_INNER_ERROR,
  ERR_TX_NOT_FOUND,
  ERR_TX_NO_CONTRACT_ADDRESS,
  ERR_TX_OUT_OF_GAS,
  ERR_TX_POLLING_TIMEOUT,
  ERR_TX_RECEIPT_MISSING_BLOCK_NUMBER,
  ERR_TX_RECEIPT_MISSING_OR_BLOCKHASH_NULL,
  ERR_TX_REVERT_INSTRUCTION,
  ERR_TX_REVERT_TRANSACTION,
  ERR_TX_REVERT_TRANSACTION_CUSTOM_ERROR,
  ERR_TX_REVERT_WITHOUT_REASON,
  ERR_TX_SEND_TIMEOUT,
  ERR_TX_SIGNING,
  ERR_TX_UNABLE_TO_POPULATE_NONCE,
  ERR_TX_UNSUPPORTED_EIP_1559,
  ERR_TX_UNSUPPORTED_TYPE,
  ERR_UNSUPPORTED_KDF,
  ERR_VALIDATION,
  ERR_WS_PROVIDER,
  ETH_DATA_FORMAT,
  Eip1559GasPriceError,
  Eip1559NotSupportedError,
  Eip838ExecutionError,
  ExistingPluginNamespaceError,
  FMT_BYTES,
  FMT_NUMBER,
  FormatterError,
  GENESIS_BLOCK_NUMBER,
  HardforkMismatchError,
  HardforksOrdered,
  HexProcessingError,
  HttpProvider,
  IVLengthError,
  Iban,
  InternalError,
  InvalidAddressError,
  InvalidBlockError,
  InvalidBooleanError,
  InvalidBytesError,
  InvalidClientError,
  InvalidConnectionError,
  InvalidGasOrGasPrice,
  InvalidInputError,
  InvalidKdfError,
  InvalidLargeValueError,
  InvalidMaxPriorityFeePerGasOrMaxFeePerGas,
  InvalidMethodParamsError,
  InvalidNonceOrChainIdError,
  InvalidNumberError,
  InvalidNumberOfParamsError,
  InvalidParamsError,
  InvalidPasswordError,
  InvalidPrivateKeyError,
  InvalidPropertiesForTransactionTypeError,
  InvalidProviderError,
  InvalidRequestError,
  InvalidResponseError,
  InvalidSignatureError,
  InvalidSizeError,
  InvalidStringError,
  InvalidTransactionCall,
  InvalidTransactionObjectError,
  InvalidTransactionWithReceiver,
  InvalidTransactionWithSender,
  InvalidTypeAbiInputError,
  InvalidTypeError,
  InvalidUnitError,
  InvalidUnsignedIntegerError,
  InvalidValueError,
  JSONRPC_ERR_CHAIN_DISCONNECTED,
  JSONRPC_ERR_DISCONNECTED,
  JSONRPC_ERR_REJECTED_REQUEST,
  JSONRPC_ERR_UNAUTHORIZED,
  JSONRPC_ERR_UNSUPPORTED_METHOD,
  KeyDerivationError,
  KeyStoreVersionError,
  LimitExceededError,
  LocalWalletNotAvailableError,
  MaxAttemptsReachedOnReconnectingError,
  MethodNotFoundError,
  MethodNotImplementedError,
  MethodNotSupported,
  MissingChainOrHardforkError,
  MissingCustomChainError,
  MissingCustomChainIdError,
  MissingGasError,
  MissingGasInnerError,
  Net,
  NibbleWidthError,
  NoContractAddressFoundError,
  OperationAbortError,
  OperationTimeoutError,
  PBKDF2IterationsError,
  ParseError,
  PendingRequestsOnReconnectingError,
  Personal,
  PrivateKeyLengthError,
  ProviderError,
  RequestAlreadySentError,
  ResolverMethodMissingError,
  ResourceUnavailableError,
  ResourcesNotFoundError,
  ResponseError,
  RevertInstructionError,
  RpcError,
  RpcErrorMessages,
  SchemaFormatError,
  SignatureError,
  SubscriptionError,
  TransactionBlockTimeoutError,
  TransactionDataAndInputError,
  TransactionError,
  TransactionGasMismatchError,
  TransactionGasMismatchInnerError,
  TransactionMissingReceiptOrBlockHashError,
  TransactionNotFound,
  TransactionOutOfGasError,
  TransactionPollingTimeoutError,
  TransactionReceiptMissingBlockNumberError,
  TransactionRejectedError,
  TransactionRevertInstructionError,
  TransactionRevertWithCustomError,
  TransactionRevertedWithoutReasonError,
  TransactionSendTimeoutError,
  TransactionSigningError,
  TypedArray,
  UnableToPopulateNonceError,
  UndefinedRawTransactionError,
  UnsupportedFeeMarketError,
  UnsupportedTransactionTypeError,
  VersionNotSupportedError,
  web3_default as Web3,
  Web3BaseProvider,
  Web3BaseWallet,
  Web3Context,
  Web3ContractError,
  Web3Eth,
  Web3EthPluginBase,
  Web3PluginBase,
  Web3Validator,
  Web3WSProviderError,
  WebSocketProvider,
  esm_exports8 as core,
  esm_default5 as default,
  esm_exports as errors,
  eth_exports_exports as eth,
  genericRpcErrorMessageTemplate,
  esm_exports11 as net,
  providers_exports_exports as providers,
  rpcErrorsMap,
  esm_exports9 as rpcMethods,
  esm_exports2 as types,
  esm_exports4 as utils,
  esm_exports3 as validator
};
/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
//# sourceMappingURL=web3.js.map
